{"code":{"thumbnail":"http://wonderfl.net/images/capture/5/57/571f/571fb1284ea31c2f8f13852998954668186a6739_100.jpg?t=1314372741","parent":"9R8a","as3":"// forked from keim_at_Si's Clear Water with refraction rendering forked from: 3D水面 / Water 3D\n// forked from saharan's 3D水面 / Water 3D\npackage {\n    import flash.system.LoaderContext;\n    import flash.display.*;\n    import flash.events.*;\n    import flash.geom.*;\n    import flash.net.*;\n    import com.bit101.components.*;\n    import net.hires.debug.*;\n\n    [SWF(frameRate = \"30\", width=\"465\", height=\"465\")]\n    public class main extends Sprite {\n        private const NUM_DETAILS:int = 48;\n        private const INV_NUM_DETAILS:Number = 1 / NUM_DETAILS;\n        private const MESH_SIZE:Number = 100;\n        private var count:uint;\n        private var bmd:BitmapData, bmd2:BitmapData, bmd3:BitmapData, tmp2:BitmapData;\n        private var loader:Loader, loader2:Loader;\n        private var vertices:Vector.<Vector3D>;\n        private var causticVertices:Vector.<Number>;\n        private var causticIndices:Vector.<int>;\n        private var transformedVertices:Vector.<Number>;\n        private var indices:Vector.<int>;\n        private var uvt:Vector.<Number>, uvt2:Vector.<Number>, uvt3:Vector.<Number>;\n        private var width2:Number;\n        private var height2:Number;\n        private var heights:Vector.<Vector.<Number>>;\n        private var velocity:Vector.<Vector.<Number>>;\n        \n/*      // for local\n        private var refractionTexture:String = \"_env1.png\";\n        private var reflectionTexture:String = \"_env2.png\";\n/*/     // for wonderfl\n        private var refractionTexture:String = \"http://assets.wonderfl.net/images/related_images/b/b2/b217/b2177f87d979a28b9bcbb6e0b89370e77ce22337\";\n        private var reflectionTexture:String = \"http://assets.wonderfl.net/images/related_images/b/bb/bbf1/bbf12c60cf84e5ab43e059920783d036da25df48\";\n//*/\n        private var viewedAngleH:Number = 0;\n        private var viewedAngleV:Number = -20 * 0.017453292519943295;\n        private var cameraDistance:Number = MESH_SIZE;\n        private var focalLength:Number = MESH_SIZE * 4;\n        private var boxHeight:Number = MESH_SIZE*0.75;\n        private var refractiveIndex:Number = 1.4;\n        private var enableCaustic:Boolean = true;\n        private var causticLayer:Shape;\n        private var reflectionLayer:Shape;\n        private var refractionLayer:Shape;\n        private var cameraPosition:Vector3D = new Vector3D();\n        private var m00:Number, m01:Number, m02:Number, m10:Number, m11:Number, m12:Number, m20:Number, m21:Number, m22:Number;\n        \n        function main() : void {\n            if (stage) init();\n            else addEventListener(Event.ADDED_TO_STAGE, init);\n        }\n\n    //-------------------------------------------------- initialize\n        private function init(e:Event = null):void {\n            removeEventListener(Event.ADDED_TO_STAGE, init);\n            stage.quality = StageQuality.LOW;\n            width2 = 465 / 2;\n            height2 = 465 / 2;\n            // var s:Stats = new Stats();\n            // s.alpha = 0.8;\n            // addChild(s);\n            count = 0;\n            loader = new Loader();\n            loader.load(new URLRequest(refractionTexture), new LoaderContext(true));\n            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, loaded);\n            loader2 = new Loader();\n            loader2.load(new URLRequest(reflectionTexture), new LoaderContext(true));\n            loader2.contentLoaderInfo.addEventListener(Event.COMPLETE, loaded);\n            stage.addEventListener(MouseEvent.MOUSE_DOWN, mouseDown);\n            vertices = new Vector.<Vector3D>(NUM_DETAILS * NUM_DETAILS, true);\n            transformedVertices = new Vector.<Number>(NUM_DETAILS * NUM_DETAILS * 2, true);\n            indices = new Vector.<int>();\n            uvt = new Vector.<Number>(NUM_DETAILS * NUM_DETAILS * 2, true);\n            uvt2 = new Vector.<Number>(NUM_DETAILS * NUM_DETAILS * 2, true);\n            uvt3 = new Vector.<Number>(NUM_DETAILS * NUM_DETAILS * 2, true);\n            var i:int;\n            var j:int;\n            // 頂点初期化。外側2つ分は表示しないので無駄な処理＆メモリに・・・\n            // [modification] change surface from x-z plane to x-y plane in order to fit together with normal calculation.\n            for (i = 2; i < NUM_DETAILS - 2; i++) {\n                for (j = 2; j < NUM_DETAILS - 2; j++) {\n                    vertices[getIndex(j, i)] = new Vector3D(\n                        (j - (NUM_DETAILS - 1) * 0.5) / NUM_DETAILS * MESH_SIZE,\n                        (i - (NUM_DETAILS - 1) * 0.5) / NUM_DETAILS * MESH_SIZE, 0);\n                    if (i != 2 && j != 2) {\n                        indices.push(getIndex(i - 1, j - 1), getIndex(i, j - 1), getIndex(i, j));\n                        indices.push(getIndex(i - 1, j - 1), getIndex(i, j), getIndex(i - 1, j));\n                    }\n                }\n            }\n            function getIndex(x:int, y:int):int { return y * NUM_DETAILS + x; }\n            // 水面関係初期化\n            heights = new Vector.<Vector.<Number>>(NUM_DETAILS, true);\n            velocity = new Vector.<Vector.<Number>>(NUM_DETAILS, true);\n            causticVertices = new Vector.<Number>(NUM_DETAILS * NUM_DETAILS * 2, true);\n            causticIndices = new Vector.<int>();\n            for (i = 0; i < NUM_DETAILS; i++) {\n                heights[i] = new Vector.<Number>(NUM_DETAILS, true);\n                velocity[i] = new Vector.<Number>(NUM_DETAILS, true);\n                for (j = 0; j < NUM_DETAILS; j++) {\n                    heights[i][j] = 0;\n                    velocity[i][j] = 0;\n                    causticVertices[(i*NUM_DETAILS+j)*2]   = (j - 2) / (NUM_DETAILS - 5) * 512;\n                    causticVertices[(i*NUM_DETAILS+j)*2+1] = (i - 2) / (NUM_DETAILS - 5) * 512;\n                }\n            }\n            for (i = 1; i < NUM_DETAILS; i++) {\n                for (j = 1; j < NUM_DETAILS; j++) {\n                    causticIndices.push((i-1)*NUM_DETAILS+j-1, (i-1)*NUM_DETAILS+j, i*NUM_DETAILS+j-1);\n                    causticIndices.push((i-1)*NUM_DETAILS+j, i*NUM_DETAILS+j, i*NUM_DETAILS+j-1);\n                }\n            }            \n            // [modification] Rendering layers\n            addChild(refractionLayer = new Shape());\n            addChild(reflectionLayer = new Shape());\n            causticLayer = new Shape();\n            reflectionLayer.alpha = 0.3;\n            // [modification] controlers\n            new HUISlider(this, 0, 0, \"Angle\", function(e:Event):void { viewedAngleV = -e.target.value* 0.017453292519943295;}).setSliderParams(0, 80, 20);\n            new HUISlider(this, 0, 20, \"Refraction\", function(e:Event):void { refractiveIndex = e.target.value;}).setSliderParams(1, 3, 1.4);\n            new HUISlider(this, 0, 40, \"Reflection\", function(e:Event):void { reflectionLayer.alpha = e.target.value;}).setSliderParams(0, 1, 0.3);\n            new CheckBox(this, 10, 64, \"Caustics\", function(e:Event):void { enableCaustic = e.target.selected;}).selected = enableCaustic;\n        }\n        \n    //-------------------------------------------------- events\n        private function loaded(e:Event) : void {\n            e.target.removeEventListener(e.type, arguments.callee);\n            if (loader.content && loader2.content) {\n                bmd  = Bitmap(loader.content).bitmapData;\n                bmd2 = Bitmap(loader2.content).bitmapData;\n                createCausticTexture();\n                addEventListener(Event.ENTER_FRAME, frame);\n            }\n        }\n        \n        private function createCausticTexture() : void {\n            tmp2 = new BitmapData(bmd2.width, bmd2.height, false, 0);\n            bmd3 = new BitmapData(128, 128, false, 0x404040);\n            var shape:Shape = new Shape(), g:Graphics = shape.graphics, m:Matrix=new Matrix();\n            m.createGradientBox(96, 96);\n            g.beginGradientFill(\"radial\", [0xd0d0d0,0x808080,0x404040], [1,1,1], [0,48,255], m);\n            g.drawRect(0, 0, 96, 96);\n            g.endFill();\n            bmd3.draw(shape, new Matrix(1,0,0,1,16,48));\n        }\n        \n        private function mouseDown(e:MouseEvent) : void {\n            stage.addEventListener(MouseEvent.MOUSE_UP, mouseUp);\n            stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseDrag);\n            ripple((mouseY -232.5)/ 465 * MESH_SIZE, (mouseX -232.5)/ 465 * MESH_SIZE, 16);\n        }\n        \n        private function mouseUp(e:MouseEvent) : void {\n            stage.removeEventListener(MouseEvent.MOUSE_UP, mouseUp);\n            stage.removeEventListener(MouseEvent.MOUSE_MOVE, mouseDrag);\n        }\n        \n        private function mouseDrag(e:MouseEvent) : void {\n            ripple((mouseY -232.5)/ 465 * MESH_SIZE, (mouseX -232.5)/ 465 * MESH_SIZE, 4);\n        }\n        \n        private function ripple(mx:Number, my:Number, intensity:Number) : void {\n            var i:int, j:int, dx:Number, dy:Number, acc:Number, imin:int, jmin:int, imax:int, jmax:int;\n            mx = (mx / MESH_SIZE + 0.5) * NUM_DETAILS;\n            my = (my / MESH_SIZE + 0.5) * NUM_DETAILS;\n            imin = (mx > 5) ? int(mx - 3) : 2;\n            jmin = (my > 5) ? int(my - 3) : 2;\n            imax = (mx < NUM_DETAILS-5) ? int(mx + 4) : (NUM_DETAILS - 1);\n            jmax = (my < NUM_DETAILS-5) ? int(my + 4) : (NUM_DETAILS - 1);\n            for (i=imin; i<imax; i++) for (j=jmin; j<jmax; j++) {\n                dx = mx - i;\n                dy = my - j;\n                acc = 3 - Math.sqrt(dx * dx + dy * dy);\n                if (acc > 0) velocity[i][j] += acc*intensity;\n            }\n        }\n        \n    //-------------------------------------------------- on each frame\n        private function frame(e:Event = null):void {\n            count++;\n            move();\n            setMesh();\n            transformVertices();\n            draw();\n        }\n\n        private function move():void {\n            // ---Water simulation---\n            var i:int;\n            var j:int;\n            for (i = 1; i < NUM_DETAILS - 1; i++) {\n                for (j = 1; j < NUM_DETAILS - 1; j++) {\n                    heights[i][j] += velocity[i][j];\n                    if (heights[i][j] > 100) heights[i][j] = 100;\n                    else if (heights[i][j] < -100) heights[i][j] = -100;\n                }\n            }\n            for (i = 1; i < NUM_DETAILS - 1; i++) {\n                for (j = 1; j < NUM_DETAILS - 1; j++) {\n                    velocity[i][j] = (velocity[i][j] +\n                        (heights[i - 1][j] + heights[i][j - 1] + heights[i + 1][j] +\n                        heights[i][j + 1] - heights[i][j] * 4) * 0.5) * 0.95;\n                }\n            }\n            \n            // why dont I use Matrix3D !?\n//            var viewedAngleH:Number =   (mouseX -232.5) / 465 * 40 * 0.017453292519943295,\n//                viewedAngleV:Number = -((mouseY -232.5) / 465 * 40 + 40) * 0.017453292519943295;\n            var sx:Number = Math.sin(viewedAngleV), sy:Number = Math.sin(viewedAngleH), \n                cx:Number = Math.cos(viewedAngleV), cy:Number = Math.cos(viewedAngleH);\n            m00 = cy;\n            m01 = 0;\n            m02 = -sy;\n            m10 = sy*sx;\n            m11 = cx;\n            m12 = cy*sx;\n            m20 = sy*cx;\n            m21 = -sx;\n            m22 = cy*cx;\n            cameraPosition.x = -cameraDistance * m02;\n            cameraPosition.y = -cameraDistance * m12;\n            cameraPosition.z = -cameraDistance * m22;\n        }\n\n        private function setMesh():void {\n            // calclate constants\n            var rimo:Number = refractiveIndex - 1,\n                xymax:Number = MESH_SIZE * 0.45, //MESH_SIZE * 0.5,\n                ixymax:Number = 1 / xymax;\n            \n            for (var i:int = 2; i < NUM_DETAILS - 2; i++) {\n                for (var j:int = 2; j < NUM_DETAILS - 2; j++) {\n                    var index:int = i * NUM_DETAILS + j, idx2:int = index*2, idx21:int = index*2+1;\n                    var v:Vector3D = vertices[index];\n                    v.z = heights[i][j] * 0.15;\n                    \n                    // ---Sphere map---\n                    var nx:Number, ny:Number, nz:Number;\n                    nx = (heights[i][j] - heights[i - 1][j]) * 0.15;\n                    ny = (heights[i][j] - heights[i][j - 1]) * 0.15;\n                    var len:Number = 1 / Math.sqrt(nx * nx + ny * ny + 1);\n                    nx *= len;\n                    ny *= len;\n                    nz = len;\n                    // ちょっと式を変更して平面でもテクスチャが見えるように\n                    uvt3[idx2] = nx * 0.5 + 0.5;\n                    uvt3[idx21] = ny * 0.5 + 0.5;\n                    uvt[idx2] = uvt3[idx2] + ((i - NUM_DETAILS * 0.5) * INV_NUM_DETAILS * 0.25);\n                    uvt[idx21] = uvt3[idx21] + ((NUM_DETAILS * 0.5 - j) * INV_NUM_DETAILS * 0.25);\n                    \n                    // [modification] Refraction map\n                    // incident vector (you can calculate them in the setup if you want faster)\n                    var dx:Number = v.x - cameraPosition.x, dy:Number = v.y - cameraPosition.y, dz:Number = v.z - cameraPosition.z;\n                    len = 1 / Math.sqrt(dx * dx + dy * dy + dz * dz);\n                    dx *= len;\n                    dy *= len;\n                    dz *= len;\n                    // output vector\n                    t = (dx * nx + dy * ny + dz) * rimo;\n                    dx += nx * t;\n                    dy += ny * t;\n                    dz += nz * t;\n                    // in this calculation, we can omit normalization of output vector !\n                    //len = 1 / Math.sqrt(dx * dx + dy * dy + dz * dz);\n                    //dx *= len;\n                    //dy *= len;\n                    //dz *= len;\n                    // uv coordinate\n                    var t:Number, s:Number, r:Number, hitz:Number, sign:Number;\n                    if (dx == 0) {\n                        if (dy == 0) {\n                            uvt2[idx2] = uvt2[idx21] = 0.5;\n                            sign = 0;\n                        } else sign = (dy < 0) ? -1 : 1;\n                    } else {\n                        sign = (dx < 0) ? -1 : 1;\n                        t = (sign * xymax - v.x) / dx;\n                        s = t * dy + v.y;\n                        if (-xymax < s && s < xymax) {\n                            hitz = t * dz + v.z;\n                            if (hitz > boxHeight) {\n                                r = (boxHeight-v.z) / dz;\n                                uvt2[idx2]  = (dx * r + v.x) * ixymax * 0.25 + 0.5;\n                                uvt2[idx21] = (dy * r + v.y) * ixymax * 0.25 + 0.5;\n                            } else {\n                                r = boxHeight / (hitz + boxHeight);\n                                uvt2[idx2]  = sign       * r * 0.5 + 0.5;\n                                uvt2[idx21] = s * ixymax * r * 0.5 + 0.5;\n                            }\n                            sign = 0;\n                        } else sign = (s < 0) ? -1 : 1;\n                    }\n                    if (sign != 0) {\n                        t = (sign * xymax - v.y) / dy;\n                        s = t * dx + v.x;\n                        hitz = t * dz + v.z;\n                        if (hitz > boxHeight) {\n                            r = (boxHeight-v.z) / dz;\n                            uvt2[idx2]  = (dx * r + v.x) * ixymax * 0.25 + 0.5;\n                            uvt2[idx21] = (dy * r + v.y) * ixymax * 0.25 + 0.5;\n                        } else {\n                            r = boxHeight / (hitz + boxHeight);\n                            uvt2[idx2]  = s * ixymax * r * 0.5 + 0.5;\n                            uvt2[idx21] = sign       * r * 0.5 + 0.5;\n                        }\n                    }\n                    //trace(v.x,v.y,dx,dy,uvt2[index * 2],uvt2[index * 2+1]);\n                }\n            }\n            //throw new Error(\"STOPPER!!\");\n        }\n        \n        private function transformVertices():void {\n            var iz:Number, v:Vector3D, i:int, imax:int = vertices.length;\n            for (i = 0; i < imax; i++) {\n                v = vertices[i];\n                if (v != null) {\n                    iz = focalLength / (v.x * m02 + v.y * m12 + v.z * m22 + cameraDistance);\n                    transformedVertices[i*2]   = (v.x * m00 + v.y * m10 + v.z * m20) * iz + 232.5;\n                    transformedVertices[i*2+1] = (v.x * m01 + v.y * m11 + v.z * m21) * iz + 232.5;\n                }\n            }\n        }\n        \n        private function draw():void {\n            var refractionGraphics:Graphics = refractionLayer.graphics,\n                reflectionGraphics:Graphics = reflectionLayer.graphics,\n                causticGraphics:Graphics = causticLayer.graphics;\n            graphics.clear();\n            graphics.beginFill(0x202020);\n            graphics.drawRect(0, 0, 465, 465);\n            graphics.endFill();\n            tmp2.copyPixels(bmd2, bmd2.rect, bmd2.rect.topLeft);\n            if (enableCaustic) {\n                causticGraphics.clear();\n                causticGraphics.beginBitmapFill(bmd3);\n                causticGraphics.drawTriangles(causticVertices, causticIndices, uvt3);\n                causticGraphics.endFill();\n                tmp2.draw(causticLayer, null, null, \"hardlight\");\n            }\n            // [modification] compose all layers\n            refractionGraphics.clear();\n            refractionGraphics.beginBitmapFill(tmp2);\n            refractionGraphics.drawTriangles(transformedVertices, indices, uvt2, TriangleCulling.NEGATIVE);\n            refractionGraphics.endFill();\n            reflectionGraphics.clear();\n            reflectionGraphics.beginBitmapFill(bmd);\n            reflectionGraphics.drawTriangles(transformedVertices, indices, uvt, TriangleCulling.NEGATIVE);\n            reflectionGraphics.endFill();\n        }\n    }\n}\n","modified_date":1314376117,"compile_ok":"1","created_date":1314372497,"forked_count":"3","license":"MIT","swf":"http://swf.wonderfl.net/swf/usercode/5/57/571f/571fb1284ea31c2f8f13852998954668186a6739.swf","diff":"70","user":{"icon":"http://wonderfl.net/images/icon/2/27/278a/278afc585a0a283d6e1f13f081cfd9c377ab9db2m","name":"keim_at_Si"},"title":"Clear Water with caustics","id":"cqJr","favorite_count":"38"},"stat":"ok"}