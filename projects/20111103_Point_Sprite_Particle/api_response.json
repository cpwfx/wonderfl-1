{"code":{"thumbnail":"http://wonderfl.net/images/capture/6/6d/6d91/6d917938f75e1b98b592073d29b9d815d91712e6_100.jpg?t=1320864147","parent":null,"as3":"package {\n    import flash.display.*;\n    import flash.events.*;\n    import flash.utils.*;\n    import flash.geom.*;\n    import flash.text.*;\n    import flash.net.*;\n    \n    import com.adobe.utils.*;\n    import com.bit101.components.*;\n    import flash.display3D.*;\n    import flash.display3D.textures.*;\n//    import org.si.ptolemy.*;\n//    import org.si.ptolemy.core.*;\n    \n    import org.si.sion.*;\n    import org.si.sion.events.*;\n    import org.si.sound.*;\n\n    public class main extends Sprite {\n/*      // for local\n        private const gradURL:String = \"grad.swf\";\n        private const partURL:String = \"part.png\";\n/*/     // for wonderfl\n        private const gradURL:String = \"http://swf.wonderfl.net/swf/usercode/2/2c/2c1a/2c1a167b1a4db168e952e96df4e3d642544eb624.swf?t=1\";\n        private const partURL:String = \"http://assets.wonderfl.net/images/related_images/6/6a/6a2d/6a2dffe6da5745c6a74c28a52a163077689afdab\";\n//*/\n        \n        private var controler:Sprite;\n        private var ptolemy:Ptolemy;\n        private var asm:AGALMiniAssembler = new AGALMiniAssembler();\n        private var programs:Vector.<Program3D> = new Vector.<Program3D>();\n        private var _psf:PointSpriteField;\n        private var _texInfo:Vector.<PointSpriteTexInfo> = new Vector.<PointSpriteTexInfo>(4, true);\n        private var _bmd:BitmapData, _tex:Texture;\n        private var _prevTime:uint, _prevBeatTime:uint, _startTime:uint;\n        \n        private var sion:SiONDriver = new SiONDriver();\n        private var beat:Number = 0, beatPerMS:Number;\n        \n        function main() {\n            Wonderfl.disable_capture();\n            ptolemy = new Ptolemy(this, 8, 8, 450, 450);\n            ptolemy.addEventListener(Event.COMPLETE, setup);\n            ptolemy.load(new URLRequest(gradURL), \"grad\", \"img\");\n            ptolemy.load(new URLRequest(partURL), \"particle\", \"img\", true);\n            stage.addEventListener(MouseEvent.MOUSE_DOWN, function(e:MouseEvent) : void {\n                stage.addEventListener(MouseEvent.MOUSE_UP, function(e:MouseEvent) : void {\n                    stage.removeEventListener(MouseEvent.MOUSE_UP, arguments.callee);\n                    stage.removeEventListener(MouseEvent.MOUSE_MOVE, _dragging);\n                });\n                stage.addEventListener(MouseEvent.MOUSE_MOVE, _dragging);\n            })\n        }\n        \n        private function setup(e:Event) : void {\n            var i:int, prog:Program3D, a:Number, b:Number;\n            var context3D:Context3D = ptolemy.context3D;\n            removeEventListener(Event.COMPLETE, setup);\n            context3D.enableErrorChecking = true;\n            context3D.setCulling(\"none\");\n            context3D.setDepthTest(false, \"always\");\n            context3D.setBlendFactors(Context3DBlendFactor.SOURCE_ALPHA, Context3DBlendFactor.ONE);\n            _psf = new PointSpriteField(context3D, 1024);\n            initialize();\n            \n            var GradEditor:Class = ptolemy.resources[\"grad\"].getClass();\n            addChild(controler = new Sprite());\n            controler.x = controler.y = 8;\n            controler.graphics.beginFill(0x404040, 0.6);\n            controler.graphics.drawRect(0, 0, 180, 80);\n            controler.graphics.endFill();\n            with(new HUISlider(controler, 0, 20, \"numEmitters\", function(e:Event):void{ setting.emitCount = e.target.value;})) {\n                setSliderParams(1, 64, setting.emitCount); tick = 1;\n            }\n            with(new HUISlider(controler, 0, 40, \"particleShape\", function(e:Event):void{ setting.tex = _texInfo[int(e.target.value)];})) {\n                setSliderParams(0, 3, 0); tick = 1;\n            }\n            with(new HUISlider(controler, 0, 60, \"bpm\", function(e:Event):void{ sion.bpm = e.target.value; beatPerMS = sion.bpm / 60000;})) {\n                setSliderParams(80, 200, 132);\n            }\n            var ge:* = new GradEditor(controler, 2, 2, \"gradation\", {color:[0xff8080,0x4040c0],alpha:[1,1],ratio:[0,192]}, \nfunction(e:Event):void { grad.create(ge.colorArray,ge.ratioArray);});\n            ge.setSize(120,12);\n            ge.changeImmediately = true;\n            ge.alphaEnabled = false;\n            _bmd = Bitmap(ptolemy.resources[\"particle\"]).bitmapData;\n            _tex = context3D.createTexture(_bmd.width, _bmd.height, \"bgra\", false);\n            _tex.uploadFromBitmapData(_bmd);\n            _texInfo[0] = new PointSpriteTexInfo(0,0,0.5,0.5,32,32);\n            _texInfo[1] = new PointSpriteTexInfo(0.5,0,1,0.5,32,32);\n            _texInfo[2] = new PointSpriteTexInfo(0,0.5,0.5,1,32,32);\n            _texInfo[3] = new PointSpriteTexInfo(0.5,0.5,1,1,32,32);\n            context3D.setTextureAt(0, _tex);\n            \n            for (i=0; i<shaders.length; i++) {\n                prog = context3D.createProgram();\n                prog.upload(asm.assemble(\"vertex\", shaders[i].vs), asm.assemble(\"fragment\", shaders[i].fs));\n                programs.push(prog);\n            }\n            \n            context3D.setProgramConstantsFromVector(\"vertex\", 126, Vector.<Number>([ptolemy.sigl.pointSpriteFieldScale.x, ptolemy.sigl.pointSpriteFieldScale.y, 0, 0]));\n            context3D.setProgramConstantsFromVector(\"vertex\", 127, Vector.<Number>([0,0.5,1,2]));\n\n            Emitter.tex = _texInfo[3];\n            setting.tex = _texInfo[0];\n            for (i=0; i<64; i++) emitters.push(new Emitter(i));\n            _startTime = _prevBeatTime = _prevTime = getTimer();\n            \n            sion.bpm = 132;\n            beatPerMS = sion.bpm / 60000;\n            beat = 0;\n            sion.addEventListener(SiONTrackEvent.BEAT, _onBeat);\n            sion.play();\n            new DrumMachine(0,8,0,2,2,0).play();\n            \n            addEventListener(Event.ENTER_FRAME, draw);\n        }\n        \n        private function draw(e:Event) : void {\n            var context3D:Context3D = ptolemy.context3D, i:int, \n                sigl:SiGLCore = ptolemy.sigl, s:Number = Math.random()*0.5 + 3,\n                now:uint = getTimer(), dbeat:Number = (now-_prevBeatTime)*beatPerMS, dt:Number = (now-_prevTime)*0.001;\n            \n            var center:Vector3D = trocLarge.calc((now - _startTime)*0.00005);\n            _psf.clearSprites();\n            for (i=0; i<setting.emitCount; i++) emitters[i].update(_psf, dbeat+beat);\n            Particle.update(_psf, dt);\n            \n            rx += (tx-rx)*0.05;\n            rz += (tz-rz)*0.05;\n            sigl.id().r(rx,Vector3D.X_AXIS).r(rz,Vector3D.Y_AXIS).t(center.x, center.y, center.z);\n            context3D.clear(0, 0, 0, 1);\n            context3D.setProgram(programs[0]);\n            context3D.setProgramConstantsFromMatrix(\"vertex\", 0, sigl.modelViewProjectionMatrix, true);\n            _psf.drawTriangles(context3D);\n            //if(!_sc){_sc = new BitmapData(450,450,false,0);with(addChildAt(new Bitmap(_sc),0)){x=y=8;}}context3D.drawToBitmapData(_sc);\n            context3D.present();\n            _prevTime = now;\n        }\n        private var _sc:BitmapData = null;\n        \n        private var rx:Number=0, rz:Number=0, tx:Number=0, tz:Number=0;\n        private function _dragging(e:MouseEvent) : void {\n            tz = (mouseX-233)*0.5;\n            tx = (mouseY-233)*0.5;\n        }\n        \n        private function _onBeat(e:SiONTrackEvent) : void {\n            beat++;\n            _prevBeatTime = getTimer();\n        }\n    }\n}\n\n\n\nvar vs0:String = <agal><![CDATA[\nm44 vt0, va0, vc0\nmov vt1.xy, va1\nmov vt1.zw, vc127.xx\ndiv vt1.xy, vt1.xy, vt0.w\nmul vt1.xy, vt1.xy, vc126.xy\nadd op, vt0, vt1\nmov v0, va2\nmov v1, va3\nmov v2, va4\n]]></agal>;\nvar fs0:String = <agal><![CDATA[\ntex ft0, v0.xy, fs0 <2d, clamp, nearest>\nmul ft0, ft0, v1\nadd ft0, ft0, v2\nsat oc, ft0\n]]></agal>;\n\nvar shaders:Array = [{\"vs\":vs0,\"fs\":fs0}];\n\n\n\n\nimport flash.geom.*;\nimport flash.display.*;\n//import org.si.ptolemy.core.*;\n\nvar emitters:Array = [];\nvar emitCenter:Vector3D = new Vector3D();\nvar troc:Trochoid3D, trocLarge:Trochoid3D, grad:Gradation, setting:ParticleSetting;\nvar s$:Vector.<Number> = new Vector.<Number>(8192, true);\nvar c$:Vector.<Number> = new Vector.<Number>(8192, true);\n\n\nfunction initialize() : void {\n    for (var i:int=0;i<8192;i++) c$[(i-2048)&8191] = s$[i] = Math.sin(i*0.0007669903939428206);\n    troc = new Trochoid3D(60, 40, 50, 3, 2, 5, 0, 0, 0);\n    trocLarge = new Trochoid3D(400, 300, 400, 2, 1, 3, 0, 0, 0);\n    grad = new Gradation();\n    grad.create([0xff8080,0x402080,0],[0,128,255]);\n    setting = new ParticleSetting({vvar:200, grav:-1000, vforce:-300, rotvar:1440, mag:2, life:2});\n}\n\nclass ParticleSetting {\n    public var vforce:Number = 0, reduction:Number = 0, life:Number = 1, lifevar:Number = 0;\n    public var vini:Number = 0, vvar:Number = 0, vz:Number = 0, grav:Number = 0, acc:Number = 0;\n    public var angini:Number = 0, angvar:Number = 0, rotini:Number=0, rotvar:Number=0;\n    public var sclini:Number = 1, sclvar:Number = 0, mag:Number=1, tex:PointSpriteTexInfo;\n    public var emitCount:int=10, emitInterval:int=2, numParticle:int=1;\n    function ParticleSetting(param:* = null) {\n        if (param) for (var key:String in param) this[key] = param[key];\n    }\n}\n\n\nclass Trochoid3D {\n    public var r0:Number, r1:Number, r2:Number, f0:Number, f1:Number, f2:Number, p0:Number, p1:Number, p2:Number;\n    public var $:Vector3D = new Vector3D(), matrix3D:Matrix3D = new Matrix3D();\n    static private var _in:Vector.<Number> = new Vector.<Number>(3, true);\n    static private var _out:Vector.<Number> = new Vector.<Number>(3, true);\n    function Trochoid3D(r0:Number=1, r1:Number=0.5, r2:Number=0.71, f0:Number=2, f1:Number=1, f2:Number=3, p0:Number=0, p1:Number=0, p2:Number=0) {\n        init(r0, r1, r2, f0, f1, f2, p0, p1, p2);\n    }\n    public function init(r0:Number, r1:Number, r2:Number, f0:Number, f1:Number, f2:Number, p0:Number=0, p1:Number=0, p2:Number=0) : void {\n        this.r0 = r0; this.p0 = p0 * 6.283185307179586; this.f0 =  f0 * 6.283185307179586; \n        this.r1 = r1; this.p1 = p1 * 6.283185307179586; this.f1 = -f1 * 6.283185307179586; \n        this.r2 = r2; this.p2 = p2 * 6.283185307179586; this.f2 =  f2 * 6.283185307179586;\n    }\n    public function calc(t:Number) : Vector3D {\n        var a0:Number = t*f0+p0, a1:Number = t*f1+p1, a2:Number = t*f2+p2, \n            s0:Number = Math.sin(a0), s1:Number = Math.sin(a1), s2:Number = Math.sin(a2), \n            c0:Number = Math.cos(a0), c1:Number = Math.cos(a1);\n        _in[0] = c0 * r0 + c1 * r1;\n        _in[1] = s0 * r0 + s1 * r1;\n        _in[2] = s2 * r2;\n        matrix3D.transformVectors(_in, _out);\n        $.setTo(_out[0], _out[1], _out[2]);\n        return $;\n    }\n}\n\nclass Gradation {\n    public var $:Vector.<Vector3D> = new Vector.<Vector3D>(512, true);\n    function Gradation() { for (var i:int=0; i<512; i++) $[i] = new Vector3D(1,1,1); }\n    public function create(color:Array, ratio:Array) : void {\n        var m:Matrix = new Matrix(), s:Shape = new Shape(), g:Graphics = s.graphics,\n            b:BitmapData = new BitmapData(512, 1, false), i:int, c:uint, alpha:Array=[];\n        for (i=0; i<color.length; i++) alpha.push(1);\n        m.createGradientBox(512, 1, 0, 0, 0);\n        g.beginGradientFill(\"linear\", color, alpha, ratio, m);\n        g.drawRect(0,0,512,1);\n        g.endFill();\n        b.draw(s);\n        for (i=0; i<512; i++) {\n            c = b.getPixel(i, 0);\n            $[i].x = ((c>>16) & 0xff) * 0.00392156862745098;\n            $[i].y = ((c>>8)  & 0xff) * 0.00392156862745098;\n            $[i].z = ( c      & 0xff) * 0.00392156862745098;\n        }\n    }\n}\n\nclass Emitter extends Vector3D {\n    static public var tex:PointSpriteTexInfo;\n    static private var _in:Vector.<Number> = new Vector.<Number>(3);\n    static private var _out:Vector.<Number> = new Vector.<Number>(3)\n    static private var _mat:Matrix3D = new Matrix3D();\n    static private var _vec:Vector3D = new Vector3D();\n    public var index:Number, prev:Vector3D, count:int=0;\n    function Emitter(index:Number) { super(); this.index = index; prev = clone(); }\n    public function update(psf:PointSpriteField, beat:Number) : void {\n        var t:Number = index/setting.emitCount, c:Vector3D = trocLarge.$, r:Vector3D = troc.calc(beat/setting.emitCount+t);\n        setTo(r.x-c.x, r.y-c.y, r.z-c.z);\n        psf.createSprite(tex, x, y, z);\n        if (++count >= setting.emitInterval) {\n            _vec.setTo(x-prev.x, y-prev.y, z-prev.z);\n            _vec.normalize();\n            for (var i:int=0; i<setting.numParticle; i++) Particle.alloc(x, y, z, _vec);\n            count = 0;\n        }\n        prev.copyFrom(this);\n    }\n}\n\nclass Particle extends Vector3D {\n    static private var _vtemp:Vector3D = new Vector3D();\n    static private var _activeList:Particle = null;\n    static private var _freeList:Particle = null;\n    public var next:Particle, tex:PointSpriteTexInfo, life:Number, age:Number;\n    public var vx:Number, vy:Number, vz:Number, ax:Number, ay:Number, az:Number;\n    public var scale:Number, dscale:Number, angle:int, dangle:Number, cvec:Vector.<Vector3D>;\n    static public function alloc(x:Number, y:Number, z:Number, vel:Vector3D) : Particle {\n        var newPart:Particle = _freeList || new Particle(), \n            life:Number = setting.life + setting.lifevar * (Math.random() - 0.5), \n            v:Number    = setting.vini + setting.vvar * (Math.random()-0.5), \n            acc:Number  = setting.acc / life;\n        if (_freeList) _freeList = _freeList.next;\n        _vtemp.setTo(Math.random()-0.5, Math.random()-0.5, Math.random()-0.5+setting.vz);\n        _vtemp.normalize();\n        newPart.tex = setting.tex;\n        newPart.cvec = grad.$;\n        newPart.life = life;\n        newPart.age = 0;\n        newPart.setTo(x, y, z);\n        newPart.vx = vel.x * setting.vforce + _vtemp.x * v;\n        newPart.vy = vel.y * setting.vforce + _vtemp.y * v;\n        newPart.vz = vel.z * setting.vforce + _vtemp.z * v;\n        newPart.ax = newPart.vx * acc;\n        newPart.ay = newPart.vy * acc;\n        newPart.az = newPart.vz * acc + setting.grav;\n        newPart.scale = setting.sclini + setting.sclvar * (Math.random()-0.5);\n        newPart.dscale = newPart.scale * (setting.mag - 1);\n        newPart.angle = (setting.angini + setting.angvar * (Math.random()-0.5))*22.755555555555556; // 8192/360\n        newPart.dangle = (setting.rotini + setting.rotvar * (Math.random()-0.5))*22.755555555555556;\n        if (Math.random() < 0.5) newPart.dangle = -newPart.dangle;\n        newPart.next = _activeList;\n        return _activeList = newPart;\n    }\n    static public function update(psf:PointSpriteField, dt:Number) : void {\n        var p:Particle, prev:Particle, t:Number, ang:int, col:int, scl:Number, sin:Number, cos:Number, c:Vector3D;\n        for (p=_activeList; p;) {\n            p.age += dt;\n            if (p.age < p.life) {\n                t = p.age / p.life;\n                p.x += (p.vx + p.ax * dt * 0.5) * dt;\n                p.y += (p.vy + p.ay * dt * 0.5) * dt;\n                p.z += (p.vz + p.az * dt * 0.5) * dt;\n                p.vx += (p.ax - p.vx * setting.reduction) * dt;\n                p.vy += (p.ay - p.vy * setting.reduction) * dt;\n                p.vz += (p.az - p.vz * setting.reduction) * dt;\n                ang = (int(p.angle + p.dangle * t))&8191;\n                scl = p.scale + p.dscale * t;\n                col = int(t * 511);\n                sin = s$[ang]; cos = c$[ang]; c = p.cvec[col];\n                psf.createSprite(p.tex, p.x, p.y, p.z, scl*cos, -scl*sin, scl*sin, scl*cos, c.x*1.25, c.y*1.25, c.z*1.25, 1);\n                prev = p; p = prev.next;\n            } else {\n                if (prev) { prev.next   = p.next; p.next = _freeList; _freeList = p; p = prev.next; } \n                else      { _activeList = p.next; p.next = _freeList; _freeList = p; p = _activeList; }\n            }\n        }\n    }\n}\n\n\n\n\n\n\n/* Tiny Ptolemy */ {\n    import flash.net.*;\n    import flash.geom.*;\n    import flash.events.*;\n    import flash.system.*;\n    import flash.display.*;\n    import flash.display3D.*;\n    import com.adobe.utils.*;\n\n    /** Operation Center */\n    class Ptolemy extends EventDispatcher {\n    // variables ----------------------------------------\n        public var context3D:Context3D;\n        public var sigl:SiGLCore;\n        public var resources:* = {};\n\n        private var _loadedResourceCount:int;\n    // constructor ----------------------------------------\n        function Ptolemy(parent:DisplayObjectContainer, xpos:Number, ypos:Number ,width:int, height:int) : void {\n            var stage:Stage = parent.stage, stage3D:Stage3D = stage.stage3Ds[0];\n            stage.scaleMode = StageScaleMode.NO_SCALE;\n            stage.align = StageAlign.TOP_LEFT;\n            stage.quality = StageQuality.LOW;\n            stage3D.x = xpos; stage3D.y = ypos;\n            stage3D.addEventListener(Event.CONTEXT3D_CREATE, function(e:Event):void{\n                context3D = e.target.context3D;\n                if (context3D) {\n                    context3D.enableErrorChecking = true;                   // check internal error\n                    context3D.configureBackBuffer(width, height, 0, true);  // disable AA/ enable depth/stencil\n                    context3D.setBlendFactors(Context3DBlendFactor.SOURCE_ALPHA, Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA);\n                    context3D.setCulling(Context3DTriangleFace.BACK);       // culling back face\n                    context3D.setRenderToBackBuffer();\n                    sigl = new SiGLCore(width, height);\n                    dispatchEvent(e.clone());\n                    if (--_loadedResourceCount == 0) dispatchEvent(new Event(Event.COMPLETE));\n                } else dispatchEvent(new ErrorEvent(ErrorEvent.ERROR, false, false, \"Context3D not found\"));\n            });\n            stage3D.requestContext3D();\n            _loadedResourceCount = 1;\n        }\n    // load resource ----------------------------------------\n        public function load(urlRequest:URLRequest, id:String=null, type:String=null, checkPolicyFile:Boolean=false) : EventDispatcher {\n            var loader:Loader, urlLoader:URLLoader;\n            _loadedResourceCount++;\n            if (type == \"img\") {\n                loader = new Loader();\n                loader.load(urlRequest, new LoaderContext(checkPolicyFile));\n                loader.contentLoaderInfo.addEventListener(Event.COMPLETE, function(e:Event) : void {\n                    resources[id] = e.target.content;\n                    if (--_loadedResourceCount == 0) dispatchEvent(new Event(Event.COMPLETE));\n                });\n                return loader;\n            }\n            urlLoader = new URLLoader(urlRequest);\n            urlLoader.dataFormat = (type == \"txt\") ? URLLoaderDataFormat.TEXT : URLLoaderDataFormat.BINARY;\n            urlLoader.addEventListener(Event.COMPLETE, function(e:Event) : void {\n                resources[id] = e.target.data;\n                if (--_loadedResourceCount == 0) dispatchEvent(new Event(Event.COMPLETE));\n            });\n            return urlLoader;\n        }\n    }\n    \n    /** SiGLCore provides basic matrix operations. */\n    class SiGLCore {\n    // variables ----------------------------------------\n        public var modelViewMatrix:Matrix3D = new Matrix3D(), projectionMatrix:PerspectiveMatrix3D = new PerspectiveMatrix3D();\n        public var viewWidth:Number, viewHeight:Number, pointSpriteFieldScale:Point = new Point();\n        private var _mvMatrixStac:Vector.<Matrix3D> = new Vector.<Matrix3D>();\n        private var _mvpMatrix:Matrix3D = new Matrix3D(), _mvpMatrixDirty:Boolean, _toDegree:Number, _toRadian:Number;\n        private var _cameraPosition:Vector3D = new Vector3D(0,0,0), _magnification:Number, _zNear:Number, _zFar:Number, _fieldOfView:Number;\n        static private var _tv:Vector.<Number> = new Vector.<Number>(16, true), _tm:Matrix3D = new Matrix3D();\n    // properties ----------------------------------------\n        public function get modelViewProjectionMatrix() : Matrix3D {\n            if (_mvpMatrixDirty) {\n                _mvpMatrix.copyFrom(projectionMatrix);\n                _mvpMatrix.prepend(modelViewMatrix);\n                _mvpMatrixDirty = false;\n            }\n            return _mvpMatrix;\n        }\n        public function get angleMode() : String { return (_toRadian == 1) ? \"radian\" : \"degree\"; }\n        public function set angleMode(mode:String) : void { _toDegree = (mode == \"radian\") ? 57.29577951308232 : 1; _toRadian = (mode == \"radian\") ? 1 : 0.017453292519943295; }\n        public function get fieldOfView() : Number { return _fieldOfView / _toRadian; }\n        public function set fieldOfView(fov:Number) : void { _fieldOfView = fov * _toRadian; _updateProjectionMatrix(); }\n        public function get magnification() : Number { return _magnification; }\n        public function set magnification(mag:Number) : void { _magnification = mag; _updateProjectionMatrix(); }\n        public function get cameraPosition() : Vector3D { return _cameraPosition; }\n    // constructor ----------------------------------------\n        function SiGLCore(width:Number=1, height:Number=1) {\n            viewWidth = width; viewHeight = height;\n            angleMode = \"degree\"; _magnification = 1;\n            _zNear = -200; _zFar = 1000;\n            modelViewMatrix.identity();\n            _mvpMatrixDirty = true;\n            this.fieldOfView = 60;\n        }\n    // matrix operations ----------------------------------------\n        public function forceUpdateMatrix() : SiGLCore { _mvpMatrixDirty = true; return this; }\n        public function setZRange(zNear:Number=-100, zFar:Number=100) : SiGLCore { _zNear = zNear; _zFar = zFar; _updateProjectionMatrix(); return this; }\n        public function clear() : SiGLCore { _mvMatrixStac.length = 0; return id(); }\n        public function id() : SiGLCore { modelViewMatrix.identity(); _mvpMatrixDirty = true; return this; }\n        public function push() : SiGLCore { _mvMatrixStac.push(modelViewMatrix.clone()); return this; }\n        public function pop() : SiGLCore { modelViewMatrix = _mvMatrixStac.pop(); return this; }\n        public function r(angle:Number, axis:Vector3D, pivotPoint:Vector3D = null) : SiGLCore { modelViewMatrix.prependRotation(angle*_toDegree, axis, pivotPoint); _mvpMatrixDirty = true; return this; }\n        public function s(scaleX:Number, scaleY:Number, scaleZ:Number=1) : SiGLCore { modelViewMatrix.prependScale(scaleX, scaleY, scaleZ); _mvpMatrixDirty = true; return this; }\n        public function t(x:Number, y:Number, z:Number=0) : SiGLCore { modelViewMatrix.prependTranslation(x, y, z); _mvpMatrixDirty = true; return this; }\n        public function re(angleX:Number, angleY:Number, angleZ:Number) : SiGLCore {\n            var rx:Number = angleX*_toRadian, ry:Number=angleY*_toRadian, rz:Number=angleZ*_toRadian,\n                sx:Number = Math.sin(rx), sy:Number = Math.sin(ry), sz:Number = Math.sin(rz), \n                cx:Number = Math.cos(rx), cy:Number = Math.cos(ry), cz:Number = Math.cos(rz);\n            _tv[0] = cz*cy; _tv[1] = sz*cy; _tv[2] = -sy; _tv[4] = -sz*cx+cz*sy*sx; _tv[5] = cz*cx+sz*sy*sx;\n            _tv[6] = cy*sx; _tv[8] = sz*sx+cz*sy*cx; _tv[9] = -cz*sx+sz*sy*cx;\n            _tv[10] = cy*cx; _tv[14] = _tv[13] = _tv[12] = _tv[11] = _tv[7] = _tv[3] = 0; _tv[15] = 1;\n            _tm.copyRawDataFrom(_tv); modelViewMatrix.prepend(_tm); _mvpMatrixDirty = true;\n            return this;\n        }\n        private function _updateProjectionMatrix() : void {\n            var aspect:Number = viewWidth / viewHeight;\n            _cameraPosition.z = (viewHeight * 0.5) / Math.tan(_fieldOfView * 0.5);\n            if (_zNear <= -_cameraPosition.z) _zNear = -_cameraPosition.z + 0.001;\n            projectionMatrix.perspectiveFieldOfViewRH(_fieldOfView, aspect, _zNear + _cameraPosition.z, _zFar + _cameraPosition.z);\n            pointSpriteFieldScale.setTo(projectionMatrix.rawData[0] * _cameraPosition.z, projectionMatrix.rawData[5] * _cameraPosition.z);\n            projectionMatrix.prependTranslation(-_cameraPosition.x, -_cameraPosition.y, -_cameraPosition.z);\n            projectionMatrix.prependScale(_magnification, _magnification, _magnification);\n        }\n    }\n\n\n    /** Mesh */\n    class Mesh {\n    // variables ----------------------------------------\n        public var vertices:Vector.<Number> = new Vector.<Number>();\n        public var faces:Vector.<Face> = new Vector.<Face>();\n        public var vertexBuffer:VertexBuffer3D, indexBuffer:IndexBuffer3D;\n        public var data32PerVertex:int, attributeList:Array = [];\n        private var _indices:Vector.<uint> = new Vector.<uint>(), _indexDirty:Boolean=true;\n    // properties ----------------------------------------\n        public function get vertexCount() : int { return vertices.length / data32PerVertex; }\n        public function set vertexCount(count:int) : void { vertices.length = count * data32PerVertex; }\n        public function get indices() : Vector.<uint> {\n            var idx:Vector.<uint> = _indices, f:Face, i:int, imax:int, j:int;\n            if (_indexDirty) {\n                idx.length = imax = faces.length * 3;\n                for (i=0,j=0; i<imax; j++) {\n                    f = faces[j];\n                    idx[i] = f.i0; i++;\n                    idx[i] = f.i1; i++;\n                    idx[i] = f.i2; i++;\n                }\n                _indexDirty = false;\n            }\n            return idx;\n        }\n    // contructor ----------------------------------------\n        function Mesh(bufferFormat:String=\"V3\") {\n            var rex:RegExp = /([_a-zA-Z]+)([1234b])/g, res:*, i:int=0;\n            data32PerVertex = 0;\n            while (res = rex.exec(bufferFormat)) data32PerVertex += (attributeList[i++]=int(res[2]));\n        }\n    // oprations ----------------------------------------\n        public function allocateBuffer(context3D:Context3D) : Mesh {\n            vertexBuffer = context3D.createVertexBuffer(vertexCount, data32PerVertex);\n            indexBuffer  = context3D.createIndexBuffer(indices.length);\n            return this;\n        }\n        public function upload(vertex:Boolean=true, index:Boolean=true) : Mesh {\n            if (vertex) vertexBuffer.uploadFromVector(vertices, 0, vertexCount);\n            if (index) indexBuffer.uploadFromVector(indices, 0, indices.length);\n            return this;\n        }\n        public function drawTriangles(context3D:Context3D) : Mesh {\n            var i:int, offset:int=0, form:Array = [\"\",\"float1\",\"float2\",\"float3\",\"float4\"];\n            for (i=0; i<attributeList.length; offset+=attributeList[i++]) context3D.setVertexBufferAt(i, vertexBuffer, offset, form[attributeList[i]]);\n            context3D.drawTriangles(indexBuffer, 0, faces.length);\n            return this;\n        }\n        public function face(i0:int, i1:int, i2:int) : Mesh { faces.push(Face.alloc(i0, i1, i2)); _indexDirty = true; return this; }\n        public function qface(i0:int, i1:int, i2:int, i3:int) : Mesh { faces.push(Face.alloc(i0, i1, i2), Face.alloc(i3, i2, i1)); _indexDirty = true; return this; }\n        public function updateFaceNormal(updateVertexNormal:Boolean=true) : Mesh {\n            var vtx:Vector.<Number> = vertices, vcount:int = vertexCount, fcount:int = faces.length, \n                i:int, istep:int, f:Face, iw:Number, fidx:int,  i0:int, i1:int, i2:int, n0:Vector3D, n1:Vector3D, n2:Vector3D, \n                x01:Number, x02:Number, y01:Number, y02:Number, z01:Number, z02:Number;\n            // calculate face normals\n            for (i=0; i<fcount; i++) {\n                f=faces[i];\n                i0=f.i0*data32PerVertex; i1=f.i1*data32PerVertex; i2=f.i2 * data32PerVertex;\n                x01 = vtx[i1]-vtx[i0]; x02 = vtx[i2]-vtx[i0]; i0++; i1++; i2++;\n                y01 = vtx[i1]-vtx[i0]; y02 = vtx[i2]-vtx[i0]; i0++; i1++; i2++;\n                z01 = vtx[i1]-vtx[i0]; z02 = vtx[i2]-vtx[i0];\n                f.normal.setTo(y02*z01-y01*z02, z02*x01-z01*x02, x02*y01-x01*y02);\n                f.normal.normalize();\n            }\n            // calculate vertex normals\n            if (updateVertexNormal) {\n                istep = data32PerVertex - 2;\n                // initialize\n                for (i=0, i0=3; i<vcount; i++, i0+=istep) { vtx[i0]=0; i0++; vtx[i0]=0; i0++; vtx[i0]=0; }\n                // sum up\n                for (i=0; i<fcount; i++) {\n                    f = faces[i];\n                    i0 = f.i0 * data32PerVertex + 3;\n                    vtx[i0]+=f.normal.x; i0++; vtx[i0]+=f.normal.y; i0++; vtx[i0]+=f.normal.z;\n                    i0 = f.i1 * data32PerVertex + 3;\n                    vtx[i0]+=f.normal.x; i0++; vtx[i0]+=f.normal.y; i0++; vtx[i0]+=f.normal.z;\n                    i0 = f.i2 * data32PerVertex + 3;\n                    vtx[i0]+=f.normal.x; i0++; vtx[i0]+=f.normal.y; i0++; vtx[i0]+=f.normal.z;\n                }\n                /* normalize (ussualy normalizing by gpu).\n                for (i=0, i0=3; i<vcount; i++, i0+=istep) {\n                    x01 = vtx[i0]; i0++; y01 = vtx[i0]; i0++; z01 = vtx[i0]; i0-=2;\n                    iw = 1 / Math.sqrt(x01*x01 + y01*y01 + z01*z01);\n                    vtx[i0] = x01 * iw; i0++; vtx[i0] = y01 * iw; i0++; vtx[i0] = z01 * iw;\n                }\n                //*/\n            }\n            return this;\n        }\n    }\n\n\n    /** Face */\n    class Face {\n        public var i0:int, i1:int, i2:int, normal:Vector3D = new Vector3D();\n        function Face() { i0 = i1 = i2 = 0; }\n        static private var _freeList:Vector.<Face> = new Vector.<Face>();\n        static public function free(face:Face) : void { _freeList.push(face); }\n        static public function alloc(i0:int, i1:int, i2:int) : Face { \n            var f:Face = _freeList.pop() || new Face();\n            f.i0 = i0; f.i1 = i1; f.i2 = i2; return f;\n        }\n    }\n    \n    \n    /** Point Sprite Field */\n    class PointSpriteField extends Mesh {\n    // variables --------------------------------------------------\n        private var spriteCount:int;\n        private var maxSpriteCount:int;\n    // constructor --------------------------------------------------\n        function PointSpriteField(context3D:Context3D, maxSpriteCount:int=1024) {\n            var i:int, j:int;\n            super(\"V3S2T2C4O4\");\n            this.maxSpriteCount = maxSpriteCount;\n            vertexCount = maxSpriteCount * 4;\n            spriteCount = 0;\n            for (i=0; i<vertices.length; i++) vertices[i] = 0;\n            for (i=0, j=0; i<maxSpriteCount; i++) qface(j++, j++, j++, j++);\n            allocateBuffer(context3D);\n            upload();\n        }\n    // operations --------------------------------------------------\n        public function clearSprites() : PointSpriteField { spriteCount = 0; return this; }\n        public function createSprite(tex:PointSpriteTexInfo, x:Number, y:Number, z:Number=0, \n                                     mata:Number=1, matb:Number=0, matc:Number=0, matd:Number=1,\n                                     rmul:Number=1, gmul:Number=1, bmul:Number=1, amul:Number=1, \n                                     radd:Number=0, gadd:Number=0, badd:Number=0, aadd:Number=0) : PointSpriteField {\n            var wa:Number = tex.hw*mata, wc:Number = tex.hw*matc, hb:Number = tex.hh*matb, hd:Number = tex.hh*matd, \n                v0x:Number = -wa+hb, v0y:Number = -wc+hd, v1x:Number = wa+hb, v1y:Number = wc+hd, \n                i0:int = spriteCount*data32PerVertex*4, i1:int=i0+data32PerVertex, i2:int=i1+data32PerVertex, i3:int=i2+data32PerVertex;\n            if (spriteCount == maxSpriteCount) return this;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = x; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = y; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = z; i0++; i1++; i2++; i3++;\n            vertices[i3] = -(vertices[i0] = v0x); i0++; i3++;\n            vertices[i3] = -(vertices[i0] = v0y); i0++; i3++;\n            vertices[i2] = -(vertices[i1] = v1x); i1++; i2++;\n            vertices[i2] = -(vertices[i1] = v1y); i1++; i2++;\n            vertices[i0] = vertices[i2] = tex.u0; i0++; i2++;\n            vertices[i1] = vertices[i3] = tex.u1; i1++; i3++;\n            vertices[i0] = vertices[i1] = tex.v0; i0++; i1++;\n            vertices[i2] = vertices[i3] = tex.v1; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = rmul; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = gmul; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = bmul; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = amul; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = radd; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = gadd; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = badd; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = aadd; i0++; i1++; i2++; i3++;\n            spriteCount++;\n            return this;\n        }\n        override public function drawTriangles(context3D:Context3D) : Mesh {\n            if (spriteCount) {\n                vertexBuffer.uploadFromVector(vertices, 0, spriteCount*4);\n                context3D.setVertexBufferAt(0, vertexBuffer,  0, Context3DVertexBufferFormat.FLOAT_3);\n                context3D.setVertexBufferAt(1, vertexBuffer,  3, Context3DVertexBufferFormat.FLOAT_2);\n                context3D.setVertexBufferAt(2, vertexBuffer,  5, Context3DVertexBufferFormat.FLOAT_2);\n                context3D.setVertexBufferAt(3, vertexBuffer,  7, Context3DVertexBufferFormat.FLOAT_4);\n                context3D.setVertexBufferAt(4, vertexBuffer, 11, Context3DVertexBufferFormat.FLOAT_4);\n                context3D.drawTriangles(indexBuffer, 0, spriteCount*2);\n            }\n            return this;\n        }\n    }\n\n    \n    /** Point Sprite Texture Infomation */\n    class PointSpriteTexInfo {\n        public var u0:Number, v0:Number, u1:Number, v1:Number, hw:Number, hh:Number;\n        function PointSpriteTexInfo(u0:Number, v0:Number, u1:Number, v1:Number, width:Number, height:Number) {\n            this.u0 = u0; this.v0 = v0; this.u1 = u1; this.v1 = v1; this.hw = width * 0.5; this.hh = height * 0.5;\n        }\n    }\n}\n\n","modified_date":1320864156,"compile_ok":"1","created_date":1320255594,"forked_count":"10","license":"MIT","swf":"http://swf.wonderfl.net/swf/usercode/6/6d/6d91/6d917938f75e1b98b592073d29b9d815d91712e6.swf","diff":"0","user":{"icon":"http://wonderfl.net/images/icon/2/27/278a/278afc585a0a283d6e1f13f081cfd9c377ab9db2m","name":"keim_at_Si"},"title":"Point Sprite Particle","id":"fDhI","favorite_count":"48"},"stat":"ok"}