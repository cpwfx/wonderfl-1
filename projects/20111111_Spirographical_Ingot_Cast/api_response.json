{"code":{"thumbnail":"http://wonderfl.net/images/capture/1/1a/1a67/1a674425190019c28061a89e5c197c5cf61f4f3f_100.jpg?t=1320954804","parent":null,"as3":"package {\n    import flash.display.*;\n    import flash.events.*;\n    import flash.utils.*;\n    import flash.geom.*;\n    import flash.text.*;\n    import flash.net.*;\n    \n    import com.adobe.utils.*;\n    import com.adobe.crypto.SHA1;\n    import com.bit101.components.*;\n    import flash.display3D.*;\n    import flash.display3D.textures.*;\n    import org.libspark.betweenas3.*;\n    import org.libspark.betweenas3.easing.*;\n    import org.libspark.betweenas3.tweens.*;\n//    import org.si.ptolemy.*;\n//    import org.si.ptolemy.core.*;\n\n    public class main extends Sprite {\n/*      // for local\n        private const envURL:String = \"_env1.png\";\n        private const partURL:String = \"part.png\";\n/*/     // for wonderfl\n        private const envURL:String = \"http://assets.wonderfl.net/images/related_images/b/b2/b217/b2177f87d979a28b9bcbb6e0b89370e77ce22337\";\n        private const partURL:String = \"http://assets.wonderfl.net/images/related_images/6/6a/6a2d/6a2dffe6da5745c6a74c28a52a163077689afdab\";\n//*/\n        \n        private var ptolemy:Ptolemy;\n        \n        private var asm:AGALMiniAssembler = new AGALMiniAssembler();\n        private var programs:Vector.<Program3D> = new Vector.<Program3D>();\n\n        private var _mesh:Mesh = new Mesh(\"V3N3\");\n        private var _trochoid:Trochoid3D = new Trochoid3D();\n        \n        private var sin:Vector.<Number> = new Vector.<Number>(), cos:Vector.<Number> = new Vector.<Number>();\n        private var _nodeCount:int, _roundCount:int;\n\n        private var _creatingTime:Number = 20000, _breakingTime:Number = 1000, iphase:Number;\n        private var _ref:Number = 0.8;\n        private var _material:FlatShadingMaterial = new FlatShadingMaterial(0xffffff, 1, 0.1, 0.8, 0.8, 16);\n        private var _radius:Vector.<Number>, _radiusBuffer:VertexBuffer3D;\n        private var _colors:Vector.<Number>, _colorsBuffer:VertexBuffer3D;\n        private var _specTex:Texture, _shpereMap:BitmapData, _shpereTex:Texture;\n        private var _partTex:Texture, _partMap:BitmapData;\n        private var _emitterTex:PointSpriteTexInfo, _fireTex:PointSpriteTexInfo, _breakTex:PointSpriteTexInfo;\n        private var _fireSetting:ParticleSetting, _breakSetting:ParticleSetting, _particleColor:Vector3D = new Vector3D(1,1,1,1);\n        private var _psf:PointSpriteField;\n        private var _light:Light = new Light();\n        \n        private var _freq1:Number=8,   _freq2:Number=7,   _zfreq:Number=1,   _hfreq:Number = 8;\n        private var _zvar1:Number=1.2, _zvar2:Number=0.4, _radrt:Number=0.6, _width:Number = 8;\n        private var _sliders:Array = [], _shapeInput:InputText;\n        private var _cameraMatrix:SiGLMatrix = new SiGLMatrix();\n        private var _trochoidMatrix:SiGLMatrix = new SiGLMatrix();\n        \n        private var _radpos:Vector.<Number>, _radvel:Vector.<Number>, _prevIndex:int;\n        private var _startTime:Number, _animStartTime:Number, _isBreaking:Boolean, _restart:Boolean = false;\n        private var _appID:String, _userID:String, _shapeTitle:Label, _title:String, _autoPlay:CheckBox;\n        \n        public function get title() : String { return _title; }\n        public function set title(str:String) : void {\n            _title = str;\n            _shapeTitle.text = \"#SPIROGRAPH{\" + str + \"}\";\n        }\n        \n        \n        function main() {\n            _appID = loaderInfo.parameters[\"appId\"];\n            _userID = loaderInfo.parameters[\"viewer.displayName\"];\n            Wonderfl.disable_capture();\n            ptolemy = new Ptolemy(this, 8, 8, 450, 450);\n            ptolemy.sigl.setZRange(-300, 3000);\n            ptolemy.addEventListener(Event.COMPLETE, setup);\n            ptolemy.load(new URLRequest(envURL),  \"env\",  \"img\", true);\n            ptolemy.load(new URLRequest(partURL), \"part\", \"img\", true);\n        }\n        \n        \n        private function setup(e:Event) : void {\n            var i:int, context3D:Context3D = ptolemy.context3D, prog:Program3D;\n            removeEventListener(Event.COMPLETE, setup);\n            \n            context3D.enableErrorChecking = true;\n            \n            // create shape\n            updateCount(4096, 8);\n            //updateCount(512, 3);\n            \n            _shpereMap = ptolemy.resources[\"env\"].bitmapData;\n            _shpereTex = context3D.createTexture(_shpereMap.width, _shpereMap.height, \"bgra\", false);\n            _shpereTex.uploadFromBitmapData(_shpereMap);\n            _partMap = ptolemy.resources[\"part\"].bitmapData;\n            _partTex = context3D.createTexture(_partMap.width, _partMap.height, \"bgra\", false);\n            _partTex.uploadFromBitmapData(_partMap);\n            _specTex = context3D.createTexture(1024, 1, \"bgra\", false);\n            _specTex.uploadFromBitmapData(_material.specMap);\n            \n            _trochoid.matrix3D = _trochoidMatrix;\n            _fireTex    = new PointSpriteTexInfo(0,0.5,0.5,1,32,32);\n            _breakTex   = new PointSpriteTexInfo(0.5,0,1,0.5,24,24);\n            _emitterTex = new PointSpriteTexInfo(0.5,0.5,1,1,32,32);\n            _fireSetting  = new ParticleSetting({texture:_fireTex,  gravity:new Vector3D(0,-600,0), speedVar:200, life:1, lifeVar:1, startColor:_particleColor});\n            _breakSetting = new ParticleSetting({texture:_breakTex, gravity:new Vector3D(0, 400,0), speedVar:100, life:2, lifeVar:2, startColor:_particleColor, velocity:new Vector3D(0, -200,0), angleVar:360, rotationVar:360});\n            _psf = new PointSpriteField(context3D, 4096);\n            \n            for (i=0; i<shaders.length; i++) {\n                prog = context3D.createProgram();\n                prog.upload(asm.assemble(\"vertex\", shaders[i].vs), asm.assemble(\"fragment\", shaders[i].fs));\n                programs.push(prog);\n            }\n            \n            context3D.setProgramConstantsFromVector(\"vertex\",  126, Vector.<Number>([ptolemy.sigl.pointSpriteFieldScale.x, ptolemy.sigl.pointSpriteFieldScale.y, 0, 0]));\n            context3D.setProgramConstantsFromVector(\"vertex\",  127, Vector.<Number>([0, 0.5, 1, 2]));\n            context3D.setProgramConstantsFromVector(\"fragment\", 27, Vector.<Number>([0, 0.5, 1, 2]));\n            \n            _startTime = getTimer();\n            setupControler();\n            addEventListener(Event.ENTER_FRAME, firstScreen);\n        }\n        \n        private function encodeParam() : String {\n            var str:String = \"\";\n            str += _freq1.toFixed(0) + \":\" + _freq2.toFixed(0) + \":\" + _zfreq.toFixed(0) + \":\" + _hfreq.toFixed(0)+\",\";\n            str += _zvar1.toFixed(1) + \",\" + _zvar2.toFixed(1) + \",\" + _radrt.toFixed(1) + \",\" + _width.toFixed(1);\n            return str;\n        }\n        \n        private function decodeParam(str:String) : Boolean {\n            var res:* = (/s\\{(.+?)\\}/).exec(str);\n            if (res && res[1]) str = res[1];\n            var p:Array = str.split(/[:,]/);\n            title = str;\n            if (p.length != 8) {\n                SHA1.hash(str);\n                SHA1.digest.position = 0;\n                var i:int, v:Array = [];\n                for (i=0; i<18; i++) v.push(SHA1.digest.readUnsignedByte()&255);\n                encrypto(v);\n                return false;\n            }\n            for (i=0; i<8; i++) _sliders[i].value = Number(p[i]);\n            _freq1 = _sliders[0].value; _freq2 = _sliders[1].value; _zfreq = _sliders[2].value; _hfreq = _sliders[3].value;\n            _zvar1 = _sliders[4].value; _zvar2 = _sliders[5].value; _radrt = _sliders[6].value; _width = _sliders[7].value;\n            return true;\n        }\n        \n        private function randomize() : void {\n            var i:int, v:Array = [];\n            for (i=0; i<18; i++) v.push(int(Math.random()*256));\n            encrypto(v);\n            title = encodeParam();\n        }\n        \n        private function encrypto(keys:Array) : void {\n            var r:Number, rot:Array, keyIndex:int=0; // length=18\n            _freq1 = _sliders[0].value = int($()*$()*32)+1;\n            _freq2 = _sliders[1].value = int(($()+$())*32)-32;\n            r = $();\n            _zfreq = _sliders[2].value = int(r*r)*4+1; if (_zfreq>4) _zfreq=_sliders[6].value =0;\n            r = int(Math.abs(_freq1+_freq2));\n            rot = [1, _freq1-1, _freq1, _freq1+1, _freq2-1, _freq2, _freq2+1, r, r, int($()*32)+1];\n            _hfreq = _sliders[3].value = rot[int($()*rot.length)]; if (_hfreq < 1) _hfreq = _sliders[3].value = 1;\n            _zvar1 = _sliders[4].value = int(($()+$()+$())*20)*0.1-3;\n            _zvar2 = _sliders[5].value = int(($()+$()+$())*20)*0.1-3;\n            _radrt = _sliders[6].value = int(($()+$())*20)*0.03; if (_radrt>1) _radrt=_sliders[6].value =(_radrt-1)*10+1;\n            r = ($()+$()+$())/3;\n            _width = _sliders[7].value = int(r * r * 31) + 1;\n            function $() : Number { return (keys[keyIndex++]&255) / 256; } \n        }\n        \n        private function _tweet(text:String) : void  {\n            var url:String = escapeMultiByte(\"http://wonderfl.net/c/\" + _appID);\n            navigateToURL(new URLRequest(\"https://twitter.com/intent/tweet?\" + \n                \"text=\" + escapeMultiByte(text) + \"&related=keim_at_si&url=\" + url + \"&original_referer=\" + url\n            ));\n        }\n/*\n        private function _searchTweet() : void {\n            var urlLoader:URLLoader = new URLLoader();\n            urlLoader.addEventListener(Event.COMPLETE, _onCompleteSearchTweet);\n            urlLoader.addEventListener(IOErrorEvent.IO_ERROR, _onErrorSearchTweet);\n            var xmlURL:String = \"http://search.twitter.com/search.atom?q=\" + encodeURIComponent(\"#spirograph3d\");\n            urlLoader.load(new URLRequest(xmlURL));\n        }\n        private function _onCompleteSearchTweet(e:Event) : void {\n        }\n        private function _onErrorSearchTweet(e:Event) : void {\n        }\n*/      \n        \n        private function setupControler() : void {\n            addChild(_mouseCapture = new Sprite());\n            _mouseCapture.graphics.beginFill(0, 0);\n            _mouseCapture.graphics.drawRect(0, 0, stage.stageWidth, stage.stageHeight);\n            _mouseCapture.graphics.endFill();\n            _mouseCapture.visible = false;\n            addChild(_ctrl = new Sprite()); _w=200; _h=0; \n            newSlider(\"ambient\", 0, 1, _material.ambient, 0.1, 1, function(e:Event):void { _material.ambient = e.target.value; });\n            newSlider(\"diffuse\", 0, 1, _material.diffuse, 0.1, 1, function(e:Event):void { _material.diffuse = e.target.value; });\n            newSlider(\"power\",   0,64, _material.power,     1, 0, function(e:Event):void { _material.power = e.target.value;    _specTex.uploadFromBitmapData(_material.specMap);});\n            newSlider(\"specular\",0, 3, _material.specular,0.1, 1, function(e:Event):void { _material.specular = e.target.value; _specTex.uploadFromBitmapData(_material.specMap);});\n            newSlider(\"refrect\", 0, 1, _ref,              0.1, 1, function(e:Event):void { _ref = e.target.value; });\n            setupControlPanel(0, \"MATERIAL\");\n            addChild(_ctrl = new Sprite()); _w=360; _h=0;\n            _sliders.push(newSlider(\"frequency1\",   1, 32, _freq1,    1, 0, function(e:Event):void { _freq1 = e.target.value; updateMesh(); _autoPlay.selected = false; title = encodeParam(); }));\n            _sliders.push(newSlider(\"frequency2\", -31, 31, _freq2,    1, 0, function(e:Event):void { _freq2 = e.target.value; updateMesh(); _autoPlay.selected = false;  title = encodeParam(); }));\n            _sliders.push(newSlider(\"z-freq.\",      0,  4, _zfreq,    1, 0, function(e:Event):void { _zfreq = e.target.value; updateMesh(); _autoPlay.selected = false;  title = encodeParam(); }));\n            _sliders.push(newSlider(\"hue-freq.\",    1, 32, _hfreq,    1, 0, function(e:Event):void { _hfreq = e.target.value; updateColor(); _autoPlay.selected = false; title = encodeParam(); }));\n            _sliders.push(newSlider(\"z-varience1\", -3,  3, _zvar1,  0.1, 1, function(e:Event):void { _zvar1 = e.target.value; updateMesh(); _autoPlay.selected = false;  title = encodeParam(); }));\n            _sliders.push(newSlider(\"z-varience2\", -3,  3, _zvar2,  0.1, 1, function(e:Event):void { _zvar2 = e.target.value; updateMesh(); _autoPlay.selected = false;  title = encodeParam(); }));\n            _sliders.push(newSlider(\"radius ratio\", 0,  3, _radrt,  0.1, 1, function(e:Event):void { _radrt = e.target.value; updateMesh(); _autoPlay.selected = false;  title = encodeParam(); }));\n            _sliders.push(newSlider(\"wire width\",   1, 32, _width,    1, 0, function(e:Event):void { _width = e.target.value; _autoPlay.selected = false; title = encodeParam(); }));\n            _shapeInput = new InputText(_ctrl, 4, _h+2, \"\");\n            _shapeInput.setSize(276, 18);\n            new PushButton(_ctrl, 282, _h+2, \"SETUP\",  function(e:Event):void { decodeParam(_shapeInput.text); _autoPlay.selected = false; _restart = true; reset(); }).setSize(76, 18); _h += 24;\n            setupControlPanel(1, \"SHAPE\");\n            _autoPlay = new CheckBox(this, 370, 465-70, \"AUTO PLAY\");\n            _autoPlay.selected = true;\n            new PushButton(this, 368, 465-54, \"CLEAR\",   function(e:Event):void { reset(); }).setSize(90, 18);\n            new PushButton(this, 368, 465-36, \"RESTART\", function(e:Event):void { _restart = true; reset(); }).setSize(90, 18);\n            new PushButton(this, 368, 465-18, \"TWEET\", function(e:Event):void { _tweet(\"Spirographical Ingot Cast s{\"+title+\"} #spirograph3d #wonderfl\"); }).setSize(90, 18);\n            //new PushButton(this, 368, 465, \"RANDOM\",  function(e:Event):void { randomize(); updateMesh(); }).setSize(90, 18);\n            _shapeTitle = new Label(this, 10, 10, \"\");\n        }\n        private function setupControlPanel(tabIndex:int, label:String) : void {\n            _ctrl.x = 8; _ctrl.y = 465;\n            _ctrl.graphics.beginFill(0, 0.75);\n            _ctrl.graphics.drawRect(0, 0, _w, _h);\n            _ctrl.graphics.endFill();\n            new PushButton(_ctrl, tabIndex*90, -18, label, function(e:Event):void {\n                var ctrl:DisplayObjectContainer = e.target.parent;\n                ctrl.parent.addChild(ctrl);\n                BetweenAS3.to(ctrl, {y:476-ctrl.height}, 0.5, Sine.easeOut).play();\n                _mouseCapture.visible = true;\n                _mouseCapture.addEventListener(MouseEvent.CLICK, function(e:Event):void{\n                    _mouseCapture.visible = false;\n                    _mouseCapture.removeEventListener(MouseEvent.CLICK, arguments.callee);\n                    BetweenAS3.to(ctrl, {y:465}, 0.5, Sine.easeOut).play();\n                });\n            }).setSize(90, 18);\n        }\n        private function newSlider(label:String, min:Number, max:Number, val:Number, tick:Number, prec:int, func:Function) : HUISlider {\n            var slider:HUISlider = new HUISlider(_ctrl, 4, _h, label, func);\n            slider.setSliderParams(min, max, val); slider.tick = tick; slider.labelPrecision = prec;\n            _h += 20; slider.width = _w;\n            return slider;\n        }\n        private var _ctrl:Sprite, _h:Number, _w:Number, _mouseCapture:Sprite;\n        \n        private function updateCount(nodeCount:int, roundCount:int) : void {\n            var vertexCount:int = nodeCount * roundCount;\n            _nodeCount  = nodeCount;\n            _roundCount = roundCount;\n            _radius = new Vector.<Number>(vertexCount, true);\n            _colors = new Vector.<Number>(vertexCount * 3, true);\n            _radpos = new Vector.<Number>(_nodeCount, true);\n            _radvel = new Vector.<Number>(_nodeCount, true);\n            _mesh.vertexCount = vertexCount;\n            if (_radiusBuffer) _radiusBuffer.dispose();\n            if (_colorsBuffer) _colorsBuffer.dispose();\n            _radiusBuffer = ptolemy.context3D.createVertexBuffer(vertexCount, 1);\n            _colorsBuffer = ptolemy.context3D.createVertexBuffer(vertexCount, 3);\n            cos.length = sin.length = _roundCount;\n            var i:int, ang:Number, dang:Number = 6.283185307179586 / _roundCount;\n            for (i=0, ang=0; i<_roundCount; i++, ang+=dang) {\n                sin[i] = -Math.sin(ang);\n                cos[i] =  Math.cos(ang);\n            }\n        }\n        \n        private function updateMesh() : void {\n            var i:int, j:int, i0:int, v:Vector3D, nx:Number, ny:Number, nz:Number, imr:int, i0mr:int, gcd:int, \n                v0:Vector3D = new Vector3D(), v1:Vector3D = new Vector3D(),\n                vx:Vector3D = new Vector3D(), vy:Vector3D = new Vector3D(), vz:Vector3D = new Vector3D(),\n                context3D:Context3D = ptolemy.context3D, prog:Program3D, vtx:Vector.<Number> = _mesh.vertices,\n                iNodeCount:Number = 1/_nodeCount, rcm1:int=_roundCount-1, hueFreq:Number=iNodeCount*(_freq1+_freq2)*3.141592653589793,\n                rad1:Number = 100, rad2:Number = 100*_radrt;\n            \n            _trochoidMatrix.identity();\n            for (gcd=i=1; i<=_freq1; i++) if ((int(_freq1))%i == 0 && (int(_freq2))%i == 0) gcd = i;\n            if (_zvar1 == 0) _zvar1 = 0.0000152587890625;\n            _trochoid.init(rad1, rad2, _zvar1*100, _freq1, _freq2, (_freq1+_freq2)*_zfreq + gcd-1);\n            _trochoid.dr2 = (_zvar2/_zvar1-1) / (100*(1+_radrt));\n            \n            v0.copyFrom(_trochoid.calc(0));\n            v1.copyFrom(_trochoid.calc(iNodeCount));\n            for (i0=i=0; i<_nodeCount; i++) {\n                v = _trochoid.calc((i+2)*iNodeCount);\n                vz.setTo(v.x-v0.x, v.y-v0.y, v.z-v0.z);\n                vx.copyFrom(v1);\n                if (vx.x == 0 && vx.y == 0 && vx.z == 0) vx.copyFrom(v0);\n                vy.setTo(vz.y*vx.z-vz.z*vx.y, vz.z*vx.x-vz.x*vx.z, vz.x*vx.y-vz.y*vx.x);\n                vy.normalize();\n                vx.setTo(vy.y*vz.z-vy.z*vz.y, vy.z*vz.x-vy.x*vz.z, vy.x*vz.y-vy.y*vz.x);\n                vx.normalize();\n                for (j=0; j<_roundCount; j++) {\n                    nx = vx.x*cos[j] + vy.x*sin[j];\n                    ny = vx.y*cos[j] + vy.y*sin[j];\n                    nz = vx.z*cos[j] + vy.z*sin[j];\n                    vtx[i0] = v1.x; i0++;\n                    vtx[i0] = v1.y; i0++;\n                    vtx[i0] = v1.z; i0++;\n                    vtx[i0] = nx; i0++;\n                    vtx[i0] = ny; i0++;\n                    vtx[i0] = nz; i0++;\n                }\n                v0.copyFrom(v1);\n                v1.copyFrom(v);\n            }\n            _mesh.clear();\n            for (i0=_nodeCount-1, i=0; i<_nodeCount; i0=i, i++) {\n                imr  = i  * _roundCount;\n                i0mr = i0 * _roundCount;\n                for (j=0; j<rcm1; j++) _mesh.qface(i0mr+j, i0mr+j+1, imr+j, imr+j+1);\n                _mesh.qface(i0mr+rcm1, i0mr, imr+rcm1, imr);\n            }\n            _mesh.allocateBuffer(context3D);\n            _mesh.upload();\n            updateColor();\n        }\n        \n        private function updateColor() : void {\n            var i:int, j:int, rgb:Vector3D, ic:int, k:Number = _hfreq/_nodeCount;\n            for (ic=i=0; i<_nodeCount; i++) {\n                rgb = hsv2rgb(i*k, 1, 1);\n                for (j=0; j<_roundCount; j++) {\n                    _colors[ic] = rgb.x; ic++;\n                    _colors[ic] = rgb.y; ic++;\n                    _colors[ic] = rgb.z; ic++;\n                }\n            }\n            _colorsBuffer.uploadFromVector(_colors, 0, _nodeCount*_roundCount);\n        }\n        \n        private function start() : void {\n            for (var i:int=0; i<_nodeCount; i++) _radvel[i] = _radpos[i] = 0;\n            _animStartTime = getTimer();\n            _prevIndex = 0;\n            _isBreaking = false;\n            iphase = 1/_creatingTime;\n        }\n\n        private function reset() : void {\n            _animStartTime = getTimer();\n            _prevIndex = 0;\n            _isBreaking = true;\n            iphase = 200/_breakingTime;\n        }\n        \n        private var _firstScreen:Sprite, _firstInput:InputText;\n        private function firstScreen(e:Event) : void {\n            if (!_firstScreen) {\n                addChild(_firstScreen = new Sprite());\n                _firstScreen.graphics.beginFill(0xffffff, 0.75);\n                _firstScreen.graphics.drawRect(0,0,465,465);\n                _firstScreen.graphics.endFill();\n                new Label(_firstScreen, 133, 213, \"YOUR NAME : \");\n                _firstInput = new InputText(_firstScreen, 213, 213, _userID);\n                _firstInput.setSize(120, 18);\n                new PushButton(_firstScreen, 158, 233, \"CREATE YOUR SPIROGRAPH\", function(e:Event) : void {\n                    removeChild(_firstScreen);\n                    removeEventListener(Event.ENTER_FRAME, firstScreen);\n                    Particle.initialize();\n                    decodeParam(_firstInput.text);\n                    updateMesh();\n                    start();\n                    addEventListener(Event.ENTER_FRAME, draw);\n                }).setSize(150, 18);\n            }\n        }\n        \n        private function draw(e:Event) : void {\n            var context3D:Context3D = ptolemy.context3D,\n                sigl:SiGLCore = ptolemy.sigl, \n                phase:Number = (getTimer() - _animStartTime) * iphase,\n                rotPhase:Number = (getTimer() - _startTime) / 20000,\n                cp:Vector3D, c:Vector3D = sigl.defaultCameraMatrix.position;\n            \n            var i:int, imax:int, ilimit:int, j:int, idx:int, n:Number, v:Vector3D, \n                vstep:int = _mesh.data32PerVertex, vtx:Vector.<Number> = _mesh.vertices;\n\n            // object rotation\n            _trochoidMatrix.identity();\n            _trochoidMatrix.prependRotationXYZ(Math.sin(rotPhase*Math.PI*4)*Math.PI*0.25, 0, Math.sin(rotPhase*Math.PI)*Math.PI);\n            cp = _trochoid.calc(phase);\n            // object motions\n            _psf.clearSprites();\n            if (_isBreaking) {\n                v = new Vector3D();\n                n = phase * phase;\n                for (i=0; i<_nodeCount; i++) {\n                    if (_radpos[i] > 0) {\n                        idx = i * _roundCount * 6;\n                        v.setTo(vtx[idx], vtx[idx+1], vtx[idx+2]);\n                        if (v.lengthSquared < n) {\n                            _radpos[i] = 0;\n                            idx = i * _roundCount;\n                            for (j=0; j<_roundCount; j++,idx++) _radius[idx] = 0;\n                            if (Math.random() < 0.25) {\n                                idx = i * _roundCount * 3;\n                                _particleColor.setTo(_colors[idx]*0.5+1, _colors[idx+1]*0.5+1, _colors[idx+2]*0.5+1);\n                                _particleColor.w = 1;\n                                _trochoidMatrix.transform(v);\n                                Particle.alloc(_breakSetting, v.x, v.y, v.z);\n                            }\n                        }\n                    }\n                }\n            } else {\n                ilimit = int(_nodeCount * phase);\n                if (ilimit < _nodeCount - 1) {\n                    if (ilimit > _prevIndex) for (i=_prevIndex; i<ilimit; i++) _radpos[i] = _width / 64;\n                    _prevIndex = ilimit;\n                    idx = ilimit * _roundCount * 3;\n                    _particleColor.setTo(_colors[idx]*1.5, _colors[idx+1]*1.5, _colors[idx+2]*1.5);\n                    _particleColor.w = 1;\n                    n = (_width + 8) * (Math.random() * 0.1 + 0.1);\n                    _psf.createSprite(_emitterTex, cp.x, cp.y, cp.z, n, 0, 0, n);\n                    Particle.alloc(_fireSetting, cp.x, cp.y, cp.z);\n                } else {\n                    ilimit = _nodeCount - 1;\n                    _radvel[ilimit] += (_radpos[ilimit-1] + _radpos[0] - _radpos[ilimit]*2) * 0.005 - (_radpos[ilimit] - 1) * 0.2;\n                    _radvel[0] += (_radpos[ilimit] + _radpos[1] - _radpos[0]*2) * 0.005 - (_radpos[0] - 1) * 0.2;\n                }\n                for (i=1; i<ilimit; i++) {\n                    _radvel[i] += (_radpos[i-1] + _radpos[i+1] - _radpos[i]*2) * 0.005 - (_radpos[i] - 1) * 0.2;\n                }\n                for (idx=i=0; i<_nodeCount; i++) {\n                    _radpos[i] += (_radvel[i] *= 0.96);\n                    n = (_radpos[i]<0) ? 0 : _radpos[i] * _width * 0.5;\n                    for (j=0; j<_roundCount; j++,idx++) _radius[idx] = n;\n                }\n            }\n            _radiusBuffer.uploadFromVector(_radius, 0, _radius.length);\n            \n\n            // global motion\n            sigl.id().r(rotPhase*360, Vector3D.Y_AXIS);\n            // lighting vector\n            _light.setTo(Math.cos(rotPhase*31.41592653589793), 1, Math.sin(rotPhase*31.41592653589793));\n            _light.transform(sigl);\n            \n            // drawing\n            context3D.setBlendFactors(Context3DBlendFactor.SOURCE_ALPHA, Context3DBlendFactor.ONE);\n            context3D.clear(0,0,0,1);\n            \n            sigl.push().m(_trochoidMatrix);\n            context3D.setProgram(programs[0]);\n            context3D.setDepthTest(true, \"less\");\n            context3D.setBlendFactors(Context3DBlendFactor.SOURCE_ALPHA, Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA);\n            context3D.setTextureAt(0, _specTex);\n            context3D.setTextureAt(1, _shpereTex);\n            context3D.setProgramConstantsFromMatrix(\"vertex\",   0, sigl.modelViewProjectionMatrix, true);\n            context3D.setProgramConstantsFromMatrix(\"vertex\",   4, sigl.modelViewMatrix, true);\n            context3D.setProgramConstantsFromVector(\"fragment\", 0, _light.lightVector);\n            context3D.setProgramConstantsFromVector(\"fragment\", 1, _light.halfVector);\n            context3D.setProgramConstantsFromVector(\"fragment\", 2, _material.ambientVector);\n            context3D.setProgramConstantsFromVector(\"fragment\", 3, _material.diffuseDifVector);\n            context3D.setProgramConstantsFromVector(\"fragment\", 4, Vector.<Number>([_ref, 0, 0, 0]));\n            context3D.setVertexBufferAt(2, _colorsBuffer, 0, \"float3\");\n            context3D.setVertexBufferAt(3, _radiusBuffer, 0, \"float1\");\n            _mesh.drawTriangles(context3D);\n            sigl.pop();\n            \n            Particle.update(_psf);\n            context3D.setProgram(programs[1]);\n            context3D.setDepthTest(false, \"less\");\n            context3D.setBlendFactors(Context3DBlendFactor.SOURCE_ALPHA, Context3DBlendFactor.ONE);\n            context3D.setTextureAt(0, _partTex);\n            context3D.setTextureAt(1, null);\n            context3D.setProgramConstantsFromMatrix(\"vertex\",   0, sigl.modelViewProjectionMatrix, true);\n            _psf.drawTriangles(context3D);\n//            if(!_s){_s=new BitmapData(450,450,false,0);with(addChildAt(new Bitmap(_s),0)){x=y=8;}}context3D.drawToBitmapData(_s);\n            context3D.present();\n\n            if (_autoPlay.selected) {\n                if (_isBreaking) {\n                    if (phase > 200) { if (!_restart) randomize(); _restart = false; updateMesh(); start(); }\n                } else {\n                    if (phase > 1.5) { reset(); }\n                }\n            } else {\n                if (_isBreaking && _restart && phase > 200) { _restart = false; updateMesh(); start(); }\n            }\n        }\n        private var _s:BitmapData = null;\n    }\n}\n\n\n// wire\nvar vs0:String = <agal><![CDATA[\nmov vt0.xyz, va1.xyz\nmov vt0.w, vc127.x\nmov v0, vt0\nmul vt1, vt0, va3.xxx\nadd vt1, vt1, va0\nm44 op,  vt1, vc0\nm44 vt0, vt0, vc4\nmul vt0, vt0, vc127.y\nadd v1,  vt0, vc127.y\nmov v2, va2\nmov v2.w, vc127.x\n]]></agal>;\nvar fs0:String = <agal><![CDATA[\ndp3 ft0, v0, fc0\nmul ft0, ft0, v2\nsat ft0, ft0\nmul ft0, fc3, ft0\nadd ft0, ft0, fc2\ndp3 ft1, v0, fc1\ntex ft3, ft1.xy, fs0 <2d,clamp,nearest>\ntex ft4, v1.xy, fs1 <2d,repeat,nearest>\nmul ft4, ft4, fc27.w\nsub ft4, ft4, fc27.z\nmul ft4, ft4, fc4.x\nsat ft2, ft4\nadd ft4, ft4, fc27.z\nsat ft1, ft4\nadd ft0, ft0, ft2\nmul ft0, ft0, ft1\nadd oc, ft0, ft3\n]]></agal>;\n\n// point particle\nvar vs1:String = <agal><![CDATA[\nm44 vt0, va0, vc0\nmov vt1.xy, va1\nmov vt1.zw, vc127.xx\ndiv vt1.xy, vt1.xy, vt0.w\nmul vt1.xy, vt1.xy, vc126.xy\nadd op, vt0, vt1\nmov v0, va2\nmov v1, va3\nmov v2, va4\n]]></agal>;\nvar fs1:String = <agal><![CDATA[\ntex ft0, v0.xy, fs0 <2d, clamp, nearest>\nmul ft0, ft0, v1\nadd ft0, ft0, v2\nsat oc, ft0\n]]></agal>;\n\nvar shaders:Array = [{\"vs\":vs0,\"fs\":fs0},{\"vs\":vs1,\"fs\":fs1}];\n\n\n\nimport flash.geom.*;\nimport flash.utils.*;\n//import org.si.ptolemy.core.*;\n\nvar c:Vector3D = new Vector3D();\nfunction hsv2rgb(h:Number, s:Number, v:Number) : Vector3D {\n    var ht:Number=(h-int(h)+int(h<0))*6, hi:int=int(ht);\n    switch(hi) {\n        case 0: c.setTo(v, v*(1-(1-ht+hi)*s), v*(1-s)); break;\n        case 1: c.setTo(v*(1-(ht-hi)*s), v, v*(1-s)); break;\n        case 2: c.setTo(v*(1-s), v, v*(1-(1-ht+hi)*s)); break;\n        case 3: c.setTo(v*(1-s), v*(1-(ht-hi)*s), v); break;\n        case 4: c.setTo(v*(1-(1-ht+hi)*s), v*(1-s), v); break;\n        case 5: c.setTo(v, v*(1-s), v*(1-(ht-hi)*s)); break;\n    }\n    return c;\n}\n\nclass Trochoid3D {\n    public var r0:Number, r1:Number, r2:Number, f0:Number, f1:Number, f2:Number, p0:Number, p1:Number, p2:Number, dr2:Number = 0;\n    public var $:Vector3D = new Vector3D(), matrix3D:Matrix3D = new Matrix3D();\n    static private var _in:Vector.<Number> = new Vector.<Number>(3, true);\n    static private var _out:Vector.<Number> = new Vector.<Number>(3, true);\n    function Trochoid3D(r0:Number=1, r1:Number=0.5, r2:Number=0.71, f0:Number=2, f1:Number=1, f2:Number=3, p0:Number=0, p1:Number=0, p2:Number=0) {\n        init(r0, r1, r2, f0, f1, f2, p0, p1, p2);\n    }\n    public function init(r0:Number, r1:Number, r2:Number, f0:Number, f1:Number, f2:Number, p0:Number=0, p1:Number=0, p2:Number=0) : void {\n        this.r0 = r0; this.p0 = p0 * 6.283185307179586; this.f0 =  f0 * 6.283185307179586; \n        this.r1 = r1; this.p1 = p1 * 6.283185307179586; this.f1 = -f1 * 6.283185307179586; \n        this.r2 = r2; this.p2 = p2 * 6.283185307179586; this.f2 =  f2 * 6.283185307179586;\n    }\n    public function calc(t:Number) : Vector3D {\n        var a0:Number = t*f0+p0, a1:Number = t*f1+p1, a2:Number = t*f2+p2, \n            s0:Number = Math.sin(a0), s1:Number = Math.sin(a1), s2:Number = Math.sin(a2), \n            c0:Number = Math.cos(a0), c1:Number = Math.cos(a1), x:Number, y:Number;\n        _in[0] = x = c0 * r0 + c1 * r1;\n        _in[1] = y = s0 * r0 + s1 * r1;\n        _in[2] = s2 * r2 * (1 + Math.sqrt(x*x+y*y) * dr2);\n        matrix3D.transformVectors(_in, _out);\n        $.setTo(_out[0], _out[1], _out[2]);\n        return $;\n    }\n}\n\n\nclass ParticleSetting {\n    public var positionVar:Vector3D = null, velocity:Vector3D = null, gravity:Vector3D = null, velocityVar:Number = 0;\n    public var speed:Number = 0, speedVar:Number = 0, accel:Number = 0, accelVar:Number = 0;\n    public var angle:Number = 0, angleVar:Number = 0, rotation:Number = 0, rotationVar:Number = 0;\n    public var life:Number = 1, lifeVar:Number = 0, gradation:Vector.<Vector3D> = null;\n    public var startColor:Vector3D = null, endColor:Vector3D = null;\n    public var startSize:Number = 1, startSizeVar:Number = 0, endSize:Number = 0, endSizeVar:Number = 0;\n    public var texture:PointSpriteTexInfo = new PointSpriteTexInfo(0,0,1,1,32,32);\n    function ParticleSetting(param:* = null) {\n        if (param) for (var key:String in param) this[key] = param[key];\n    }\n}\n\nclass Particle extends Vector3D {\n    static private var s$:Vector.<Number>, c$:Vector.<Number>;\n    static private var _vtemp:Vector3D = new Vector3D(), _ONE_VECTOR:Vector3D, _ZERO_VECTOR:Vector3D;\n    static private var _activeList:Particle = null;\n    static private var _freeList:Particle = null;\n    static private var _prevTime:uint;\n    public var next:Particle, texture:PointSpriteTexInfo, life:Number, ilife:Number, age:Number;\n    public var vx:Number, vy:Number, vz:Number, ax:Number, ay:Number, az:Number;\n    public var scale:Number, dscale:Number, angle:int, dangle:Number;\n    public var color:Vector3D = new Vector3D(), dcolor:Vector3D = new Vector3D();\n    static public function initialize() : void {\n        if (!c$) {\n            c$ = new Vector.<Number>(8192, true);\n            s$ = new Vector.<Number>(8192, true);\n            for (var i:int=0;i<8192;i++) c$[(i-2048)&8191] = s$[i] = Math.sin(i*0.0007669903939428206);\n            _ONE_VECTOR = new Vector3D(1, 1, 1, 1);\n            _ZERO_VECTOR = new Vector3D(0, 0, 0, 0);\n        }\n        _prevTime = getTimer();\n    }\n    static public function alloc(setting:ParticleSetting, x:Number, y:Number, z:Number, commonVelocity:Vector3D=null) : Particle {\n        var newPart:Particle = _freeList || new Particle(), $:Function = Math.random, \n            speed:Number = setting.speed + setting.speedVar * ($()-0.5),\n            accel:Number = setting.accel + setting.accelVar * ($()-0.5),\n            velvr:Number = 1 + setting.velocityVar * ($()-0.5), \n            posv:Vector3D = setting.positionVar || _ZERO_VECTOR, \n            vel:Vector3D  = setting.velocity || commonVelocity || _ZERO_VECTOR, \n            grav:Vector3D = setting.gravity || _ZERO_VECTOR, \n            scol:Vector3D = setting.startColor || _ONE_VECTOR, \n            ecol:Vector3D = setting.endColor || scol;\n        if (_freeList) _freeList = _freeList.next;\n        _vtemp.setTo($()-0.5, $()-0.5, $()-0.5);\n        _vtemp.normalize();\n        newPart.setTo(x+posv.x*($()-0.5), y+posv.y*($()-0.5), z+posv.z*($()-0.5));\n        newPart.texture = setting.texture;\n        newPart.life = setting.life  + setting.lifeVar  * ($()-0.5);\n        newPart.ilife = 1/newPart.life;\n        newPart.age = 0;\n        newPart.color.copyFrom(scol);\n        newPart.color.w = scol.w;\n        newPart.dcolor.setTo(ecol.x-scol.x, ecol.y-scol.y, ecol.z-scol.z);\n        newPart.dcolor.w = ecol.w - scol.w;\n        newPart.vx = vel.x * velvr + _vtemp.x * speed;\n        newPart.vy = vel.y * velvr + _vtemp.y * speed;\n        newPart.vz = vel.z * velvr + _vtemp.z * speed;\n        newPart.ax = _vtemp.x * accel + grav.x;\n        newPart.ay = _vtemp.y * accel + grav.y;\n        newPart.az = _vtemp.z * accel + grav.z;\n        newPart.scale  = setting.startSize + setting.startSizeVar*($()-0.5);\n        newPart.dscale = setting.endSize   + setting.endSizeVar  *($()-0.5) - newPart.scale;\n        newPart.angle  = (setting.angle    + setting.angleVar   *($()-0.5))*22.755555555555556; // 8192/360\n        newPart.dangle = (setting.rotation + setting.rotationVar*($()-0.5))*22.755555555555556;\n        if ($() < 0.5) newPart.dangle = -newPart.dangle;\n        newPart.next = _activeList;\n        return _activeList = newPart;\n    }\n    static public function update(psf:PointSpriteField) : void {\n        var p:Particle, prev:Particle, t:Number, ang:int, scl:Number, sin:Number, cos:Number, \n            r:Number, g:Number, b:Number, a:Number, now:uint = getTimer(), dt:Number=(now-_prevTime)*0.001;\n        _prevTime = now;\n        for (p=_activeList; p;) {\n            p.age += dt;\n            if (p.age < p.life) {\n                t = p.age * p.ilife;\n                p.x += (p.vx + p.ax * dt * 0.5) * dt;\n                p.y += (p.vy + p.ay * dt * 0.5) * dt;\n                p.z += (p.vz + p.az * dt * 0.5) * dt;\n                p.vx += p.ax * dt;\n                p.vy += p.ay * dt;\n                p.vz += p.az * dt;\n                ang = (int(p.angle + p.dangle * t))&8191;\n                scl = p.scale + p.dscale * t;\n                sin = s$[ang];  cos = c$[ang];\n                r = p.color.x + p.dcolor.x * t;\n                g = p.color.y + p.dcolor.y * t;\n                b = p.color.z + p.dcolor.z * t;\n                a = p.color.w + p.dcolor.w * t;\n                psf.createSprite(p.texture, p.x, p.y, p.z, scl*cos, -scl*sin, scl*sin, scl*cos, r, g, b, a);\n                prev = p; p = prev.next;\n            } else {\n                if (prev) { prev.next   = p.next; p.next = _freeList; _freeList = p; p = prev.next; } \n                else      { _activeList = p.next; p.next = _freeList; _freeList = p; p = _activeList; }\n            }\n        }\n    }\n}\n\n\n\n\n/* Tiny Ptolemy */ {\n    import flash.net.*;\n    import flash.geom.*;\n    import flash.events.*;\n    import flash.system.*;\n    import flash.display.*;\n    import flash.display3D.*;\n    import com.adobe.utils.*;\n\n\n    /** Operation Center */\n    class Ptolemy extends EventDispatcher {\n    // variables ----------------------------------------\n        public var context3D:Context3D;\n        public var sigl:SiGLCore;\n        public var resources:* = {};\n\n        private var _loadedResourceCount:int;\n    // constructor ----------------------------------------\n        function Ptolemy(parent:DisplayObjectContainer, xpos:Number, ypos:Number ,width:int, height:int) : void {\n            var stage:Stage = parent.stage, stage3D:Stage3D = stage.stage3Ds[0];\n            stage.scaleMode = StageScaleMode.NO_SCALE;\n            stage.align = StageAlign.TOP_LEFT;\n            stage.quality = StageQuality.LOW;\n            stage3D.x = xpos; stage3D.y = ypos;\n            sigl = new SiGLCore(width, height);\n            stage3D.addEventListener(Event.CONTEXT3D_CREATE, function(e:Event):void{\n                context3D = e.target.context3D;\n                if (context3D) {\n                    context3D.enableErrorChecking = true;                   // check internal error\n                    context3D.configureBackBuffer(width, height, 0, true);  // disable AA/ enable depth/stencil\n                    context3D.setBlendFactors(Context3DBlendFactor.SOURCE_ALPHA, Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA);\n                    context3D.setCulling(Context3DTriangleFace.BACK);       // culling back face\n                    context3D.setRenderToBackBuffer();\n                    dispatchEvent(e.clone());\n                    if (--_loadedResourceCount == 0) dispatchEvent(new Event(Event.COMPLETE));\n                } else dispatchEvent(new ErrorEvent(ErrorEvent.ERROR, false, false, \"Context3D not found\"));\n            });\n            stage3D.requestContext3D();\n            _loadedResourceCount = 1;\n        }\n    // load resource ----------------------------------------\n        public function load(urlRequest:URLRequest, id:String=null, type:String=null, checkPolicyFile:Boolean=false) : EventDispatcher {\n            var loader:Loader, urlLoader:URLLoader;\n            _loadedResourceCount++;\n            if (type == \"img\") {\n                loader = new Loader();\n                loader.load(urlRequest, new LoaderContext(checkPolicyFile));\n                loader.contentLoaderInfo.addEventListener(Event.COMPLETE, function(e:Event) : void {\n                    resources[id] = e.target.content;\n                    if (--_loadedResourceCount == 0) dispatchEvent(new Event(Event.COMPLETE));\n                });\n                return loader;\n            }\n            urlLoader = new URLLoader(urlRequest);\n            urlLoader.dataFormat = (type == \"txt\") ? URLLoaderDataFormat.TEXT : URLLoaderDataFormat.BINARY;\n            urlLoader.addEventListener(Event.COMPLETE, function(e:Event) : void {\n                resources[id] = e.target.data;\n                if (--_loadedResourceCount == 0) dispatchEvent(new Event(Event.COMPLETE));\n            });\n            return urlLoader;\n        }\n    }\n    \n\n    /** SiGLCore provides basic matrix operations. */\n    class SiGLCore {\n    // variables ----------------------------------------\n        public var modelViewMatrix:SiGLMatrix = new SiGLMatrix(), projectionMatrix:SiGLMatrix = new SiGLMatrix();\n        public var viewWidth:Number, viewHeight:Number, pointSpriteFieldScale:Point = new Point();\n        public var defaultCameraMatrix:SiGLMatrix = new SiGLMatrix(), matrix:SiGLMatrix = modelViewMatrix;\n        private var _mvpMatrix:Matrix3D = new Matrix3D(), _mvpdir:Boolean, _2d:Number, _2r:Number;\n        private var _mag:Number, _zNear:Number, _zFar:Number, _fieldOfView:Number, _alignTopLeft:Boolean = false;\n    // properties ----------------------------------------\n        public function get modelViewProjectionMatrix() : Matrix3D {\n            if (_mvpdir) {\n                _mvpMatrix.copyFrom(projectionMatrix);\n                _mvpMatrix.prepend(modelViewMatrix);\n                _mvpdir = false;\n            }\n            return _mvpMatrix;\n        }\n        public function get align() : String { return (_alignTopLeft) ? \"topLeft\" : \"center\"; }\n        public function set align(mode:String) : void { _alignTopLeft = (mode == \"topLeft\"); _updateProjectionMatrix(); }\n        public function get matrixMode() : String { return (matrix === projectionMatrix) ? \"projection\" : \"modelView\"; }\n        public function set matrixMode(mode:String) : void { matrix = (mode == \"projection\") ? projectionMatrix : modelViewMatrix; }\n        public function get angleMode() : String { return (_2r == 1) ? \"radian\" : \"degree\"; }\n        public function set angleMode(mode:String) : void { _2d = (mode == \"radian\") ? 57.29577951308232 : 1; _2r = (mode == \"radian\") ? 1 : 0.017453292519943295; }\n        public function get fieldOfView() : Number { return _fieldOfView / _2r; }\n        public function set fieldOfView(fov:Number) : void { _fieldOfView = fov * _2r; _updateProjectionMatrix(); }\n        public function get magnification() : Number { return _mag; }\n        public function set magnification(mag:Number) : void { _mag = mag; _updateProjectionMatrix(); }\n    // constructor ----------------------------------------\n        function SiGLCore(width:Number=1, height:Number=1) {\n            viewWidth = width; viewHeight = height;\n            angleMode = \"degree\"; _mag = 1;\n            _zNear = -1000; _zFar = 200;\n            modelViewMatrix.identity();\n            _mvpdir = true;\n            this.fieldOfView = 60;\n        }\n    // matrix operations ----------------------------------------\n        public function forceUpdateMatrix() : SiGLCore { _mvpdir = true; return this; }\n        public function setZRange(zNear:Number=-100, zFar:Number=100) : SiGLCore { _zNear = zNear; _zFar = zFar; _updateProjectionMatrix(); return this; }\n        public function clear() : SiGLCore { matrix.clear(); _mvpdir = true; return this; }\n        public function id() : SiGLCore { matrix.id(); _mvpdir = true; return this; }\n        public function push() : SiGLCore { matrix.push(); return this; }\n        public function pop() : SiGLCore { matrix.pop(); _mvpdir = true; return this; }\n        public function r(a:Number, axis:Vector3D, pivot:Vector3D = null) : SiGLCore { matrix.prependRotation(a*_2d, axis, pivot); matrix._invdir = _mvpdir = true; return this; }\n        public function s(x:Number, y:Number, z:Number=1) : SiGLCore { matrix.prependScale(x, y, z); matrix._invdir = _mvpdir = true; return this; }\n        public function t(x:Number, y:Number, z:Number=0) : SiGLCore { matrix.prependTranslation(x, y, z); matrix._invdir = _mvpdir = true; return this; }\n        public function m(mat:Matrix3D) : SiGLCore { matrix.prepend(mat); matrix._invdir = _mvpdir = true; return this; }\n        public function re(x:Number, y:Number, z:Number) : SiGLCore { matrix.prependRotationXYZ(x*_2r, y*_2r, z*_2r); _mvpdir = true; return this; }\n        public function setCameraMatrix(mat:Matrix3D=null) : SiGLCore { projectionMatrix.rem().prepend(mat || defaultCameraMatrix); _mvpdir = true; return this; }\n        private function _updateProjectionMatrix() : void {\n            var wh:Number = viewWidth / viewHeight, rev:Number = (_alignTopLeft)?-1:1,\n                fl:Number = (viewHeight * 0.5) / Math.tan(_fieldOfView * 0.5);\n            if (_zNear <= -fl) _zNear = -fl + 0.001;\n            projectionMatrix.clear().perspectiveFieldOfView(_fieldOfView, wh, _zNear+fl, _zFar+fl, -1);\n            pointSpriteFieldScale.setTo(projectionMatrix.rawData[0] * fl, projectionMatrix.rawData[5] * fl);\n            projectionMatrix.push();\n            defaultCameraMatrix.identity();\n            defaultCameraMatrix.prependTranslation(0, 0, -fl);\n            if (_alignTopLeft) defaultCameraMatrix.prependTranslation(viewWidth* 0.5, -viewHeight * 0.5, 0);\n            defaultCameraMatrix.prependScale(_mag, _mag * rev, _mag * rev);\n            setCameraMatrix();\n        }\n    }\n    \n    \n\n    /** SiGLMatrix is extention of Matrix3D with push/pop operation */\n    class SiGLMatrix extends Matrix3D {\n        internal var _invdir:Boolean = false, _inv:Matrix3D = new Matrix3D(), _stac:Vector.<Matrix3D> = new Vector.<Matrix3D>();\n        static private var _tv:Vector.<Number> = new Vector.<Number>(16, true), _tm:Matrix3D = new Matrix3D();\n        static private var _in:Vector.<Number> = new Vector.<Number>(4, true), _out:Vector.<Number> = new Vector.<Number>(4, true);\n        public function get inverted() : Matrix3D { if (_invdir) { _inv.copyFrom(this); _inv.invert(); _invdir = false; } return _inv; }\n        public function forceUpdateInvertedMatrix() : SiGLMatrix { _invdir=true; return this; }\n        public function clear() : SiGLMatrix { _stac.length=0; return id(); }\n        public function id() : SiGLMatrix { identity(); _inv.identity(); return this; }\n        public function push() : SiGLMatrix { _stac.push(this.clone()); return this; }\n        public function pop() : SiGLMatrix { this.copyFrom(_stac.pop()); _invdir=true; return this; }\n        public function rem() : SiGLMatrix { this.copyFrom(_stac[_stac.length-1]); _invdir=true; return this; }\n        public function prependRotationXYZ(rx:Number, ry:Number, rz:Number) : SiGLMatrix {\n            var sx:Number = Math.sin(rx), sy:Number = Math.sin(ry), sz:Number = Math.sin(rz), \n                cx:Number = Math.cos(rx), cy:Number = Math.cos(ry), cz:Number = Math.cos(rz);\n            _tv[0] = cz*cy; _tv[1] = sz*cy; _tv[2] = -sy; _tv[4] = -sz*cx+cz*sy*sx; _tv[5] = cz*cx+sz*sy*sx;\n            _tv[6] = cy*sx; _tv[8] = sz*sx+cz*sy*cx; _tv[9] = -cz*sx+sz*sy*cx;\n            _tv[10] = cy*cx; _tv[14] = _tv[13] = _tv[12] = _tv[11] = _tv[7] = _tv[3] = 0; _tv[15] = 1;\n            _tm.copyRawDataFrom(_tv); prepend(_tm); _invdir=true;\n            return this;\n        }\n        public function lookAt(cx:Number, cy:Number, cz:Number, tx:Number=0, ty:Number=0, tz:Number=0, ux:Number=0, uy:Number=1, uz:Number=0, w:Number=0) : SiGLMatrix {\n            var dx:Number=tx-cx, dy:Number=ty-cy, dz:Number=tz-cz, dl:Number=-1/Math.sqrt(dx*dx+dy*dy+dz*dz), \n                rx:Number=dy*uz-dz*uy, ry:Number=dz*ux-dx*uz, rz:Number=dx*uy-dy*ux, rl:Number= 1/Math.sqrt(rx*rx+ry*ry+rz*rz);\n            _tv[0]  = (rx*=rl); _tv[4]  = (ry*=rl); _tv[8]  = (rz*=rl); _tv[12] = -(cx*rx+cy*ry+cz*rz) * w;\n            _tv[2]  = (dx*=dl); _tv[6]  = (dy*=dl); _tv[10] = (dz*=dl); _tv[14] = -(cx*dx+cy*dy+cz*dz) * w;\n            _tv[1]  = (ux=dy*rz-dz*ry); _tv[5]  = (uy=dz*rx-dx*rz); _tv[9]  = (uz=dx*ry-dy*rx); _tv[13] = -(cx*ux+cy*uy+cz*uz) * w;\n            _tv[3] = _tv[7] = _tv[11] = 0; _tv[15] = 1; copyRawDataFrom(_tv); _invdir=true;\n            return this;\n        }\n        public function perspectiveFieldOfView(fieldOfViewY:Number, aspectRatio:Number, zNear:Number, zFar:Number, lh:Number=1.0) : void {\n            var yScale:Number = 1.0 / Math.tan(fieldOfViewY * 0.5), xScale:Number = yScale / aspectRatio;\n            this.copyRawDataFrom(Vector.<Number>([xScale,0,0,0,0,yScale,0,0,0,0,zFar/(zFar-zNear)*lh,lh,0,0,(zNear*zFar)/(zNear-zFar),0]));\n        }\n        public function transform(vector:Vector3D) : Vector3D {\n            _in[0] = vector.x; _in[1] = vector.y; _in[2] = vector.z; _in[3] = vector.w;\n            transformVectors(_in, _out); vector.setTo(_out[0], _out[1], _out[2]); vector.w = _out[3];\n            return vector;\n        }\n    }\n    \n    \n    /** Mesh */\n    class Mesh {\n    // variables ----------------------------------------\n        public var vertices:Vector.<Number> = new Vector.<Number>();\n        public var faces:Vector.<Face> = new Vector.<Face>();\n        public var vertexBuffer:VertexBuffer3D, indexBuffer:IndexBuffer3D;\n        public var data32PerVertex:int, attributeList:Array = [];\n        private var _indices:Vector.<uint> = new Vector.<uint>(), _indexDirty:Boolean=true;\n    // properties ----------------------------------------\n        public function get vertexCount() : int { return vertices.length / data32PerVertex; }\n        public function set vertexCount(count:int) : void { vertices.length = count * data32PerVertex; }\n        public function get indices() : Vector.<uint> {\n            var idx:Vector.<uint> = _indices, f:Face, i:int, imax:int, j:int;\n            if (_indexDirty) {\n                idx.length = imax = faces.length * 3;\n                for (i=0,j=0; i<imax; j++) { f=faces[j]; idx[i]=f.i0; i++; idx[i]=f.i1; i++; idx[i]=f.i2; i++; }\n                _indexDirty = false;\n            }\n            return idx;\n        }\n    // contructor ----------------------------------------\n        function Mesh(bufferFormat:String=\"V3\") {\n            var rex:RegExp = /([_a-zA-Z]+)([1234b])/g, res:*, i:int=0;\n            data32PerVertex = 0;\n            while (res = rex.exec(bufferFormat)) data32PerVertex += (attributeList[i++]=int(res[2]));\n        }\n    // oprations ----------------------------------------\n        public function allocateBuffer(context3D:Context3D) : Mesh {\n            vertexBuffer = context3D.createVertexBuffer(vertexCount, data32PerVertex);\n            indexBuffer  = context3D.createIndexBuffer(indices.length);\n            return this;\n        }\n        public function upload(vertex:Boolean=true, index:Boolean=true) : Mesh {\n            if (vertex) vertexBuffer.uploadFromVector(vertices, 0, vertexCount);\n            if (index) indexBuffer.uploadFromVector(indices, 0, indices.length);\n            return this;\n        }\n        public function drawTriangles(context3D:Context3D) : Mesh {\n            var i:int, offset:int=0, form:Array = [\"\",\"float1\",\"float2\",\"float3\",\"float4\"];\n            for (i=0; i<attributeList.length; offset+=attributeList[i++]) context3D.setVertexBufferAt(i, vertexBuffer, offset, form[attributeList[i]]);\n            context3D.drawTriangles(indexBuffer, 0, faces.length);\n            for (i=0; i<attributeList.length; i++) context3D.setVertexBufferAt(i, null, 0, \"float1\");\n            return this;\n        }\n        public function clear() : Mesh { for (var i:int=0; i<faces.length; i++) Face.free(faces[i]); faces.length = 0; _indexDirty = true; return this; }\n        public function face(i0:int, i1:int, i2:int) : Mesh { faces.push(Face.alloc(i0, i1, i2)); _indexDirty = true; return this; }\n        public function qface(i0:int, i1:int, i2:int, i3:int) : Mesh { faces.push(Face.alloc(i0, i1, i2), Face.alloc(i3, i2, i1)); _indexDirty = true; return this; }\n        public function updateFaceNormal(updateVertexNormal:Boolean=true) : Mesh {\n            var vtx:Vector.<Number> = vertices, vcount:int = vertexCount, fcount:int = faces.length, \n                i:int, istep:int, f:Face, iw:Number, fidx:int,  i0:int, i1:int, i2:int, n0:Vector3D, n1:Vector3D, n2:Vector3D, \n                x01:Number, x02:Number, y01:Number, y02:Number, z01:Number, z02:Number;\n            // calculate face normals\n            for (i=0; i<fcount; i++) {\n                f=faces[i];\n                i0=f.i0*data32PerVertex; i1=f.i1*data32PerVertex; i2=f.i2 * data32PerVertex;\n                x01 = vtx[i1]-vtx[i0]; x02 = vtx[i2]-vtx[i0]; i0++; i1++; i2++;\n                y01 = vtx[i1]-vtx[i0]; y02 = vtx[i2]-vtx[i0]; i0++; i1++; i2++;\n                z01 = vtx[i1]-vtx[i0]; z02 = vtx[i2]-vtx[i0];\n                f.normal.setTo(y02*z01-y01*z02, z02*x01-z01*x02, x02*y01-x01*y02);\n                f.normal.normalize();\n            }\n            // calculate vertex normals\n            if (updateVertexNormal) {\n                istep = data32PerVertex - 2;\n                // initialize\n                for (i=0, i0=3; i<vcount; i++, i0+=istep) { vtx[i0]=0; i0++; vtx[i0]=0; i0++; vtx[i0]=0; }\n                // sum up\n                for (i=0; i<fcount; i++) {\n                    f = faces[i];\n                    i0 = f.i0 * data32PerVertex + 3;\n                    vtx[i0]+=f.normal.x; i0++; vtx[i0]+=f.normal.y; i0++; vtx[i0]+=f.normal.z;\n                    i0 = f.i1 * data32PerVertex + 3;\n                    vtx[i0]+=f.normal.x; i0++; vtx[i0]+=f.normal.y; i0++; vtx[i0]+=f.normal.z;\n                    i0 = f.i2 * data32PerVertex + 3;\n                    vtx[i0]+=f.normal.x; i0++; vtx[i0]+=f.normal.y; i0++; vtx[i0]+=f.normal.z;\n                }\n                /* normalize (ussualy normalizing by gpu).\n                for (i=0, i0=3; i<vcount; i++, i0+=istep) {\n                    x01 = vtx[i0]; i0++; y01 = vtx[i0]; i0++; z01 = vtx[i0]; i0-=2;\n                    iw = 1 / Math.sqrt(x01*x01 + y01*y01 + z01*z01);\n                    vtx[i0] = x01 * iw; i0++; vtx[i0] = y01 * iw; i0++; vtx[i0] = z01 * iw;\n                } //*/\n            }\n            return this;\n        }\n    }\n    \n    /** Face */\n    class Face {\n        public var i0:int, i1:int, i2:int, normal:Vector3D = new Vector3D();\n        function Face() { i0 = i1 = i2 = 0; }\n        static private var _freeList:Vector.<Face> = new Vector.<Face>();\n        static public function free(face:Face) : void { _freeList.push(face); }\n        static public function alloc(i0:int, i1:int, i2:int) : Face { \n            var f:Face = _freeList.pop() || new Face();\n            f.i0 = i0; f.i1 = i1; f.i2 = i2; return f;\n        }\n    }\n    \n    /** Light */\n    class Light extends Vector3D {\n        private var _in :Vector.<Number> = new Vector.<Number>(6, true), _out:Vector.<Number> = new Vector.<Number>(6, true);\n        private var _lv:Vector.<Number>  = new Vector.<Number>(4, true), _hv:Vector.<Number>  = new Vector.<Number>(4, true);\n        private var _mvm:Matrix3D = new Matrix3D(), ZERO_VECTOR:Vector3D = new Vector3D();\n        public function get lightVector() : Vector.<Number> { return _lv; }\n        public function get halfVector() : Vector.<Number> { return _hv; }\n        public function transform(sigl:SiGLCore) : void {\n            var ilen:Number = 1/length, hx:Number, hy:Number, hz:Number;\n            _mvm.copyFrom(sigl.modelViewMatrix); _mvm.copyRowFrom(3, ZERO_VECTOR); _mvm.invert();\n            hx = _in[0] = x * ilen; hy = _in[1] = y * ilen; hz = (_in[2] = z * ilen) + 1;\n            ilen = 1 / Math.sqrt(hx * hx + hy * hy + hz * hz);\n            _in[3] = hx * ilen; _in[4] = hy * ilen; _in[5] = hz * ilen;\n            _mvm.transformVectors(_in, _out);\n            _lv[0] = _out[0]; _lv[1] = _out[1]; _lv[2] = _out[2];\n            _hv[0] = _out[3]; _hv[1] = _out[4]; _hv[2] = _out[5];\n        }\n    }\n    \n    /** flat shading material */\n    class FlatShadingMaterial {\n        private var _col:int, _alp:Number, _amb:Number, _dif:Number, _spc:Number, _pow:Number;\n        private var _specMap:BitmapData = new BitmapData(1024,1,false);\n        private var _ambVector:Vector.<Number> = new Vector.<Number>(4, true);\n        private var _difDifVector:Vector.<Number> = new Vector.<Number>(4, true);\n        public function set color(c:int) : void { setColor(c, _alp, _amb, _dif); }\n        public function get color() : int { return _col; }\n        public function set alpha(a:Number) : void { setColor(_col, a, _amb, _dif); }\n        public function get alpha() : Number { return _alp; }\n        public function set ambient(a:Number) : void { setColor(_col, _alp, a, _dif); }\n        public function get ambient() : Number { return _amb; }\n        public function set diffuse(d:Number) : void { setColor(_col, _alp, _amb, d); }\n        public function get diffuse() : Number { return _dif; }\n        public function set specular(s:Number) : void { setSpecular(s, _pow); }\n        public function get specular() : Number { return _spc; }\n        public function set power(p:Number) : void { setSpecular(_spc, p); }\n        public function get power() : Number { return _pow; }\n        public function get ambientVector() : Vector.<Number> { return _ambVector; }\n        public function get diffuseDifVector() : Vector.<Number> { return _difDifVector; }\n        public function get specMap() : BitmapData { return _specMap; }\n        function FlatShadingMaterial(color:int=0xffffff, alpha:Number=1, ambient:Number=0.25, diffuse:Number=0.75, specular:Number=0.75, power:Number=16) {\n            setColor(color, alpha, ambient, diffuse);\n            setSpecular(specular, power);\n        }\n        public function setColor(color:int, alpha:Number=1, ambient:Number=0.25, diffuse:Number=0.75) : FlatShadingMaterial {\n            _col = color; _alp = alpha; _amb = ambient; _dif = diffuse;\n            var r:Number = ((color>>16)&255)*0.00392156862745098, g:Number = ((color>>8)&255)*0.00392156862745098, b:Number = (color&255)*0.00392156862745098;\n            _ambVector[0] = r * ambient; _ambVector[1] = g * ambient; _ambVector[2] = b * ambient; _ambVector[3] = alpha;\n            _difDifVector[0] = r * diffuse - _ambVector[0]; _difDifVector[1] = g * diffuse - _ambVector[1]; _difDifVector[2] = b * diffuse - _ambVector[2]; _difDifVector[3] = alpha;\n            return this;\n        }\n        private function setSpecular(specular:Number=0.75, power:Number=16) : FlatShadingMaterial {\n            _spc = specular; _pow = power; specular *= 256;\n            for (var i:int=0; i<1024; i++) {\n                var c:int = int(Math.pow(i*0.0009775171065493646, power) * specular);\n                _specMap.setPixel32(i, 0, ((c<256)?c:255)*0x10101);\n            }\n            return this;\n\n        }\n    }\n    \n    \n\n    /** Point Sprite Field */\n    class PointSpriteField extends Mesh {\n    // variables --------------------------------------------------\n        public var spriteCount:int, maxSpriteCount:int;\n    // constructor --------------------------------------------------\n        function PointSpriteField(context3D:Context3D, maxSpriteCount:int=1024) {\n            super(\"V3S2T2C4O4\");\n            vertexCount = (this.maxSpriteCount = maxSpriteCount) * 4;\n            spriteCount = 0;\n            for (var i:int=0, j:int=0; i<maxSpriteCount; i++) qface(j++, j++, j++, j++);\n            allocateBuffer(context3D);\n            upload();\n        }\n    // operations --------------------------------------------------\n        public function clearSprites() : PointSpriteField { spriteCount = 0; return this; }\n        public function createSprite(tex:PointSpriteTexInfo, x:Number, y:Number, z:Number=0, \n                                     mata:Number=1, matb:Number=0, matc:Number=0, matd:Number=1,\n                                     rmul:Number=1, gmul:Number=1, bmul:Number=1, amul:Number=1, \n                                     radd:Number=0, gadd:Number=0, badd:Number=0, aadd:Number=0) : PointSpriteField {\n            var wa:Number = tex.hw*mata, wc:Number = tex.hw*matc, hb:Number = tex.hh*matb, hd:Number = tex.hh*matd, \n                v0x:Number = -wa+hb, v0y:Number = -wc+hd, v1x:Number = wa+hb, v1y:Number = wc+hd, \n                i0:int = spriteCount*data32PerVertex*4, i1:int=i0+data32PerVertex, i2:int=i1+data32PerVertex, i3:int=i2+data32PerVertex;\n            if (spriteCount == maxSpriteCount) return this;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = x; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = y; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = z; i0++; i1++; i2++; i3++;\n            vertices[i3] = -(vertices[i0] = v0x); i0++; i3++;\n            vertices[i3] = -(vertices[i0] = v0y); i0++; i3++;\n            vertices[i2] = -(vertices[i1] = v1x); i1++; i2++;\n            vertices[i2] = -(vertices[i1] = v1y); i1++; i2++;\n            vertices[i0] = vertices[i2] = tex.u0; i0++; i2++;\n            vertices[i1] = vertices[i3] = tex.u1; i1++; i3++;\n            vertices[i0] = vertices[i1] = tex.v0; i0++; i1++;\n            vertices[i2] = vertices[i3] = tex.v1; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = rmul; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = gmul; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = bmul; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = amul; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = radd; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = gadd; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = badd; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = aadd; i0++; i1++; i2++; i3++;\n            spriteCount++;\n            return this;\n        }\n        override public function drawTriangles(context3D:Context3D) : Mesh {\n            if (spriteCount) {\n                vertexBuffer.uploadFromVector(vertices, 0, spriteCount*4);\n                context3D.setVertexBufferAt(0, vertexBuffer,  0, Context3DVertexBufferFormat.FLOAT_3);\n                context3D.setVertexBufferAt(1, vertexBuffer,  3, Context3DVertexBufferFormat.FLOAT_2);\n                context3D.setVertexBufferAt(2, vertexBuffer,  5, Context3DVertexBufferFormat.FLOAT_2);\n                context3D.setVertexBufferAt(3, vertexBuffer,  7, Context3DVertexBufferFormat.FLOAT_4);\n                context3D.setVertexBufferAt(4, vertexBuffer, 11, Context3DVertexBufferFormat.FLOAT_4);\n                context3D.drawTriangles(indexBuffer, 0, spriteCount*2);\n                for (var i:int=0; i<5; i++) context3D.setVertexBufferAt(i, null, 0, \"float1\");\n            }\n            return this;\n        }\n    }\n\n    /** Point Sprite Texture Infomation */\n    class PointSpriteTexInfo {\n        public var u0:Number, v0:Number, u1:Number, v1:Number, hw:Number, hh:Number;\n        function PointSpriteTexInfo(u0:Number, v0:Number, u1:Number, v1:Number, width:Number, height:Number) {\n            this.u0 = u0; this.v0 = v0; this.u1 = u1; this.v1 = v1; this.hw = width * 0.5; this.hh = height * 0.5;\n        }\n    }\n}\n\n","modified_date":1321021514,"compile_ok":"1","created_date":1320954403,"forked_count":"5","license":"MIT","swf":"http://swf.wonderfl.net/swf/usercode/1/1a/1a67/1a674425190019c28061a89e5c197c5cf61f4f3f.swf","diff":"0","user":{"icon":"http://wonderfl.net/images/icon/2/27/278a/278afc585a0a283d6e1f13f081cfd9c377ab9db2m","name":"keim_at_Si"},"title":"Spirographical Ingot Cast","id":"3LzE","favorite_count":"61"},"stat":"ok"}