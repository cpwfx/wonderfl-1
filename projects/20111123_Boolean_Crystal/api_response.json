{"code":{"thumbnail":"http://wonderfl.net/images/capture/d/dc/dc2d/dc2d00dc95e6d7c6f7738aff7d29e86abf50c9f1_100.jpg?t=1322009848","parent":null,"as3":"package {\n    import flash.display.*;\n    import flash.events.*;\n    import flash.utils.*;\n    import flash.geom.*;\n    import flash.text.*;\n    import flash.net.*;\n    \n    import com.adobe.utils.*;\n    import com.bit101.components.*;\n    import flash.display3D.*;\n    import flash.display3D.textures.*;\n    import org.libspark.betweenas3.*;\n    import org.libspark.betweenas3.easing.*;\n    import org.libspark.betweenas3.tweens.*;\n//    import org.si.ptolemy.*;\n//    import org.si.ptolemy.core.*;\n//    import org.si.ptolemy.utils.*;\n\n    public class main extends Sprite {\n/*      // for local\n        private const cceURL:String = \"cce.swf\";\n        private const envURL :String = \"_env2.png\";\n        private const cubeURL:String = \"_cube.png\";\n/*/     // for wonderfl\n        private const cceURL:String = \"http://swf.wonderfl.net/swf/usercode/6/67/679c/679c3b410a599d83b3548ce73ce37b873ae4046b.swf?v=1\";\n        private const envURL:String = \"http://assets.wonderfl.net/images/related_images/b/bb/bbf1/bbf12c60cf84e5ab43e059920783d036da25df48\";\n        private const cubeURL:String = \"http://assets.wonderfl.net/images/related_images/0/0a/0af4/0af44d6dad95415359d744cfb88e879a41e21754\";\n//*/\n        \n        private var ptolemy:Ptolemy;\n        \n        private var asm:AGALMiniAssembler = new AGALMiniAssembler();\n        private var programs:Vector.<Program3D> = new Vector.<Program3D>();\n\n        private var _meshA:Mesh = new Mesh(\"V3N3\");\n        private var _meshB:Mesh = new Mesh(\"V3N3\");\n        private var _back:Mesh = new Mesh(\"V3T2\");\n        private var _meshAMatrix:SiGLMatrix = new SiGLMatrix();\n        private var _meshBMatrix:SiGLMatrix = new SiGLMatrix();\n        private var _meshASize:Number = 180, _meshBSize:Number = 200;\n        private var _meshAShape:int = 10, _meshBShape:int = 6;\n\n        private var _boolMode:int = 4;\n        private var _boolOperations:Vector.<BooleanOperation> = Vector.<BooleanOperation>([\n            new BooleanOperation(\"A\",   \"back\",  \"none\",  \"always\",   \"never\"),\n            new BooleanOperation(\"B\",   \"none\",  \"back\",  \"never\",    \"always\"),\n            new BooleanOperation(\"A+B\", \"back\",  \"back\",  \"always\",   \"always\"),\n            new BooleanOperation(\"A*B\", \"back\",  \"back\",  \"notEqual\", \"notEqual\"),\n            new BooleanOperation(\"A-B\", \"back\",  \"front\", \"equal\",    \"notEqual\"),\n            new BooleanOperation(\"B-A\", \"front\", \"back\",  \"notEqual\", \"equal\")\n        ]);\n        \n        private var _materialA:FlatShadingMaterial = new FlatShadingMaterial(0x8080e0);\n        private var _materialB:FlatShadingMaterial = new FlatShadingMaterial(0x8080e0);\n        private var _ref:Number = 0.25;\n        private var _specTex:Texture, _cubeTex:CubeTexture;\n        private var _backMap:BitmapData, _backTex:Texture;\n        private var _light:Light = new Light();\n        private var _cameraMatrix:SiGLMatrix = new SiGLMatrix();\n        \n        private var _startTime:Number, _animStartTime:Number;\n        \n        function main() {\n            Wonderfl.disable_capture();\n            ptolemy = new Ptolemy(this, 8, 8, 450, 450);\n            ptolemy.sigl.setZRange(-300, 1000);\n            ptolemy.addEventListener(Event.COMPLETE, setup);\n            ptolemy.load(new URLRequest(cceURL),  \"cce\",  \"img\", true);\n            ptolemy.load(new URLRequest(envURL),  \"env\",  \"img\", true);\n            ptolemy.load(new URLRequest(cubeURL), \"cube\", \"img\", true);\n        }\n        \n        \n        private function setup(e:Event) : void {\n            var i:int, j:int, k:int, context3D:Context3D = ptolemy.context3D, prog:Program3D, mat:Matrix3D = new Matrix3D();\n            removeEventListener(Event.COMPLETE, setup);\n            context3D.enableErrorChecking = true;\n            \n            // create shape\n            SolidFactory.plane(_back, 450, 450, 0).updateBuffer(\"T\", Vector.<Number>([0,1,1,1,0,0,1,0]));\n            _back.allocateBuffer(context3D).upload();\n            _backMap = ptolemy.resources[\"env\"].bitmapData;\n            _backTex = context3D.createTexture(_backMap.width, _backMap.height, \"bgra\", false);\n            _backTex.uploadFromBitmapData(_backMap);\n\n            _specTex = context3D.createTexture(1024, 1, \"bgra\", false);\n            _specTex.uploadFromBitmapData(_materialA.specMap);\n            \n            _cubeTex = createCubeTexture(context3D, ptolemy.resources[\"cube\"].bitmapData);\n            updateMesh(_meshA, _meshAShape, _meshASize);\n            updateMesh(_meshB, _meshBShape, _meshBSize);\n            \n            for (i=0; i<shaders.length; i++) {\n                prog = context3D.createProgram();\n                prog.upload(asm.assemble(\"vertex\", shaders[i].vs), asm.assemble(\"fragment\", shaders[i].fs));\n                programs.push(prog);\n            }\n            \n            context3D.setProgramConstantsFromVector(\"vertex\",  126, Vector.<Number>([0.2, 2, 0, 0]));\n            context3D.setProgramConstantsFromVector(\"vertex\",  127, Vector.<Number>([0, 0.5, 1, 2]));\n            context3D.setProgramConstantsFromVector(\"fragment\", 27, Vector.<Number>([0, 0.5, 1, 2]));\n            \n            setupControler();\n            _startTime = getTimer();\n            addEventListener(Event.ENTER_FRAME, draw);\n        }\n        \n        \n        private function setupControler() : void {\n            var ColorChooserEx:Class = ptolemy.resources[\"cce\"].getClass(), cb:ComboBox, \n                shapes:Array = [\"SHPERE\", \"TETRAHEDRON\", \"HEXAHEDRON\", \"OCTAHEDRON\", \"DODECAHEDRON\", \"ICOSAHEDRON\", \"GEODESTIC DOME\", \"PENTA PILLAR\", \"CYLINDER\", \"CONE\", \"CRYSTAL\"]; \n            addChild(_mouseCapture = new Sprite());\n            _mouseCapture.graphics.beginFill(0, 0);\n            _mouseCapture.graphics.drawRect(0, 0, stage.stageWidth, stage.stageHeight);\n            _mouseCapture.graphics.endFill();\n            _mouseCapture.visible = false;\n            addChild(_ctrl = new Sprite()); _w=240; _h=20; \n            new ColorChooserEx(_ctrl,  2, 2, _materialA.color, function(e:Event):void { _materialA.color = e.target.value; });\n            new ColorChooserEx(_ctrl, 82, 2, _materialB.color, function(e:Event):void { _materialB.color = e.target.value; });\n            newSlider(\"Mesh A size\", 0, 400, _meshASize, 10, 0, function(e:Event):void { _meshASize = e.target.value; updateMesh(_meshA, _meshAShape, _meshASize); });\n            newSlider(\"Mesh B size\", 0, 400, _meshBSize, 10, 0, function(e:Event):void { _meshBSize = e.target.value; updateMesh(_meshB, _meshBShape, _meshBSize); }); _h+=10;\n            newSlider(\"ambient\", 0, 1, _materialA.ambient, 0.1, 1, function(e:Event):void { _materialA.ambient = _materialB.ambient = e.target.value; });\n            newSlider(\"diffuse\", 0, 1, _materialA.diffuse, 0.1, 1, function(e:Event):void { _materialA.diffuse = _materialB.ambient = e.target.value; });\n            newSlider(\"power\",   0,64, _materialA.power,     1, 0, function(e:Event):void { _materialA.power = e.target.value;    _specTex.uploadFromBitmapData(_materialA.specMap);});\n            newSlider(\"specular\",0, 3, _materialA.specular,0.1, 1, function(e:Event):void { _materialA.specular = e.target.value; _specTex.uploadFromBitmapData(_materialA.specMap);});\n            newSlider(\"refrect\", 0, 1, _ref,               0.1, 1, function(e:Event):void { _ref = e.target.value; });\n            setupControlPanel(0, \"PARAMETERS\");\n            cb = new ComboBox(this, 246, 8, shapes[_meshAShape], shapes);\n            cb.numVisibleItems = shapes.length;\n            cb.selectedIndex = _meshAShape;\n            cb.addEventListener(Event.SELECT, function(e:Event):void{ _meshAShape = e.target.selectedIndex; updateMesh(_meshA, _meshAShape, _meshASize); });\n            cb = new ComboBox(this, 358, 8, shapes[_meshBShape], shapes);\n            cb.numVisibleItems = shapes.length;\n            cb.selectedIndex = _meshBShape;\n            cb.addEventListener(Event.SELECT, function(e:Event):void{ _meshBShape = e.target.selectedIndex; updateMesh(_meshB, _meshBShape, _meshBSize); });\n            new PushButton(this, 8,   8, \"MESH A\", function(e:Event):void {_boolMode = 0;});\n            new PushButton(this, 8,  28, \"MESH B\", function(e:Event):void {_boolMode = 1;});\n            new PushButton(this, 8,  48, \"A+B\", function(e:Event):void {_boolMode = 2;});\n            new PushButton(this, 8,  68, \"A*B\", function(e:Event):void {_boolMode = 3;});\n            new PushButton(this, 8,  88, \"A-B\", function(e:Event):void {_boolMode = 4;});\n            new PushButton(this, 8, 108, \"B-A\", function(e:Event):void {_boolMode = 5;});\n        }\n        private function setupControlPanel(tabIndex:int, label:String) : void {\n            _ctrl.x = 8; _ctrl.y = 465;\n            _ctrl.graphics.beginFill(0, 0.75);\n            _ctrl.graphics.drawRect(0, 0, _w, _h);\n            _ctrl.graphics.endFill();\n            new PushButton(_ctrl, tabIndex*90, -18, label, function(e:Event):void {\n                var ctrl:DisplayObjectContainer = e.target.parent;\n                ctrl.parent.addChild(ctrl);\n                BetweenAS3.to(ctrl, {y:476-ctrl.height}, 0.5, Sine.easeOut).play();\n                _mouseCapture.visible = true;\n                _mouseCapture.addEventListener(MouseEvent.CLICK, function(e:Event):void{\n                    _mouseCapture.visible = false;\n                    _mouseCapture.removeEventListener(MouseEvent.CLICK, arguments.callee);\n                    BetweenAS3.to(ctrl, {y:465}, 0.5, Sine.easeOut).play();\n                });\n            }).setSize(90, 18);\n        }\n        private function newSlider(label:String, min:Number, max:Number, val:Number, tick:Number, prec:int, func:Function) : void {\n            var slider:HUISlider = new HUISlider(_ctrl, 4, _h, label, func);\n            slider.setSliderParams(min, max, val); slider.tick = tick; slider.labelPrecision = prec;\n            _h += 20; slider.width = _w;\n        }\n        private var _ctrl:Sprite, _h:Number, _w:Number, _mouseCapture:Sprite;\n        \n        \n        private function updateMesh(mesh:Mesh, shape:int, size:Number) : void {\n            mesh.dispose();\n            switch(shape) {\n            case 0:  SolidFactory.sphere(mesh, size, 2).updateFaceNormal(true);  break;\n            case 1:  SolidFactory.tetrahedron(mesh, size).updateFaceNormal(true); break;\n            case 2:  SolidFactory.hexahedron(mesh, size).updateFaceNormal(true); break; \n            case 3:  SolidFactory.octahedron(mesh, size).updateFaceNormal(true); break;\n            case 4:  SolidFactory.dodecahedron(mesh, size).updateFaceNormal(true); break;\n            case 5:  SolidFactory.icosahedron(mesh, size).updateFaceNormal(true); break;\n            case 6:  SolidFactory.sphere(mesh, size, 2, false).updateFaceNormal(true); break;\n            case 7:  SolidFactory.pillar(mesh,  5, size*0.5,  320, 1, false).updateFaceNormal(true); break;\n            case 8:  SolidFactory.pillar(mesh, 32, size*0.5,  320, 1,  true).updateFaceNormal(true); break;\n            case 9:  SolidFactory.pillar(mesh, 32, size*0.5,    0, 1,  true, size, 0).updateFaceNormal(true); break;\n            case 10: SolidFactory.pillar(mesh,  8, size*0.5, size, 1, false, size*0.5, size*0.5).updateFaceNormal(true); break;\n            }\n        }\n        \n        \n        private function draw(e:Event) : void {\n            var context3D:Context3D = ptolemy.context3D,\n                sigl:SiGLCore = ptolemy.sigl, \n                t:Number = (_startTime - getTimer()) * 0.00314,\n                op:BooleanOperation = _boolOperations[_boolMode];\n            \n            // upload\n            if (_meshA.vertexBuffer == null) _meshA.allocateBuffer(context3D).upload();\n            if (_meshB.vertexBuffer == null) _meshB.allocateBuffer(context3D).upload();\n\n            // global motion\n            // lighting vector\n            _light.setTo(mouseX-233, 233-mouseY, 300);\n            _meshAMatrix.identity();\n            _meshAMatrix.prependRotationXYZ(t*0.1, t*0.06, 0);\n            _meshBMatrix.identity();\n            _meshBMatrix.prependRotationXYZ(0, t*0.3, t*0.05);\n            _meshBMatrix.prependTranslation(-60, 0, 0);\n            \n            // drawing\n            context3D.clear();\n            context3D.setProgramConstantsFromVector(\"fragment\", 4, Vector.<Number>([_ref,1-_ref,0,0]));\n            context3D.setStencilReferenceValue(0);\n            // background\n            sigl.id();\n            context3D.setProgram(programs[2]);\n            context3D.setTextureAt(0, _backTex);\n            context3D.setTextureAt(1, null);\n            context3D.setCulling(\"none\");\n            context3D.setDepthTest(false, \"always\");\n            context3D.setStencilActions(\"frontAndBack\", \"always\");\n            context3D.setProgramConstantsFromMatrix(\"vertex\", 0, sigl.modelViewProjectionMatrix, true);\n            _back.drawTriangles(context3D);\n            // CSG \n            switch (_boolMode) {\n            case 2:\n                drawMesh(_meshA, _meshAMatrix, _materialA, \"back\", \"always\");\n                drawMesh(_meshB, _meshBMatrix, _materialB, \"back\", \"always\");\n                break;\n            case 4:\n                drawCSG(_meshB, _meshBMatrix, _meshA, _meshAMatrix, _materialB, op.surfB, op.stencilB);\n                drawCSG(_meshA, _meshAMatrix, _meshB, _meshBMatrix, _materialA, op.surfA, op.stencilA);\n                break;\n            default:\n                drawCSG(_meshA, _meshAMatrix, _meshB, _meshBMatrix, _materialA, op.surfA, op.stencilA);\n                drawCSG(_meshB, _meshBMatrix, _meshA, _meshAMatrix, _materialB, op.surfB, op.stencilB);\n                break;\n            }\n\n            //if(!_s){_s=new BitmapData(450,450,false,0);with(addChildAt(new Bitmap(_s),0)){x=y=8;}}context3D.drawToBitmapData(_s);\n            context3D.present();\n        }\n        private var _s:BitmapData = null;\n        \n        private function drawCSG(meshA:Mesh, meshAMatrix:Matrix3D, meshB:Mesh, meshBMatrix:Matrix3D, materialA:FlatShadingMaterial, cullingA:String, stencilOpA:String) : void {\n            var context3D:Context3D = ptolemy.context3D, sigl:SiGLCore = ptolemy.sigl; \n            \n            context3D.clear(0,0,0,1,1,0,Context3DClearMask.DEPTH|Context3DClearMask.STENCIL);\n            context3D.setProgram(programs[1]);\n            context3D.setTextureAt(0, null);\n            context3D.setTextureAt(1, null);\n            context3D.setColorMask(false, false, false, false);\n            sigl.push().m(meshAMatrix);\n            context3D.setCulling(cullingA);\n            context3D.setDepthTest(true, \"less\");\n            context3D.setStencilActions(\"frontAndBack\", \"always\");\n            context3D.setProgramConstantsFromMatrix(\"vertex\", 0, sigl.modelViewProjectionMatrix, true);\n            meshA.drawTriangles(context3D);\n            sigl.rem().m(meshBMatrix);\n            context3D.setCulling(\"none\");\n            context3D.setDepthTest(false, \"less\");\n            context3D.setStencilActions(\"front\", \"always\", \"incrementWrap\");\n            context3D.setStencilActions(\"back\", \"always\", \"decrementWrap\");\n            context3D.setProgramConstantsFromMatrix(\"vertex\",   0, sigl.modelViewProjectionMatrix, true);\n            meshB.drawTriangles(context3D);\n            sigl.pop();\n            \n            context3D.clear(0,0,0,1,1,0,Context3DClearMask.DEPTH);\n            drawMesh(meshA, meshAMatrix, materialA, cullingA, stencilOpA);\n        }\n\n        private function drawMesh(mesh:Mesh, matrix:Matrix3D, material:FlatShadingMaterial, culling:String, stencilOp:String) : void {\n            var context3D:Context3D = ptolemy.context3D, sigl:SiGLCore = ptolemy.sigl; \n            \n            context3D.setProgram(programs[0]);\n            context3D.setTextureAt(0, _specTex);\n            context3D.setTextureAt(1, _cubeTex);\n            context3D.setColorMask(true, true, true, true);\n            context3D.setStencilActions(\"frontAndBack\", stencilOp);\n            sigl.push().m(matrix);\n            _light.transform(sigl);\n            context3D.setCulling(culling);\n            context3D.setDepthTest(true, \"less\");\n            context3D.setProgramConstantsFromMatrix(\"vertex\",   0, sigl.modelViewProjectionMatrix, true);\n            context3D.setProgramConstantsFromMatrix(\"vertex\",   4, sigl.modelViewMatrix, true);\n            context3D.setProgramConstantsFromVector(\"fragment\", 0, _light.lightVector);\n            context3D.setProgramConstantsFromVector(\"fragment\", 1, _light.halfVector);\n            context3D.setProgramConstantsFromVector(\"fragment\", 2, material.ambientVector);\n            context3D.setProgramConstantsFromVector(\"fragment\", 3, material.diffuseDifVector);\n            \n            mesh.drawTriangles(context3D);\n            sigl.pop();\n        }\n    }\n}\n\n\nvar vs0:String = <agal><![CDATA[\nm44 op, va0, vc0\nmov v0, va1\n\nsub vt0, va0, vc3\nnrm vt0.xyz, vt0\ndp3 vt1.x, vt0, va1\n\nmul vt2.x, vt1.x, vc126.y\nmul vt2, va1, vt2.x\nadd vt2, vt2, vt0\nm33 vt2.xyz, vt2, vc4\nabs vt2.z, vt2.z\nmov v1, vt2\n\nmul vt2.x, vt1.x, vc126.x\nmul vt2, va1, vt2.x\nadd vt2, vt2, vt0\nm33 vt2.xyz, vt2, vc4\nabs vt2.z, vt2.z\nneg vt2.z, vt2.z\nmov v2, vt2\n\ndp3 v3.z, va1, vc6\nmov v3.xyw, vc127.xxx\n]]></agal>;\nvar fs0:String = <agal><![CDATA[\ndp3 ft0.x, v0, fc0\nabs ft0.x, ft0.x\nsat ft0.x, ft0.x\nmul ft0, fc3, ft0.x\nadd ft0, ft0, fc2\ndp3 ft1.x, v0, fc1\nabs ft1.x, ft1.x\ntex ft3, ft1.xx, fs0 <2d,clamp,nearest>\ntex ft4, v1.xyz, fs1 <cube,linear,mipnearest>\ntex ft2, v2.xyz, fs1 <cube,linear,mipnearest>\nmul ft0, ft0, ft2\n\nabs ft1.z, v3.z\nsub ft1.z, fc27.z, ft1.z\nmul ft1.z, ft1.z, ft1.z\nmul ft1.z, ft1.z, ft1.z\n\nmul ft1.x, fc4.y, ft1.z\nadd ft1.x, ft1.x, fc4.x\nsub ft1.y, fc27.z, ft1.x\n\nmul ft4, ft4, ft1.x\nmul ft0, ft0, ft1.y\nadd ft0, ft0, ft4\nadd oc, ft0, ft3\n]]></agal>;\n/* frsnel\nF = F0 + (1-F0)(1-cos)^5\n*/\n\nvar vs1:String = <agal><![CDATA[\nm44 op, va0, vc0\nmov vt0, va1\n]]></agal>;\nvar fs1:String = <agal><![CDATA[\nmov oc, fc27.zzz\n]]></agal>;\n\nvar vs2:String = <agal><![CDATA[\nm44 op, va0, vc0\nmov v0, va1\n]]></agal>;\nvar fs2:String = <agal><![CDATA[\ntex oc, v0.xy, fs0 <2d,clamp,nearest>\n]]></agal>;\n\nvar shaders:Array = [{\"vs\":vs0,\"fs\":fs0}, {\"vs\":vs1,\"fs\":fs1}, {\"vs\":vs2,\"fs\":fs2}];\n\n\nclass BooleanOperation {\n    public var name:String, surfA:String, surfB:String, stencilA:String, stencilB:String; \n    function BooleanOperation(name:String, surfA:String, surfB:String, stencilA:String, stencilB:String) {\n        this.surfA=surfA; this.surfB=surfB; this.stencilA=stencilA; this.stencilB=stencilB;\n    }\n}\n\n\nimport flash.display.*;\nimport flash.geom.*;\nimport flash.display3D.*;\nimport flash.display3D.textures.*;\nfunction createCubeTexture(context3D:Context3D, bitmap:BitmapData) : CubeTexture {\n    var size:int = bitmap.width / 3, tex:CubeTexture = context3D.createCubeTexture(size, \"bgra\", false), \n        src:BitmapData, bmp:BitmapData, mat:Matrix = new Matrix(), i:int, mm:int, s:int, scl:Number, rot:Array=[-1,1,2,0,0,0];\n    for (i=0; i<6; i++) {\n        src = new BitmapData(size, size, false);\n        src.copyPixels(bitmap, new Rectangle((i%3)*size, (int(i/3))*size, size, size), new Point(0, 0));\n        for (mm=0, s=size; s!=0; mm++, s>>=1) {\n            scl = s / size;\n            mat.identity();\n            mat.translate(size*-0.5,size*-0.5);\n            mat.rotate(rot[i]*Math.PI*0.5);\n            mat.translate(size*0.5,size*0.5);\n            mat.scale(scl, scl);\n            bmp = new BitmapData(s, s, false);\n            bmp.draw(src, mat, null, null, null, true);\n            tex.uploadFromBitmapData(bmp, i, mm);\n            bmp.dispose();\n        }\n    }\n    return tex;\n}\n\n\n\n{\n    /**  Solid Mesh Factory class. */\n    class SolidFactory {\n        /* tetrahedron */\n        static public function tetrahedron(mesh:Mesh, size:Number=1) : Mesh {\n            var s:Number = size * 0.5;\n            _begin(mesh);\n            _f3(); _tv.push( s, s, s, -s, s,-s,  s,-s,-s);\n            _f3(); _tv.push( s,-s,-s, -s, s,-s, -s,-s, s);\n            _f3(); _tv.push( s,-s,-s, -s,-s, s,  s, s, s);\n            _f3(); _tv.push( s, s, s, -s,-s, s, -s, s,-s);\n            return _end();\n        }\n        \n        \n        /** hexahedron */\n        static public function hexahedron(mesh:Mesh, size:Number=1) : Mesh {\n            var s:Number = size * 0.5;\n            _begin(mesh);\n            _f4(); _tv.push(-s,-s,-s,  s,-s,-s, -s, s,-s,  s, s,-s);\n            _f4(); _tv.push(-s,-s,-s, -s, s,-s, -s,-s, s, -s, s, s);\n            _f4(); _tv.push( s,-s,-s, -s,-s,-s,  s,-s, s, -s,-s, s);\n            _f4(); _tv.push(-s, s,-s,  s, s,-s, -s, s, s,  s, s, s);\n            _f4(); _tv.push( s, s,-s,  s,-s,-s,  s, s, s,  s,-s, s);\n            _f4(); _tv.push( s,-s, s, -s,-s, s,  s, s, s, -s, s, s);\n            return _end();\n        }\n        \n        \n        /** octahedron */\n        static public function octahedron(mesh:Mesh, size:Number=1) : Mesh {\n            var s:Number = size * 0.5;\n            _begin(mesh);\n            _f3(); _tv.push(0,0,-s,  -s,0,0,  0,-s,0);\n            _f3(); _tv.push(0,0,-s,  0,-s,0,  s,0,0);\n            _f3(); _tv.push(0,0,-s,   s,0,0,  0,s,0);\n            _f3(); _tv.push(0,0,-s,   0,s,0,  -s,0,0);\n            _f3(); _tv.push(0,-s,0,  -s,0,0,  0,0,s);\n            _f3(); _tv.push(s,0,0,   0,-s,0,  0,0,s);\n            _f3(); _tv.push(0,s,0,    s,0,0,  0,0,s);\n            _f3(); _tv.push(-s,0,0,   0,s,0,  0,0,s);\n            return _end();\n        }\n        \n        \n        /** dodecahedron */\n        static public function dodecahedron(mesh:Mesh, size:Number=1) : Mesh {\n            var s:Number = size * 0.5,\n                a:Number = s*0.149071198, b:Number = s*0.241202266, c:Number = s*0.283550269, \n                d:Number = s*0.390273464, e:Number = s*0.458793973, f:Number = s*0.631475730, \n                g:Number = s*0.742344243;\n            _begin(mesh);\n            _v3d(c,f,d);    _v3d(e,f,-a); _v3d(0,f,-b-b); _v3d(-e,f,-a);  _v3d(-c,f,d);\n            _v3d(e,a,f);    _v3d(g,a,-b); _v3d(0,a,-d-d); _v3d(-g,a,-b);  _v3d(-e,a,f);\n            _v3d(0,-a,d+d); _v3d(g,-a,b); _v3d(e,-a,-f);  _v3d(-e,-a,-f); _v3d(-g,-a,b);\n            _v3d(0,-f,b+b); _v3d(e,-f,a); _v3d(c,-f,-d);  _v3d(-c,-f,-d); _v3d(-e,-f,a);\n            _f5(0,3,1,2,4); _f5(4,5,9,10,0); _f5(0,6,5,11,1);\n            _f5(1,7,6,12,2); _f5(2,8,7,13,3); _f5(3,9,8,14,4);\n            _f5(17,11,12,6,16); _f5(16,10,11,5,15); _f5(15,14,10,9,19);\n            _f5(19,13,14,8,18); _f5(18,12,13,7,17); _f5(16,18,15,19,17);\n            return _end();\n        }\n        \n        \n        /** icosahedron */\n        static public function icosahedron(mesh:Mesh, size:Number=1) : Mesh {\n            var s:Number = size * 0.5,\n                a:Number = s*0.276393202, b:Number = s*0.447213595, c:Number = s*0.525731112, \n                d:Number = s*0.723606798, e:Number = s*0.850650808;\n            _begin(mesh);\n            _f3(); _tv.push(0,s,0, e,b,a, 0,b,b+b);  _f3(); _tv.push(0,b,b+b, e,b,a, c,-b,d);\n            _f3(); _tv.push(0,s,0, c,b,-d, e,b,a);   _f3(); _tv.push(e,b,a, c,b,-d, e,-b,-a);\n            _f3(); _tv.push(0,s,0, -c,b,-d, c,b,-d); _f3(); _tv.push(c,b,-d, -c,b,-d, 0,-b,-b-b);\n            _f3(); _tv.push(0,s,0, -e,b,a, -c,b,-d); _f3(); _tv.push(-c,b,-d, -e,b,a, -e,-b,-a);\n            _f3(); _tv.push(0,s,0, 0,b,b+b, -e,b,a); _f3(); _tv.push(-e,b,a, 0,b,b+b, -c,-b,d);\n            _f3(); _tv.push(0,b,b+b, c,-b,d, -c,-b,d);     _f3(); _tv.push(-c,-b,d, c,-b,d, 0,-s,0);\n            _f3(); _tv.push(e,b,a, e,-b,-a, c,-b,d);       _f3(); _tv.push(c,-b,d, e,-b,-a, 0,-s,0);\n            _f3(); _tv.push(c,b,-d, 0,-b,-b-b, e,-b,-a);   _f3(); _tv.push(e,-b,-a, 0,-b,-b-b, 0,-s,0);\n            _f3(); _tv.push(-c,b,-d, -e,-b,-a, 0,-b,-b-b); _f3(); _tv.push(0,-b,-b-b, -e,-b,-a, 0,-s,0);\n            _f3(); _tv.push(-e,b,a, -c,-b,d, -e,-b,-a);    _f3(); _tv.push(-e,-b,-a, -c,-b,d, 0,-s,0);\n            return _end();\n        }\n        \n        \n        /** Geodesic dome sphere */\n        static public function sphere(mesh:Mesh, size:Number=1, precision:int=1, shareVertex:Boolean=true) : Mesh {\n            var s:Number=size*0.5, i:int, imax:int, istep:int, v:Vector3D=new Vector3D();\n            if (shareVertex) {\n                var a:Number=0.276393202, b:Number=0.447213595, c:Number=0.525731112, d:Number=0.723606798, e:Number=0.850650808\n                mesh.clear(); mesh.vertexCount=0;\n                _tv.length = 0;\n                _tv.push(0,1,0, 0,b,b+b, e,b,a, c,b,-d, -c,b,-d, -e,b,a);\n                _tv.push(e,-b,-a, c,-b,d, -c,-b,d, -e,-b,-a, 0,-b,-b-b, 0,-1,0);\n                mesh.qface(0,2,1,7).qface(0,3,2,6).qface(0,4,3,10).qface(0,5,4,9).qface(0,1,5,8);\n                mesh.qface(1,7,8,11).qface(2,6,7,11).qface(3,10,6,11).qface(4,9,10,11).qface(5,8,9,11);\n                mesh.updateBuffer(Mesh.vertexAttributeName, _tv);\n            } else {\n                icosahedron(mesh, 1);\n            }\n            mesh.divideFaces(precision, shareVertex);\n            i = mesh.attributes[Mesh.vertexAttributeName].offset;\n            imax = mesh.vertices.length;\n            istep = mesh.data32PerVertex;\n            for (i=0; i<imax; i+=istep) {\n                v.setTo(mesh.vertices[i], mesh.vertices[i+1], mesh.vertices[i+2]);\n                v.normalize();\n                mesh.vertices[i]   = v.x * s;\n                mesh.vertices[i+1] = v.y * s;\n                mesh.vertices[i+2] = v.z * s;\n            } \n            return mesh;\n        }\n        \n        \n        /** pillar */\n        static public function pillar(mesh:Mesh, faceCount:int, radius:Number=1, height:Number=1, ratio:Number=1, shareVertex:Boolean=true, capConeHeightPosi:Number=0, capConeHeightNega:Number=0) : Mesh {\n            var i:int, d:Number, a:Number, i0:int, i1:int, ioff:int, imax:int;\n            mesh.clear(); mesh.vertexCount=0;\n            _tv.length = faceCount * 3 * 2;\n            for (i=0, i0=0, i1=faceCount*3, a=0, d=6.283185307179586/faceCount; i<faceCount; i++, a-=d) {\n                _tv[i0] =  (_tv[i1] = Math.cos(a) * radius) * ratio; i0++; i1++;\n                _tv[i0] =  (_tv[i1] = Math.sin(a) * radius) * ratio; i0++; i1++;\n                _tv[i0] = -(_tv[i1] = -height * 0.5); i0++; i1++;\n            }\n            if (shareVertex) {\n                for (i=1, imax=faceCount; i<imax; i++) mesh.qface(i,i-1,i+imax,i+imax-1);\n                mesh.qface(0,imax-1,imax,imax*2-1);\n            } else {\n                _tv.length += (imax = _tv.length);\n                for (i0=0, i1=imax; i0<imax; i0++, i1++) _tv[i1] = _tv[i0];\n                i0 = faceCount * 2;\n                for (i=1, imax=faceCount; i<imax; i++) mesh.qface(i,i0+i-1,i+imax,i0+i+imax-1);\n                mesh.qface(0,i0+imax-1,imax,i0+imax*2-1);\n            }\n            if (ratio>0 && !isNaN(capConeHeightPosi)) {\n                ioff = (i1 = _tv.length) / 3;\n                if (shareVertex) {\n                    _tv.length += (imax = faceCount * 3) + 3;\n                    _tv[i1++] = 0; _tv[i1++] = 0; _tv[i1++] = height * 0.5 + capConeHeightPosi;\n                    for (i=0; i<imax; i++, i1++) _tv[i1] = _tv[i];\n                    for (i=1, imax=faceCount; i<imax; i++) mesh.face(ioff,ioff+i,ioff+i+1);\n                    mesh.face(ioff,ioff+imax,ioff+1);\n                } else {\n                    _tv.length += (imax = faceCount * 3) * 2 + 3;\n                    _tv[i1++] = 0; _tv[i1++] = 0; _tv[i1++] = height * 0.5 + capConeHeightPosi;\n                    for (i=0, i0=i1+imax; i<imax; i++, i0++, i1++) _tv[i1] = _tv[i0] = _tv[i];\n                    for (i=1, imax=faceCount; i<imax; i++) mesh.face(ioff,ioff+i,ioff+imax+i+1);\n                    mesh.face(ioff,ioff+imax,ioff+1);\n                }\n            }\n            if (!isNaN(capConeHeightNega)) {\n                ioff = (i1 = _tv.length) / 3;\n                if (shareVertex) {\n                    _tv.length += (imax = faceCount * 3) + 3;\n                    _tv[i1++] = 0; _tv[i1++] = 0; _tv[i1++] = -height * 0.5 - capConeHeightNega;\n                    for (i=0; i<imax; i++, i1++) _tv[i1] = _tv[i+imax];\n                    for (i=1, imax=faceCount; i<imax; i++) mesh.face(ioff,ioff+i+1,ioff+i);\n                    mesh.face(ioff,ioff+1,ioff+imax);\n                } else {\n                    _tv.length += (imax = faceCount * 3) * 2 + 3;\n                    _tv[i1++] = 0; _tv[i1++] = 0; _tv[i1++] = -height * 0.5 - capConeHeightNega;\n                    for (i=0, i0=i1+imax; i<imax; i++, i0++, i1++) _tv[i1] = _tv[i0] = _tv[i+imax];\n                    for (i=1, imax=faceCount; i<imax; i++) mesh.face(ioff,ioff+imax+i+1,ioff+i);\n                    mesh.face(ioff,ioff+imax+1,ioff+imax);\n                }\n            }\n            return mesh.updateBuffer(Mesh.vertexAttributeName, _tv);\n        }\n        \n        \n        static public function plane(mesh:Mesh, width:Number, height:Number, z:Number=0) : Mesh {\n            _tv.length = 0;\n            _tv.push(-width*0.5,-height*0.5,z, width*0.5,-height*0.5,z, -width*0.5,height*0.5,z, width*0.5,height*0.5,z);\n            mesh.qface(0,1,2,3);\n            return mesh.updateBuffer(Mesh.vertexAttributeName, _tv);\n        }\n        \n        \n        \n        \n    // internal functions\n    //--------------------------------------------------\n        static private var _tv:Vector.<Number> = new Vector.<Number>(), _tv3d:Vector.<Vector3D> = new Vector.<Vector3D>(), _ii:int, _mesh:Mesh;\n        static private function _v3d(x:Number, y:Number, z:Number) : void { _tv3d.push(new Vector3D(x, y, z)); }\n        static private function _begin(mesh:Mesh) : void { _mesh = mesh; mesh.clear(); mesh.vertexCount=0; _ii = 0; _tv.length = 0; _tv3d.length = 0; }\n        static private function _f3() : void { _mesh.face(_ii++, _ii++, _ii++); }\n        static private function _f4() : void { _mesh.qface(_ii++, _ii++, _ii++, _ii++); }\n        static private function _end() : Mesh { return _mesh.updateBuffer(Mesh.vertexAttributeName, _tv); }\n        static private function _f5(i0:int, i1:int, i2:int, i3:int, i4:int) : void {\n            _mesh.qface(_ii++, _ii++, _ii++, _ii++).face(_ii-3, _ii-4, _ii++);\n            _tv.push(_tv3d[i0].x, _tv3d[i0].y, _tv3d[i0].z);\n            _tv.push(_tv3d[i1].x, _tv3d[i1].y, _tv3d[i1].z);\n            _tv.push(_tv3d[i2].x, _tv3d[i2].y, _tv3d[i2].z);\n            _tv.push(_tv3d[i3].x, _tv3d[i3].y, _tv3d[i3].z);\n            _tv.push(_tv3d[i4].x, _tv3d[i4].y, _tv3d[i4].z);\n        }\n    }\n}\n\n\n\n\n\n\n\n/* Tiny Ptolemy */ {\n    import flash.net.*;\n    import flash.geom.*;\n    import flash.events.*;\n    import flash.system.*;\n    import flash.display.*;\n    import flash.display3D.*;\n    import com.adobe.utils.*;\n\n\n    /** Operation Center */\n    class Ptolemy extends EventDispatcher {\n    // variables ----------------------------------------\n        public var context3D:Context3D;\n        public var sigl:SiGLCore;\n        public var resources:* = {};\n\n        private var _loadedResourceCount:int;\n    // constructor ----------------------------------------\n        function Ptolemy(parent:DisplayObjectContainer, xpos:Number, ypos:Number ,width:int, height:int) : void {\n            var stage:Stage = parent.stage, stage3D:Stage3D = stage.stage3Ds[0];\n            stage.scaleMode = StageScaleMode.NO_SCALE;\n            stage.align = StageAlign.TOP_LEFT;\n            stage.quality = StageQuality.LOW;\n            stage3D.x = xpos; stage3D.y = ypos;\n            sigl = new SiGLCore(width, height);\n            stage3D.addEventListener(Event.CONTEXT3D_CREATE, function(e:Event):void{\n                context3D = e.target.context3D;\n                if (context3D) {\n                    context3D.enableErrorChecking = true;                   // check internal error\n                    context3D.configureBackBuffer(width, height, 0, true);  // disable AA/ enable depth/stencil\n                    context3D.setBlendFactors(Context3DBlendFactor.SOURCE_ALPHA, Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA);\n                    context3D.setCulling(Context3DTriangleFace.BACK);       // culling back face\n                    context3D.setRenderToBackBuffer();\n                    dispatchEvent(e.clone());\n                    if (--_loadedResourceCount == 0) dispatchEvent(new Event(Event.COMPLETE));\n                } else dispatchEvent(new ErrorEvent(ErrorEvent.ERROR, false, false, \"Context3D not found\"));\n            });\n            stage3D.requestContext3D();\n            _loadedResourceCount = 1;\n        }\n    // load resource ----------------------------------------\n        public function load(urlRequest:URLRequest, id:String=null, type:String=null, checkPolicyFile:Boolean=false) : EventDispatcher {\n            var loader:Loader, urlLoader:URLLoader;\n            _loadedResourceCount++;\n            if (type == \"img\") {\n                loader = new Loader();\n                loader.load(urlRequest, new LoaderContext(checkPolicyFile));\n                loader.contentLoaderInfo.addEventListener(Event.COMPLETE, function(e:Event) : void {\n                    resources[id] = e.target.content;\n                    if (--_loadedResourceCount == 0) dispatchEvent(new Event(Event.COMPLETE));\n                });\n                return loader;\n            }\n            urlLoader = new URLLoader(urlRequest);\n            urlLoader.dataFormat = (type == \"txt\") ? URLLoaderDataFormat.TEXT : URLLoaderDataFormat.BINARY;\n            urlLoader.addEventListener(Event.COMPLETE, function(e:Event) : void {\n                resources[id] = e.target.data;\n                if (--_loadedResourceCount == 0) dispatchEvent(new Event(Event.COMPLETE));\n            });\n            return urlLoader;\n        }\n    }\n    \n\n    /** SiGLCore provides basic matrix operations. */\n    class SiGLCore {\n    // variables ----------------------------------------\n        public var modelViewMatrix:SiGLMatrix = new SiGLMatrix(), projectionMatrix:SiGLMatrix = new SiGLMatrix();\n        public var viewWidth:Number, viewHeight:Number, pointSpriteFieldScale:Point = new Point();\n        public var defaultCameraMatrix:SiGLMatrix = new SiGLMatrix(), matrix:SiGLMatrix = modelViewMatrix;\n        private var _mvpMatrix:Matrix3D = new Matrix3D(), _mvpdir:Boolean, _2d:Number, _2r:Number;\n        private var _mag:Number, _zNear:Number, _zFar:Number, _fieldOfView:Number, _alignTopLeft:Boolean = false;\n    // properties ----------------------------------------\n        public function get modelViewProjectionMatrix() : Matrix3D {\n            if (_mvpdir) {\n                _mvpMatrix.copyFrom(projectionMatrix);\n                _mvpMatrix.prepend(modelViewMatrix);\n                _mvpdir = false;\n            }\n            return _mvpMatrix;\n        }\n        public function get align() : String { return (_alignTopLeft) ? \"topLeft\" : \"center\"; }\n        public function set align(mode:String) : void { _alignTopLeft = (mode == \"topLeft\"); _updateProjectionMatrix(); }\n        public function get matrixMode() : String { return (matrix === projectionMatrix) ? \"projection\" : \"modelView\"; }\n        public function set matrixMode(mode:String) : void { matrix = (mode == \"projection\") ? projectionMatrix : modelViewMatrix; }\n        public function get angleMode() : String { return (_2r == 1) ? \"radian\" : \"degree\"; }\n        public function set angleMode(mode:String) : void { _2d = (mode == \"radian\") ? 57.29577951308232 : 1; _2r = (mode == \"radian\") ? 1 : 0.017453292519943295; }\n        public function get fieldOfView() : Number { return _fieldOfView / _2r; }\n        public function set fieldOfView(fov:Number) : void { _fieldOfView = fov * _2r; _updateProjectionMatrix(); }\n        public function get magnification() : Number { return _mag; }\n        public function set magnification(mag:Number) : void { _mag = mag; _updateProjectionMatrix(); }\n    // constructor ----------------------------------------\n        function SiGLCore(width:Number=1, height:Number=1) {\n            viewWidth = width; viewHeight = height;\n            angleMode = \"degree\"; _mag = 1;\n            _zNear = -1000; _zFar = 200;\n            modelViewMatrix.identity();\n            _mvpdir = true;\n            this.fieldOfView = 60;\n        }\n    // matrix operations ----------------------------------------\n        public function forceUpdateMatrix() : SiGLCore { _mvpdir = true; return this; }\n        public function setZRange(zNear:Number=-100, zFar:Number=100) : SiGLCore { _zNear = zNear; _zFar = zFar; _updateProjectionMatrix(); return this; }\n        public function clear() : SiGLCore { matrix.clear(); _mvpdir = true; return this; }\n        public function id() : SiGLCore { matrix.id(); _mvpdir = true; return this; }\n        public function push() : SiGLCore { matrix.push(); return this; }\n        public function pop() : SiGLCore { matrix.pop(); _mvpdir = true; return this; }\n        public function rem() : SiGLCore { matrix.rem(); _mvpdir = true; return this; }\n        public function r(a:Number, axis:Vector3D, pivot:Vector3D = null) : SiGLCore { matrix.prependRotation(a*_2d, axis, pivot); matrix._invdir = _mvpdir = true; return this; }\n        public function s(x:Number, y:Number, z:Number=1) : SiGLCore { matrix.prependScale(x, y, z); matrix._invdir = _mvpdir = true; return this; }\n        public function t(x:Number, y:Number, z:Number=0) : SiGLCore { matrix.prependTranslation(x, y, z); matrix._invdir = _mvpdir = true; return this; }\n        public function m(mat:Matrix3D) : SiGLCore { matrix.prepend(mat); matrix._invdir = _mvpdir = true; return this; }\n        public function re(x:Number, y:Number, z:Number) : SiGLCore { matrix.prependRotationXYZ(x*_2r, y*_2r, z*_2r); _mvpdir = true; return this; }\n        public function setCameraMatrix(mat:Matrix3D=null) : SiGLCore { projectionMatrix.rem().prepend(mat || defaultCameraMatrix); _mvpdir = true; return this; }\n        private function _updateProjectionMatrix() : void {\n            var wh:Number = viewWidth / viewHeight, rev:Number = (_alignTopLeft)?-1:1,\n                fl:Number = (viewHeight * 0.5) / Math.tan(_fieldOfView * 0.5);\n            if (_zNear <= -fl) _zNear = -fl + 0.001;\n            projectionMatrix.clear().perspectiveFieldOfView(_fieldOfView, wh, _zNear+fl, _zFar+fl, -1);\n            pointSpriteFieldScale.setTo(projectionMatrix.rawData[0] * fl, projectionMatrix.rawData[5] * fl);\n            projectionMatrix.push();\n            defaultCameraMatrix.identity();\n            defaultCameraMatrix.prependTranslation(0, 0, -fl);\n            if (_alignTopLeft) defaultCameraMatrix.prependTranslation(viewWidth* 0.5, -viewHeight * 0.5, 0);\n            defaultCameraMatrix.prependScale(_mag, _mag * rev, _mag * rev);\n            setCameraMatrix();\n        }\n    }\n    \n\n    /** SiGLMatrix is extention of Matrix3D with push/pop operation */\n    class SiGLMatrix extends Matrix3D {\n        internal var _invdir:Boolean = false, _inv:Matrix3D = new Matrix3D(), _stac:Vector.<Matrix3D> = new Vector.<Matrix3D>();\n        static private var _tv:Vector.<Number> = new Vector.<Number>(16, true), _tm:Matrix3D = new Matrix3D();\n        static private var _in:Vector.<Number> = new Vector.<Number>(4, true), _out:Vector.<Number> = new Vector.<Number>(4, true);\n        public function get inverted() : Matrix3D { if (_invdir) { _inv.copyFrom(this); _inv.invert(); _invdir = false; } return _inv; }\n        public function forceUpdateInvertedMatrix() : SiGLMatrix { _invdir=true; return this; }\n        public function clear() : SiGLMatrix { _stac.length=0; return id(); }\n        public function id() : SiGLMatrix { identity(); _inv.identity(); return this; }\n        public function push() : SiGLMatrix { _stac.push(this.clone()); return this; }\n        public function pop() : SiGLMatrix { this.copyFrom(_stac.pop()); _invdir=true; return this; }\n        public function rem() : SiGLMatrix { this.copyFrom(_stac[_stac.length-1]); _invdir=true; return this; }\n        public function prependRotationXYZ(rx:Number, ry:Number, rz:Number) : SiGLMatrix {\n            var sx:Number = Math.sin(rx), sy:Number = Math.sin(ry), sz:Number = Math.sin(rz), \n                cx:Number = Math.cos(rx), cy:Number = Math.cos(ry), cz:Number = Math.cos(rz);\n            _tv[0] = cz*cy; _tv[1] = sz*cy; _tv[2] = -sy; _tv[4] = -sz*cx+cz*sy*sx; _tv[5] = cz*cx+sz*sy*sx;\n            _tv[6] = cy*sx; _tv[8] = sz*sx+cz*sy*cx; _tv[9] = -cz*sx+sz*sy*cx;\n            _tv[10] = cy*cx; _tv[14] = _tv[13] = _tv[12] = _tv[11] = _tv[7] = _tv[3] = 0; _tv[15] = 1;\n            _tm.copyRawDataFrom(_tv); prepend(_tm); _invdir=true;\n            return this;\n        }\n        public function lookAt(cx:Number, cy:Number, cz:Number, tx:Number=0, ty:Number=0, tz:Number=0, ux:Number=0, uy:Number=1, uz:Number=0, w:Number=0) : SiGLMatrix {\n            var dx:Number=tx-cx, dy:Number=ty-cy, dz:Number=tz-cz, dl:Number=-1/Math.sqrt(dx*dx+dy*dy+dz*dz), \n                rx:Number=dy*uz-dz*uy, ry:Number=dz*ux-dx*uz, rz:Number=dx*uy-dy*ux, rl:Number= 1/Math.sqrt(rx*rx+ry*ry+rz*rz);\n            _tv[0]  = (rx*=rl); _tv[4]  = (ry*=rl); _tv[8]  = (rz*=rl); _tv[12] = -(cx*rx+cy*ry+cz*rz) * w;\n            _tv[2]  = (dx*=dl); _tv[6]  = (dy*=dl); _tv[10] = (dz*=dl); _tv[14] = -(cx*dx+cy*dy+cz*dz) * w;\n            _tv[1]  = (ux=dy*rz-dz*ry); _tv[5]  = (uy=dz*rx-dx*rz); _tv[9]  = (uz=dx*ry-dy*rx); _tv[13] = -(cx*ux+cy*uy+cz*uz) * w;\n            _tv[3] = _tv[7] = _tv[11] = 0; _tv[15] = 1; copyRawDataFrom(_tv); _invdir=true;\n            return this;\n        }\n        public function perspectiveFieldOfView(fieldOfViewY:Number, aspectRatio:Number, zNear:Number, zFar:Number, lh:Number=1.0) : void {\n            var yScale:Number = 1.0 / Math.tan(fieldOfViewY * 0.5), xScale:Number = yScale / aspectRatio;\n            this.copyRawDataFrom(Vector.<Number>([xScale,0,0,0,0,yScale,0,0,0,0,zFar/(zFar-zNear)*lh,lh,0,0,(zNear*zFar)/(zNear-zFar),0]));\n        }\n        public function transform(vector:Vector3D) : Vector3D {\n            _in[0] = vector.x; _in[1] = vector.y; _in[2] = vector.z; _in[3] = vector.w;\n            transformVectors(_in, _out); vector.setTo(_out[0], _out[1], _out[2]); vector.w = _out[3];\n            return vector;\n        }\n    }\n    \n    \n    /** Mesh */\n    class Mesh {\n    // constants ----------------------------------------\n        static public const vertexAttributeName:String = \"V\";\n        static public const normalAttributeName:String = \"N\";\n    // variables ----------------------------------------\n        public var vertices:Vector.<Number> = new Vector.<Number>();\n        public var faces:Vector.<Face> = new Vector.<Face>();\n        public var vertexBuffer:VertexBuffer3D, indexBuffer:IndexBuffer3D;\n        public var data32PerVertex:int, attributes:*={}, atl:Array = [];\n        private var _indices:Vector.<uint> = new Vector.<uint>(), _indexDirty:Boolean=true;\n    // properties ----------------------------------------\n        public function get vertexCount() : int { return vertices.length / data32PerVertex; }\n        public function set vertexCount(count:int) : void { vertices.length = count * data32PerVertex; }\n        public function get indices() : Vector.<uint> {\n            var idx:Vector.<uint> = _indices, f:Face, i:int, imax:int, j:int;\n            if (_indexDirty) {\n                idx.length = imax = faces.length * 3;\n                for (i=0,j=0; i<imax; j++) { f=faces[j]; idx[i]=f.i0; i++; idx[i]=f.i1; i++; idx[i]=f.i2; i++; }\n                _indexDirty = false;\n            }\n            return idx;\n        }\n    // contructor ----------------------------------------\n        function Mesh(bufferFormat:String=\"V3\") {\n            var rex:RegExp = /([_a-zA-Z]+)([1234b])/g, res:*, i:int=0;\n            data32PerVertex = 0;\n            while (res = rex.exec(bufferFormat)) {\n                attributes[res[1]] = {size:int(res[2]), offset:data32PerVertex};\n                data32PerVertex += (atl[i++]=int(res[2]));\n            }\n        }\n    // oprations ----------------------------------------\n        public function updateBuffer(attr:String, l:Vector.<Number>, offset:int=0) : Mesh {\n            var vai:* = attributes[attr], size:int = vai.size, il:int, iv:int, i:int, j:int, imax:int=l.length/size+offset;\n            if (vertices.length < imax * data32PerVertex) vertices.length = imax * data32PerVertex;\n            for (il=0, i=offset; i<imax; i++) for (j=0, iv=i*data32PerVertex+vai.offset; j<size; j++, iv++, il++) vertices[iv]=l[il];\n            return this;\n        }\n        public function allocateBuffer(context3D:Context3D) : Mesh {\n            vertexBuffer = context3D.createVertexBuffer(vertexCount, data32PerVertex);\n            indexBuffer  = context3D.createIndexBuffer(indices.length);\n            return this;\n        }\n        public function upload(vertex:Boolean=true, index:Boolean=true) : Mesh {\n            if (vertex) vertexBuffer.uploadFromVector(vertices, 0, vertexCount);\n            if (index) indexBuffer.uploadFromVector(indices, 0, indices.length);\n            return this;\n        }\n        public function dispose() : Mesh {\n            if (vertexBuffer) vertexBuffer.dispose();\n            if (indexBuffer)  indexBuffer.dispose();\n            vertexBuffer = null;\n            indexBuffer = null;\n            return this;\n        }\n        public function drawTriangles(context3D:Context3D) : Mesh {\n            var i:int, o:int=0, f:Array = [\"\",\"float1\",\"float2\",\"float3\",\"float4\"];\n            for (i=0; i<atl.length; o+=atl[i++]) context3D.setVertexBufferAt(i, vertexBuffer, o, f[atl[i]]);\n            context3D.drawTriangles(indexBuffer, 0, faces.length);\n            for (i=0; i<atl.length; i++) context3D.setVertexBufferAt(i, null, 0, \"float1\");\n            return this;\n        }\n        public function clear() : Mesh { for (var i:int=0; i<faces.length; i++) Face.free(faces[i]); faces.length = 0; _indexDirty = true; return this; }\n        public function face(i0:int, i1:int, i2:int) : Mesh { faces.push(Face.alloc(i0, i1, i2)); _indexDirty = true; return this; }\n        public function qface(i0:int, i1:int, i2:int, i3:int) : Mesh { faces.push(Face.alloc(i0, i1, i2), Face.alloc(i3, i2, i1)); _indexDirty = true; return this; }\n        public function flipFaces() : Mesh { for (var i:int=0,j:int; i<faces.length; i++) { j=faces[i].i0; faces[i].i0=faces[i].i1; faces[i].i1=faces[i].i2; faces[i].i2=j; } return this;}\n        public function divideFaces(precision:int=1, shareVertex:Boolean=true) : Mesh {\n            var prec:int, i:int, imax:int, i0:int, i1:int, i2:int, vindex:int = vertexCount, _vhash:*={};\n            for (prec=0; prec<precision; prec++) for (i=0, imax=faces.length; i<imax; i++) {\n                i0 = faces[i].i0; i1 = faces[i].i1; i2 = faces[i].i2;\n                face(i0, _newvtx(i0, i1), _newvtx(i2, i0));\n                face(_newvtx(i0, i1), i1, _newvtx(i1, i2));\n                face(_newvtx(i2, i0), _newvtx(i1, i2), i2);\n                faces[i].i0 = _newvtx(i0, i1); faces[i].i1 = _newvtx(i1, i2); faces[i].i2 = _newvtx(i2, i0);\n            }\n            return this;\n            function _newvtx(i0:int, i1:int) : int {\n                var vkey:uint = (i0<<16) | i1, idx:int;\n                if (vkey in _vhash) return _vhash[vkey];\n                vkey = (i1<<16) | i0; if (vkey in _vhash) return _vhash[vkey];\n                i0 *= data32PerVertex; i1 *= data32PerVertex; idx = vertices.length; vertices.length += data32PerVertex;\n                vertices[idx] = (vertices[i0] + vertices[i1]) * 0.5; idx++; i0++; i1++;\n                vertices[idx] = (vertices[i0] + vertices[i1]) * 0.5; idx++; i0++; i1++;\n                vertices[idx] = (vertices[i0] + vertices[i1]) * 0.5;\n                if (shareVertex) _vhash[vkey] = vindex;\n                return vindex++;\n            }\n        }\n        public function updateFaceNormal(updateVertexNormal:Boolean=true) : Mesh {\n            var vtx:Vector.<Number> = vertices, vcount:int = vertexCount, fcount:int = faces.length, \n                i:int, istep:int, f:Face, iw:Number, fidx:int,  i0:int, i1:int, i2:int, n0:Vector3D, n1:Vector3D, n2:Vector3D, \n                x01:Number, x02:Number, y01:Number, y02:Number, z01:Number, z02:Number;\n            // calculate face normals\n            for (i=0; i<fcount; i++) {\n                f=faces[i];\n                i0=f.i0*data32PerVertex; i1=f.i1*data32PerVertex; i2=f.i2 * data32PerVertex;\n                x01 = vtx[i1]-vtx[i0]; x02 = vtx[i2]-vtx[i0]; i0++; i1++; i2++;\n                y01 = vtx[i1]-vtx[i0]; y02 = vtx[i2]-vtx[i0]; i0++; i1++; i2++;\n                z01 = vtx[i1]-vtx[i0]; z02 = vtx[i2]-vtx[i0];\n                f.normal.setTo(y02*z01-y01*z02, z02*x01-z01*x02, x02*y01-x01*y02);\n                f.normal.normalize();\n            }\n            // calculate vertex normals\n            if (updateVertexNormal) {\n                istep = data32PerVertex - 2;\n                // initialize\n                for (i=0, i0=3; i<vcount; i++, i0+=istep) { vtx[i0]=0; i0++; vtx[i0]=0; i0++; vtx[i0]=0; }\n                // sum up\n                for (i=0; i<fcount; i++) {\n                    f = faces[i];\n                    i0 = f.i0 * data32PerVertex + 3;\n                    vtx[i0]+=f.normal.x; i0++; vtx[i0]+=f.normal.y; i0++; vtx[i0]+=f.normal.z;\n                    i0 = f.i1 * data32PerVertex + 3;\n                    vtx[i0]+=f.normal.x; i0++; vtx[i0]+=f.normal.y; i0++; vtx[i0]+=f.normal.z;\n                    i0 = f.i2 * data32PerVertex + 3;\n                    vtx[i0]+=f.normal.x; i0++; vtx[i0]+=f.normal.y; i0++; vtx[i0]+=f.normal.z;\n                }\n                //* normalize (ussualy normalizing by gpu).\n                for (i=0, i0=3; i<vcount; i++, i0+=istep) {\n                    x01 = vtx[i0]; i0++; y01 = vtx[i0]; i0++; z01 = vtx[i0]; i0-=2;\n                    iw = 1 / Math.sqrt(x01*x01 + y01*y01 + z01*z01);\n                    vtx[i0] = x01 * iw; i0++; vtx[i0] = y01 * iw; i0++; vtx[i0] = z01 * iw;\n                } //*/\n            }\n            return this;\n        }\n    }\n    \n    \n    /** Face */\n    class Face {\n        public var i0:int, i1:int, i2:int, normal:Vector3D = new Vector3D();\n        function Face() { i0 = i1 = i2 = 0; }\n        static private var _freeList:Vector.<Face> = new Vector.<Face>();\n        static public function free(face:Face) : void { _freeList.push(face); }\n        static public function alloc(i0:int, i1:int, i2:int) : Face { \n            var f:Face = _freeList.pop() || new Face();\n            f.i0 = i0; f.i1 = i1; f.i2 = i2; return f;\n        }\n    }\n    \n    \n    /** Light */\n    class Light extends Vector3D {\n        public var lightVector:Vector.<Number>  = new Vector.<Number>(4, true), halfVector:Vector.<Number>  = new Vector.<Number>(4, true);\n        private var _in :Vector.<Number> = new Vector.<Number>(6, true), _out:Vector.<Number> = new Vector.<Number>(6, true);\n        private var _lv3d:Vector3D  = new Vector3D(), _hv3d:Vector3D  = new Vector3D();\n        function Light(x:Number=1000, y:Number=1000, z:Number=1000) { super(x, y, z); halfVector[3] = lightVector[3] = 0; }\n        public function transform(sigl:SiGLCore) : void {\n            sigl.projectionMatrix.copyColumnTo(3, _hv3d);\n            _in[0] = x; _in[1] = y; _in[2] = z; _in[3] = _hv3d.x; _in[4] = _hv3d.y; _in[5] = _hv3d.z;\n            sigl.modelViewMatrix.inverted.transformVectors(_in, _out);\n            _lv3d.setTo(_out[0], _out[1], _out[2]); _lv3d.normalize(); _hv3d.setTo(_out[3], _out[4], _out[5]); _hv3d.normalize();\n            _hv3d.x += (lightVector[0] = _lv3d.x); _hv3d.y += (lightVector[1] = _lv3d.y); _hv3d.z += (lightVector[2] = _lv3d.z);\n            _hv3d.normalize(); halfVector[0] = _hv3d.x; halfVector[1] = _hv3d.y; halfVector[2] = _hv3d.z;\n        }\n    }\n    \n    \n    /** flat shading material */\n    class FlatShadingMaterial {\n        private var _col:int, _alp:Number, _amb:Number, _dif:Number, _spc:Number, _pow:Number;\n        private var _specMap:BitmapData = new BitmapData(1024,1,false);\n        private var _ambVector:Vector.<Number> = new Vector.<Number>(4, true);\n        private var _difDifVector:Vector.<Number> = new Vector.<Number>(4, true);\n        public function set color(c:int) : void { setColor(c, _alp, _amb, _dif); }\n        public function get color() : int { return _col; }\n        public function set alpha(a:Number) : void { setColor(_col, a, _amb, _dif); }\n        public function get alpha() : Number { return _alp; }\n        public function set ambient(a:Number) : void { setColor(_col, _alp, a, _dif); }\n        public function get ambient() : Number { return _amb; }\n        public function set diffuse(d:Number) : void { setColor(_col, _alp, _amb, d); }\n        public function get diffuse() : Number { return _dif; }\n        public function set specular(s:Number) : void { setSpecular(s, _pow); }\n        public function get specular() : Number { return _spc; }\n        public function set power(p:Number) : void { setSpecular(_spc, p); }\n        public function get power() : Number { return _pow; }\n        public function get ambientVector() : Vector.<Number> { return _ambVector; }\n        public function get diffuseDifVector() : Vector.<Number> { return _difDifVector; }\n        public function get specMap() : BitmapData { return _specMap; }\n        function FlatShadingMaterial(color:int=0xffffff, alpha:Number=1, ambient:Number=0.25, diffuse:Number=0.75, specular:Number=0.75, power:Number=16) {\n            setColor(color, alpha, ambient, diffuse);\n            setSpecular(specular, power);\n        }\n        public function setColor(color:int, alpha:Number=1, ambient:Number=0.25, diffuse:Number=0.75) : FlatShadingMaterial {\n            _col = color; _alp = alpha; _amb = ambient; _dif = diffuse;\n            var r:Number = ((color>>16)&255)*0.00392156862745098, g:Number = ((color>>8)&255)*0.00392156862745098, b:Number = (color&255)*0.00392156862745098;\n            _ambVector[0] = r * ambient; _ambVector[1] = g * ambient; _ambVector[2] = b * ambient; _ambVector[3] = alpha;\n            _difDifVector[0] = r * diffuse - _ambVector[0]; _difDifVector[1] = g * diffuse - _ambVector[1]; _difDifVector[2] = b * diffuse - _ambVector[2]; _difDifVector[3] = alpha;\n            return this;\n        }\n        private function setSpecular(specular:Number=0.75, power:Number=16) : FlatShadingMaterial {\n            _spc = specular; _pow = power; specular *= 256;\n            for (var i:int=0; i<1024; i++) {\n                var c:int = int(Math.pow(i*0.0009775171065493646, power) * specular);\n                _specMap.setPixel32(i, 0, ((c<255)?c:255)*0x10101);\n            }\n            return this;\n        }\n    }\n}\n","modified_date":1322009863,"compile_ok":"1","created_date":1321975479,"forked_count":"10","license":"MIT","swf":"http://swf.wonderfl.net/swf/usercode/d/dc/dc2d/dc2d00dc95e6d7c6f7738aff7d29e86abf50c9f1.swf","diff":"0","user":{"icon":"http://wonderfl.net/images/icon/2/27/278a/278afc585a0a283d6e1f13f081cfd9c377ab9db2m","name":"keim_at_Si"},"title":"Boolean Crystal","id":"vpLs","favorite_count":"66"},"stat":"ok"}