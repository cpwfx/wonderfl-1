{"code":{"thumbnail":"http://wonderfl.net/images/capture/9/9e/9e0f/9e0ff05badf4a63a0eb27b766820b92604cdbfd6_100.jpg?t=1346340957","parent":null,"as3":"package {\n    import flash.net.*;\n    import flash.geom.*;\n    import flash.utils.*;\n    import flash.events.*;\n    import flash.display.*;\n    import flash.display3D.*;\n    import flash.display3D.textures.*;\n    import com.adobe.utils.*;\n    import com.bit101.components.*;\n    import org.libspark.betweenas3.*;\n    import org.libspark.betweenas3.easing.*;\n    import org.libspark.betweenas3.tweens.*;\n    import org.si.sion.*;\n    import org.si.sion.midi.*;\n    import org.si.sion.events.*;\n    import org.si.sion.effector.*;\n    import org.si.sion.utils.soundfont.*;\n    import org.si.sion.utils.soundloader.*;\n    //import net.wonderfl.utils.*;\n\n    [SWF(frameRate=\"30\")]\n    public class main extends Sprite {\n    // parameters ----------\n        private const TEST_MODE:Boolean = false;\n        private const TITLE:String = \"GIMMICK - FANTAISIE IMPROMPTU -\";\n        private const SPRING_STRENGTH:Number = 0.75;\n        private const DAMPER_STRENGTH:Number = 0.25;\n        private const CAMERA_SPRING_STRENGTH:Number = 0.1;\n        private const CAMERA_DAMPER_STRENGTH:Number = 0.6;\n        private const HIT_STRENGTH:Number = 16;\n        private const BALL_SIZE:Number = 16;\n        private const GRAVITY:Number = 2;\n        private const BALL_REFLECTION:Number = 0.5;\n        private const KEY_REFLECTION:Number = 0.5;\n        private const DELAY_TIME:Number = 1200;\n        private const SHUFFLE_ITEM:String = \"Shuffle !!\";\n    // resource ----------\n        private const domainURL:String = \"http://soundimpulse.sakura.ne.jp/wonderfl/\";\n        private const cubeFile:String = \"_cube.png\";\n        private const ssfFile:String  = \"ssf.swf\";\n        private const midiFileList:Array = [\n          \"etude3.mid\",\"fantaisie.mid\",\"nocturne2.mid\",\"polonaise6.mid\",\"prelude7.mid\",\"valse6.mid\",\"etude12.mid\"\n        ];\n    // SiON ----------\n        private var driver:SiONDriver = new SiONDriver(4096);\n        private var soundLoader:SoundLoader = new SoundLoader();\n        private var smfData:* = {}, currentData:SMFData;\n    // Prolemy ----------\n        private var ptolemy:Ptolemy;\n        private var asm:AGALMiniAssembler = new AGALMiniAssembler();\n        private var programs:Vector.<Program3D> = new Vector.<Program3D>();\n        private var _light:Light = new Light();\n        private var _camera:Camera = new Camera();\n        private var _cameraBall:Camera = new Camera();\n        private var _cameraPos:Vector3D = new Vector3D();\n        private var _cameraVel:Vector3D = new Vector3D();\n        private var _mouseTarget:Point = new Point();\n        private var _mouseRotation:Point = new Point();\n    // models ----------\n        private var _fader:Mesh, _text:Mesh, _back:Mesh, _ball:Mesh, _meshWK:Mesh, _meshBK:Mesh;\n        private var _ballField:PointSpriteField;\n        private var _specTex:Texture, _cubeTex:CubeTexture, _ballSprite:Texture, _textTex:Texture;\n        private var _matWK:FlatShadingMaterial = new FlatShadingMaterial(0xffffff, 1, 0.75, 1);\n        private var _matBK:FlatShadingMaterial = new FlatShadingMaterial(0x000000, 1, 0.75, 1);\n    // keyboard ----------\n        private const KEY_COUNT:int = 69;\n        private var keyColors:Vector.<int> = new Vector.<int>(KEY_COUNT, true);\n        private var keyMatrix:Vector.<Matrix3D> = new Vector.<Matrix3D>(KEY_COUNT, true);\n        private var keyPosition:Vector.<Vector3D> = new Vector.<Vector3D>(KEY_COUNT, true);\n        private var keyMesh:Vector.<Mesh> = new Vector.<Mesh>(KEY_COUNT, true);\n        private var keyMaterial:Vector.<FlatShadingMaterial> = new Vector.<FlatShadingMaterial>(KEY_COUNT, true);\n        private var keyRotate:Vector.<Vector3D> = new Vector.<Vector3D>(KEY_COUNT, true);\n    // front screen ----------\n        private var faderColor:Vector.<Number> = Vector.<Number>([1,1,1,1]);\n        private var textColor:Vector.<Number> = Vector.<Number>([1,1,1,1]);\n        private var textBitmap:Bitmap;\n        private var textBD:BitmapData = new BitmapData(512,512,true,0);\n        private var textBDMatrix:Matrix = new Matrix(1,0,0,1,0,0);\n    // others ----------\n        private var vc:Vector3D = new Vector3D();\n        private var _prevTime:Number, _animStartTime:Number;\n        private var _label:Label, _selector:ComboBox;\n        private var dragStart:Point = new Point();\n    // properties ----------\n        public function get faderAlpha() : Number { return faderColor[3]; }\n        public function set faderAlpha(f:Number) : void { faderColor[3] = f; }\n        public function get textAlpha() : Number { return textColor[3]; }\n        public function set textAlpha(f:Number) : void { textColor[3] = f; }\n        \n    // constructor ----------\n        function main() {\n            Wonderfl.disable_capture();\n            //Wonderfl.capture_delay(30);\n            ptolemy = new Ptolemy(this, 8, 8, 450, 450);\n            ptolemy.sigl.setZRange(-300, 1500);\n            ptolemy.addEventListener(Event.COMPLETE, onReady);\n            clearText();\n            drawText(210, TITLE, true, 2);\n            drawText(240, \"powered by SiON v0.652\");\n            textBitmap = new Bitmap(textBD);\n            textBitmap.y = textBitmap.x = -23;\n            addChild(textBitmap);\n            _label = new Label(this, 200, 290, \"loading ...\");\n        }\n        \n    // entry points ----------\n        private function onReady(e:Event) : void {\n            ptolemy.removeEventListener(Event.COMPLETE, onReady);\n            soundLoader.addEventListener(Event.COMPLETE, setup);\n            soundLoader.addEventListener(ProgressEvent.PROGRESS, _onLoadingProgress);\n            for (var i:int=0; i<midiFileList.length; i++) {\n                soundLoader.setURL(new URLRequest(domainURL + midiFileList[i]), midiFileList[i], \"mid\");\n            }\n            soundLoader.setURL(new URLRequest(domainURL + ssfFile),  \"sondfont\", \"ssf\", true);\n            soundLoader.setURL(new URLRequest(domainURL + cubeFile), \"cube\", \"img\", true);\n            soundLoader.loadAll();\n        }\n        \n        private function setup(e:Event) : void {\n            soundLoader.removeEventListener(Event.COMPLETE, setup);\n            \n            setupPtolemy();\n            setupSiON();\n            \n            _label.text = \"Click to start\";\n            stage.addEventListener(MouseEvent.CLICK, start);\n        }\n        \n        private function start(e:Event) : void {\n            stage.removeEventListener(MouseEvent.CLICK, start);\n            // remove title objects\n            removeChild(_label);\n            removeChild(textBitmap);\n            // initialize\n            _cameraPos.setTo(0, 500, -1000);\n            _cameraVel.setTo(0, 0, 0);\n            _mouseTarget.setTo(0.3, 0);\n            _mouseRotation.setTo(0, 0);\n            _prevTime = getTimer();\n            currentData = smfData[\"fantaisie.mid\"];\n            setupController();\n            // set handlers\n            addEventListener(Event.ENTER_FRAME, draw);\n            stage.addEventListener(MouseEvent.MOUSE_DOWN, _onMouseDown);\n            // start fadeout\n            uploadText();\n            titleFade();\n        }\n        \n    // handlers ----------\n        private function _onLoadingProgress(e:ProgressEvent) : void {\n            _label.text = \"loading (\" + (soundLoader.bytesLoaded/soundLoader.bytesTotal*100).toFixed(0) + \"%)\";\n        }\n        private function _onSongSelected(e:Event) : void {\n            if (_selector.selectedItem == SHUFFLE_ITEM) shufflePlayNext();\n            else changeSong(String(_selector.selectedItem));\n        }\n        private function _onMouseDown(e:Event) : void {\n            stage.addEventListener(MouseEvent.MOUSE_MOVE, _onMouseMove);\n            stage.addEventListener(MouseEvent.MOUSE_UP,   _onMouseUp);\n            dragStart.setTo(mouseX, mouseY);\n            _dragging();\n        }\n        private function _onMouseMove(e:Event) : void {\n            _dragging();\n        }\n        private function _onMouseUp(e:Event) : void {\n            _dragging();\n            _mouseRotation.setTo(0, 0);\n            stage.removeEventListener(MouseEvent.MOUSE_MOVE, _onMouseMove);\n            stage.removeEventListener(MouseEvent.MOUSE_UP,   _onMouseUp);\n        }\n        private function _dragging() : void {\n            _mouseRotation.x = (mouseX - dragStart.x)/16000;\n            _mouseRotation.y = (mouseY - dragStart.y)/1600;\n        }\n        private function _onNoteOn(e:SiONMIDIEvent) : void {\n            if (e.note >= 24 && e.note < 24+KEY_COUNT) {\n                Ball.create(keyPosition[e.note-24], e.note-24, e.value);\n            }\n        }\n        private function _onFadeOut(e:SiONEvent) : void {\n            driver.stop();\n        }\n        private function _onFinishSequence() : void {\n            BetweenAS3.delay(func(shufflePlayNext), 4).play();\n        }\n        private function _onHit(keyIndex:int) : void {\n            keyRotate[keyIndex].y = -HIT_STRENGTH;\n        }\n        \n    // setup ----------\n        private function setupPtolemy() : void {\n            var i:int, j:int, k:int, n:Number, cm:Mesh, vi:int, prog:Program3D;\n            var context3D:Context3D = ptolemy.context3D;\n            var mat:Matrix3D = new Matrix3D();\n            var tv:Vector.<Number> = new Vector.<Number>();\n            \n            // Ptolemy Setup\n            context3D.enableErrorChecking = TEST_MODE;\n            // meshes\n            _fader = SolidFactory.plane (new Mesh(\"V3\"),   512, 512, 0).allocateBuffer(context3D).upload();\n            _text  = SolidFactory.plane (new Mesh(\"V3T2\"), 512, 512, 0).allocateBuffer(context3D).updateBuffer(\"T\", Vector.<Number>([0,1,1,1,0,0,1,0])).upload();\n            _back  = SolidFactory.sphere(new Mesh(\"V3N3\"), 1500, 1).allocateBuffer(context3D).updateFaceNormal(true).upload();\n            _ball  = SolidFactory.sphere(new Mesh(\"V3N3\"),  256, 2).allocateBuffer(context3D).updateFaceNormal(true).upload();\n            _meshWK = keyModel(20, 12, 80, 75, 8);\n            _meshBK = keyModel(14,  8, 56, 48, 8);\n            // textures\n            _specTex = context3D.createTexture(1024, 1, \"bgra\", false);\n            _specTex.uploadFromBitmapData(_matWK.specMap);\n            _cubeTex = createCubeTexture(context3D, soundLoader.hash[\"cube\"].bitmapData);\n            _textTex = context3D.createTexture(512, 512, \"bgra\", false);\n            // shaders\n            for (i=0; i<shaders.length; i++) {\n                prog = context3D.createProgram();\n                prog.upload(asm.assemble(\"vertex\", shaders[i].vs), asm.assemble(\"fragment\", shaders[i].fs));\n                programs.push(prog);\n            }\n            // constants\n            context3D.setProgramConstantsFromVector(\"vertex\",  126, Vector.<Number>([ptolemy.sigl.pointSpriteFieldScale.x, ptolemy.sigl.pointSpriteFieldScale.y, 0, 0]));\n            context3D.setProgramConstantsFromVector(\"vertex\",  127, Vector.<Number>([0, 0.5, 1, 2]));\n            context3D.setProgramConstantsFromVector(\"fragment\", 27, Vector.<Number>([0, 0.5, 1, 2]));\n            \n            // balls\n            _ballSprite = context3D.createTexture(256, 256, \"bgra\", true);\n            _ballField = new PointSpriteField(context3D);\n            Ball.texInfo = new PointSpriteTexInfo(0, 0, 1, 1, BALL_SIZE, BALL_SIZE);\n            Ball.initialize(_onHit, GRAVITY, DELAY_TIME);\n            // keyboard\n            var ks:Array = [0,1,0,1,0,0,1,0,1,0,1,0], d2r:Number = Math.PI/180,\n                rt:Array = [1,1,1,1,2,1,1,1,1,1,1,2], deg:Number = 0;\n            for (i=0; i<KEY_COUNT; i++) {\n                keyColors[i] = ks[i%12];\n                keyMatrix[i] = new Matrix3D();\n                keyMatrix[i].prependRotation(deg, Vector3D.Z_AXIS);\n                keyMatrix[i].prependTranslation(0,180-keyColors[i]*10,keyColors[i]*10);\n                keyMatrix[i].prependRotation(45, Vector3D.X_AXIS);\n                keyPosition[i] = keyMatrix[i].transformVector(new Vector3D(0,70-keyColors[i]*20,20));\n                deg += rt[i%12] * 4.5;\n                if (keyColors[i]) {\n                    keyMesh[i] = _meshBK;\n                    keyMaterial[i] = _matBK;\n                } else {\n                    keyMesh[i] = _meshWK;\n                    keyMaterial[i] = _matWK;\n                }\n                keyRotate[i] = new Vector3D(0,0,0);\n            }\n            \n            // Mesh construction tool\n            function keyModel(w:Number, w2:Number, h:Number, h2:Number, d:Number) : Mesh {\n                var hw:Number=w*0.5, hw2:Number=w2*0.5, hd:Number=d*0.5;\n                begin(new Mesh(\"V3N3\"));\n                if (!TEST_MODE) {\n                    f4(-hw, 0,-hd,  hw, 0,-hd, -hw, h,-hd,  hw, h,-hd);\n                    f4(-hw, 0,-hd, -hw, h,-hd,-hw2, 0, hd,-hw2,h2, hd);\n                    f4( hw, 0,-hd, -hw, 0,-hd, hw2, 0, hd,-hw2, 0, hd);\n                    f4(-hw, h,-hd,  hw, h,-hd,-hw2,h2, hd, hw2,h2, hd);\n                    f4( hw, h,-hd,  hw, 0,-hd, hw2,h2, hd, hw2, 0, hd);\n                }\n                f4(hw2, 0, hd,-hw2, 0, hd, hw2,h2, hd,-hw2,h2, hd);\n                return end();\n            }\n            function begin(m:Mesh) : void {\n                i=0; tv.length = 0; cm = m; cm.clear(); cm.vertexCount = 0;\n            }\n            function f3(x0:Number, y0:Number, z0:Number, x1:Number, y1:Number, z1:Number, x2:Number, y2:Number, z2:Number) : void {\n                cm.face(i++, i++, i++); tv.push(x0, y0, z0, x1, y1, z1, x2, y2, z2);\n            }\n            function f4(x0:Number, y0:Number, z0:Number, x1:Number, y1:Number, z1:Number, x2:Number, y2:Number, z2:Number, x3:Number, y3:Number, z3:Number) : void {\n                cm.qface(i++, i++, i++, i++); tv.push(x0, y0, z0, x1, y1, z1, x2, y2, z2, x3, y3, z3);\n            }\n            function end() : Mesh {\n                return cm.updateBuffer(Mesh.vertexAttributeName, tv).updateFaceNormal(true).allocateBuffer(context3D).upload();\n            }\n        }\n        private function setupSiON() : void {\n            var soundFont:SiONSoundFont = soundLoader.hash[\"sondfont\"], i:int;\n            for (i=0; i<midiFileList.length; i++) smfData[midiFileList[i]] = soundLoader.hash[midiFileList[i]];\n            driver.addEventListener(SiONMIDIEvent.NOTE_ON,  _onNoteOn);\n            driver.addEventListener(SiONEvent.FADE_OUT_COMPLETE, _onFadeOut);\n            driver.midiModule.voiceSet[0] = soundFont.pcmVoices[0];\n            driver.midiModule.setDefaultEffector(0,[new DelayLine(DELAY_TIME)]);\n            driver.midiModule.onFinishSequence = _onFinishSequence;\n            driver.volume = 0.25;\n        }\n        private function setupController() : void {\n            _selector = new ComboBox(this, 12, 12, \"fantaisie.mid\", midiFileList);\n            _selector.addItem(SHUFFLE_ITEM);\n            _selector.numVisibleItems = midiFileList.length;\n            _selector.addEventListener(Event.SELECT, _onSongSelected);\n        }\n        \n    // operation ----------\n        private function titleFade() : void {\n            BetweenAS3.serial(fadeIn(2), func(startSong), textFadeOut(2), func(sideTitle), textFadeIn(1)).play();\n        }\n        private function changeFade() : void {\n            BetweenAS3.serial(fadeOut(2), func(mainTitle), textFadeIn(2), BetweenAS3.delay(func(titleFade), 1)).play();\n        }\n        private function func(f:Function) : ITween { return BetweenAS3.func(f); }\n        private function fadeIn(time:Number) : ITween { return BetweenAS3.to(this, {faderAlpha:0}, time); }\n        private function fadeOut(time:Number) : ITween { return BetweenAS3.to(this, {faderAlpha:1, textAlpha:0}, time); }\n        private function textFadeIn(time:Number) : ITween { return BetweenAS3.to(this, {textAlpha:1}, time); }\n        private function textFadeOut(time:Number) : ITween { return BetweenAS3.to(this, {textAlpha:0}, time); }\n        private function mainTitle() : void { clearText(); drawText(220, currentData.title, true, 2); uploadText(); }\n        private function sideTitle() : void { clearText(); drawText(450, currentData.title, false); uploadText(); }\n        private function startSong() : void {\n            driver.play((TEST_MODE) ? null : currentData);\n            _selector.enabled = true;\n        }\n        private function shufflePlayNext() : void {\n            _selector.selectedItem = midiFileList[int(Math.random()*midiFileList.length)];\n        }\n        private function changeSong(song:String) : void {\n            currentData = smfData[song];\n            driver.fadeOut(4);\n            changeFade();\n            _selector.enabled = false;\n        }\n        \n    // draw ----------\n        private function draw(e:Event) : void {\n            var context3D:Context3D = ptolemy.context3D, sigl:SiGLCore = ptolemy.sigl, \n                i:int, now:Number, damper:Number, a:Number, b:Number, tx:Number, ty:Number, tx2:Number, ty2:Number, tz:Number,\n                sR:Number = 300, lR:Number = 700;\n\n            // camera motion\n            damper = 1-CAMERA_DAMPER_STRENGTH;\n            _mouseTarget.x += _mouseRotation.x;\n            _mouseTarget.y += _mouseRotation.y;\n            _mouseTarget.y *= 0.8;\n            tx = Math.cos(_mouseTarget.x * 3.1415926535897933);\n            ty = Math.sin(_mouseTarget.x * 3.1415926535897933);\n            tx2 = tx * tx;\n            ty2 = ty * ty;\n            a = (-lR * tx + Math.sqrt(lR*lR*tx2 - (tx2+ty2)*(sR*sR-lR*lR)*4)) / ((tx2+ty2)*2);\n            b = (_mouseTarget.y*45+30) * 0.017453292519943295;\n            a *= Math.cos(b);\n            tx *= a;\n            ty *= a;\n            tz = lR * Math.sin(b);\n            _cameraPos.incrementBy(_cameraVel);\n            _cameraVel.x = (_cameraVel.x + (tx - _cameraPos.x) * CAMERA_SPRING_STRENGTH) * damper;\n            _cameraVel.y = (_cameraVel.y + (ty - _cameraPos.y) * CAMERA_SPRING_STRENGTH) * damper;\n            _cameraVel.z = (_cameraVel.z + (tz - _cameraPos.z) * CAMERA_SPRING_STRENGTH) * damper;\n            \n            // global\n            _light.setTo(1000, 500, 1000);\n            _camera.update(_cameraPos.x,_cameraPos.y,_cameraPos.z, 0,0,0, 0.2,0,1);\n            sigl.id();\n\n            // 1st drawing\n            context3D.setRenderToTexture(_ballSprite);\n            context3D.clear(0,0,0,0);\n            // ball sprite\n            _cameraBall.copyFrom(_camera);\n            _cameraBall.copyColumnTo(3, vc);\n            vc.normalize(); vc.x *= 260; vc.y *= 260; vc.z *= 260;\n            _cameraBall.copyColumnFrom(3, vc);\n            sigl.setCameraMatrix(_cameraBall);\n            context3D.setProgram(programs[0]);\n            context3D.setTextureAt(0, _specTex);\n            context3D.setTextureAt(1, _cubeTex);\n            context3D.setCulling(\"back\");\n            context3D.setDepthTest(true, \"less\");\n            drawMesh(_ball, _matBK, BALL_REFLECTION);\n            \n            // 2nd drawing\n            context3D.setRenderToBackBuffer();\n            context3D.clear();\n            // background\n            sigl.setCameraMatrix(_camera);\n            context3D.setProgram(programs[1]);\n            context3D.setTextureAt(0, _cubeTex);\n            context3D.setTextureAt(1, null);\n            context3D.setCulling(\"front\");\n            context3D.setDepthTest(false, \"always\");\n            context3D.setProgramConstantsFromMatrix(\"vertex\", 0, sigl.modelViewProjectionMatrix, true);\n            if (!TEST_MODE) _back.drawTriangles(context3D);\n            // keyboard\n            context3D.setProgram(programs[0]);\n            context3D.setTextureAt(0, _specTex);\n            context3D.setTextureAt(1, _cubeTex);\n            context3D.setCulling(\"back\");\n            context3D.setDepthTest(true, \"less\");\n            sigl.push();\n            for (i=0; i<KEY_COUNT; i++) {\n                sigl.push().m(keyMatrix[i]).r(keyRotate[i].x, Vector3D.X_AXIS);\n                drawMesh(keyMesh[i], keyMaterial[i], KEY_REFLECTION);\n                sigl.pop();\n                keyRotate[i].x += keyRotate[i].y;\n                keyRotate[i].y -= keyRotate[i].x * SPRING_STRENGTH;\n                keyRotate[i].y *= 1-DAMPER_STRENGTH;\n            }\n            sigl.pop();\n            \n            // for test\n            if (TEST_MODE && Math.random() < 0.2) {\n                var idx:int = Math.random()*69;\n                Ball.create(keyPosition[idx], idx, Math.random()*127);\n            }\n\n            // point sprite (balls)\n            sigl.modelViewProjectionMatrix.copyColumnTo(2, vc);\n            now = getTimer();\n            Ball.update(_ballField, now - _prevTime, vc);\n            _prevTime = now;\n            context3D.setProgram(programs[2]);\n            context3D.setTextureAt(0, _ballSprite);\n            context3D.setTextureAt(1, null);\n            context3D.setCulling(\"none\");\n            context3D.setDepthTest(false, \"less\");\n            context3D.setProgramConstantsFromMatrix(\"vertex\", 0, sigl.modelViewProjectionMatrix, true);\n            _ballField.drawTriangles(context3D);\n\n            // front screen\n            sigl.setCameraMatrix(null).id();\n            context3D.setTextureAt(0, null);\n            context3D.setTextureAt(1, null);\n            context3D.setCulling(\"none\");\n            context3D.setDepthTest(false, \"always\");\n            context3D.setProgramConstantsFromMatrix(\"vertex\",   0, sigl.modelViewProjectionMatrix, true);\n            if (faderColor[3] > 0) {    // fader\n                context3D.setProgram(programs[3]);\n                context3D.setProgramConstantsFromVector(\"fragment\", 0, faderColor);\n                _fader.drawTriangles(context3D);\n            }\n            // text\n            context3D.setProgram(programs[4]);\n            context3D.setTextureAt(0, _textTex);\n            context3D.setProgramConstantsFromVector(\"fragment\", 0, textColor);\n            _text.drawTriangles(context3D);\n            \n            //if(!_s){_s=new BitmapData(450,450,false,0);with(addChildAt(new Bitmap(_s),0)){x=y=8;}}context3D.drawToBitmapData(_s);\n            context3D.present();\n        }\n        private var _s:BitmapData = null;\n        \n        private var _fc4:Vector.<Number> = Vector.<Number>([1, 0, 0, 0])\n        private function drawMesh(mesh:Mesh, material:FlatShadingMaterial, ref:Number) : void {\n            var context3D:Context3D = ptolemy.context3D, sigl:SiGLCore = ptolemy.sigl; \n            _fc4[0] = 1-ref; _fc4[1] = ref;\n            _light.transform(sigl);\n            context3D.setProgramConstantsFromMatrix(\"vertex\",   0, sigl.modelViewProjectionMatrix, true);\n            context3D.setProgramConstantsFromMatrix(\"vertex\",   4, sigl.modelViewMatrix, true);\n            context3D.setProgramConstantsFromVector(\"vertex\",   8, _camera.cameraVector(sigl));\n            context3D.setProgramConstantsFromVector(\"fragment\", 0, _light.lightVector);\n            context3D.setProgramConstantsFromVector(\"fragment\", 1, _light.halfVector);\n            context3D.setProgramConstantsFromVector(\"fragment\", 2, material.ambientVector);\n            context3D.setProgramConstantsFromVector(\"fragment\", 3, material.diffuseDifVector);\n            context3D.setProgramConstantsFromVector(\"fragment\", 4, _fc4);\n            mesh.drawTriangles(context3D);\n        }\n        \n        private function clearText() : void { textBD.fillRect(textBD.rect, 0); }\n        private function drawText(ty:Number, text:String, isCenter:Boolean=true, scale:Number=1) : void {\n            var label:Label, dx:Number, dy:Number, tx:Number;\n            Style.LABEL_TEXT = 0xffffffff;\n            label = new Label(null, 0, 0, text);\n            tx = (isCenter) ? (256-label.width*scale*0.5) : (470-label.width*scale);\n            ty += 10;\n            textBDMatrix.setTo(scale, 0, 0, scale, 0, 0);\n            for (dy=-1; dy<=1; dy++) for (dx=-1; dx<=1; dx++) {\n                textBDMatrix.tx = tx + dx;\n                textBDMatrix.ty = ty + dy;\n                textBD.draw(label, textBDMatrix);\n            }\n            Style.LABEL_TEXT = 0xff000000;\n            textBDMatrix.tx = tx;\n            textBDMatrix.ty = ty;\n            textBD.draw(new Label(null, 0, 0, text), textBDMatrix);\n        }\n        private function uploadText() : void {\n            _textTex.uploadFromBitmapData(textBD);\n        }\n    }\n}\n\n// Shaders\n// reflection render ----------\nvar vs0:String = <agal><![CDATA[\nm44 op, va0, vc0\nmov v0, va1\nsub vt0, va0, vc8\nnrm vt0.xyz, vt0\ndp3 vt1.x, vt0, va1\nadd vt1.x, vt1.x, vt1.x\nmul vt1, va1, vt1.x\nadd vt0, vt0, vt1\nm33 vt1.xyz, vt0, vc4\nmov vt1.w, vc127.x\nmov v1, vt1\n]]></agal>;\nvar fs0:String = <agal><![CDATA[\ndp3 ft0.x, v0, fc0\nabs ft0.x, ft0.x\nsat ft0.x, ft0.x\nmul ft0, fc3, ft0.x\nadd ft0, ft0, fc2\ndp3 ft1.x, v0, fc1\nsat ft1.x, ft1.x\ntex ft2, ft1.xx, fs0 <2d,clamp,nearest>\ntex ft3, v1.xyz, fs1 <cube,linear,mipnearest>\nmul ft0, ft0, fc4.x\nmul ft3, ft3, fc4.y\nadd ft0, ft0, ft3\nadd oc, ft0, ft2\n]]></agal>;\n// background ----------\nvar vs1:String = <agal><![CDATA[\nm44 op, va0, vc0\nmov v0, va1\n]]></agal>;\nvar fs1:String = <agal><![CDATA[\ntex oc, v0.xyz, fs0 <cube,linear,mipnearest>\n]]></agal>;\n// point sprite ----------\nvar vs2:String = <agal><![CDATA[\nm44 vt0, va0, vc0\nmov vt1.xy, va1\nmov vt1.zw, vc127.xx\ndiv vt1.xy, vt1.xy, vt0.w\nmul vt1.xy, vt1.xy, vc126.xy\nadd op, vt0, vt1\nmov v0, va2\nmov v1, va3\nmov v2, va4\n]]></agal>;\nvar fs2:String = <agal><![CDATA[\ntex ft0, v0.xy, fs0 <2d, clamp, nearest>\nmul ft0, ft0, v1\nadd ft0, ft0, v2\nsat oc, ft0\n]]></agal>;\n// fader ----------\nvar vs3:String = \"m44 op, va0, vc0\";\nvar fs3:String = \"mov oc, fc0\";\n// text area ----------\nvar vs4:String = <agal><![CDATA[\nm44 op, va0, vc0\nmov v0, va1\n]]></agal>;\nvar fs4:String = <agal><![CDATA[\ntex ft0, v0.xy, fs0 <2d, clamp, nearest>\nmul oc, ft0, fc0\n]]></agal>;\n\nvar shaders:Array = [{\"vs\":vs0,\"fs\":fs0}, {\"vs\":vs1,\"fs\":fs1}, {\"vs\":vs2,\"fs\":fs2}, {\"vs\":vs3,\"fs\":fs3}, {\"vs\":vs4,\"fs\":fs4}];\n\n\n\n\nimport flash.geom.*;\nimport flash.display.*;\nimport flash.display3D.*;\nimport flash.display3D.textures.*;\nimport org.si.sion.effector.*;\n\n// cube texture extractor\nfunction createCubeTexture(context3D:Context3D, bitmap:BitmapData) : CubeTexture {\n    var size:int = bitmap.width / 3, tex:CubeTexture = context3D.createCubeTexture(size, \"bgra\", false), \n        src:BitmapData, bmp:BitmapData, mat:Matrix = new Matrix(), i:int, mm:int, s:int, scl:Number, rot:Array=[-1,1,2,0,0,0];\n    for (i=0; i<6; i++) {\n        src = new BitmapData(size, size, false);\n        src.copyPixels(bitmap, new Rectangle((i%3)*size, (int(i/3))*size, size, size), new Point(0, 0));\n        for (mm=0, s=size; s!=0; mm++, s>>=1) {\n            scl = s / size;\n            mat.identity();\n            mat.translate(size*-0.5,size*-0.5);\n            mat.rotate(rot[i]*Math.PI*0.5);\n            mat.translate(size*0.5,size*0.5);\n            mat.scale(scl, scl);\n            bmp = new BitmapData(s, s, false);\n            bmp.draw(src, mat, null, null, null, true);\n            tex.uploadFromBitmapData(bmp, i, mm);\n            bmp.dispose();\n        }\n    }\n    return tex;\n}\n\n// Ball particle class\nclass Ball extends Vector3D {\n    static public var callbackHit:Function, texInfo:PointSpriteTexInfo, halfGrav:Number, delayTime:Number;\n    static private var _active:Ball, _free:Ball, _sorted:Ball=null;\n    public var next:Ball, prev:Ball, start:Vector3D = new Vector3D(), vel:Vector3D = new Vector3D(), age:Number, keyIndex:int, projZ:Number;\n    function Ball() { next = prev = this; }\n    public function setup(x:Number, y:Number, z:Number, tx:Number, ty:Number, tz:Number, time:Number) : void {\n        var invtime:Number = 1/time;\n        setTo(x, y, z);\n        start.setTo(x, y, z);\n        vel.setTo((tx-x)*invtime, (ty-y)*invtime, (tz-z-halfGrav*time*time)*invtime);\n        age = 0;\n    }\n// linked list operations ----------\n    public function push(b:Ball) : void {\n        b.next = this;\n        b.prev = prev;\n        b.prev.next = b;\n        b.next.prev = b;\n    }\n    public function unshift(b:Ball) : void {\n        b.next = next;\n        b.prev = this;\n        b.prev.next = b;\n        b.next.prev = b;\n    }\n    public function shift() : Ball {\n        if (next == this) return null;\n        var inst:Ball = next;\n        next = inst.next;\n        next.prev = this;\n        inst.next = inst.prev = inst;\n        return inst;\n    }\n    public function insertSort(b:Ball) : void {\n        for (var t:Ball=prev; t!=this; t=t.prev) {\n            if (t.projZ<=b.projZ) break;\n        }\n        b.prev = t;\n        b.next = t.next;\n        b.prev.next = b;\n        b.next.prev = b;\n    }\n// global operations ----------\n    static public function initialize(hit:Function, gravity:Number, delay:Number) : void {\n        _active = new Ball();\n        _free   = new Ball();\n        _sorted = new Ball();\n        callbackHit = hit;\n        halfGrav = -gravity * 0.5 / 1000;\n        delayTime = delay;\n    }\n    static public function create(t:Vector3D, keyIndex:int, velocity:int) : void {\n        var newBall:Ball = _free.shift() || new Ball();\n        newBall.setup(0, 0, velocity-600, t.x, t.y, t.z, delayTime);\n        newBall.keyIndex = keyIndex;\n        _active.unshift(newBall);\n    }\n    static public function update(psf:PointSpriteField, dage:Number, v2:Vector3D) : void {\n        var ball:Ball;\n        // move and sort\n        while (ball=_active.shift()) {\n            ball.age += dage;\n            ball.x = ball.start.x + ball.vel.x * ball.age;\n            ball.y = ball.start.y + ball.vel.y * ball.age;\n            ball.z = ball.start.z + ball.vel.z * ball.age + halfGrav * ball.age * ball.age;\n            if (ball.z < -600) _free.push(ball);\n            else {\n                if (ball.age > delayTime) {\n                    ball.x = ball.start.x + ball.vel.x * delayTime;\n                    ball.y = ball.start.y + ball.vel.y * delayTime;\n                    ball.z = ball.start.z + ball.vel.z * delayTime + halfGrav * delayTime * delayTime;\n                    ball.setup(ball.x, ball.y, ball.z, 0, 0, -600, delayTime*0.75);\n                    callbackHit(ball.keyIndex);\n                }\n                ball.projZ = ball.x * v2.x + ball.y * v2.y + ball.z * v2.z + v2.w;\n                _sorted.insertSort(ball);\n            }\n        }\n        // create sprite\n        ball = _sorted; _sorted = _active; _active = ball;\n        psf.clearSprites();\n        for (ball=_active.next; ball!=_active; ball=ball.next) {\n            psf.createSprite(texInfo, ball.x, ball.y, ball.z, 1,0,0,1, 1,1,1,(ball.z>-200)?1:((ball.z+600)*0.0025));\n        }\n    }\n}\n\nclass DelayLine extends SiEffectBase {\n    private var _buf:Vector.<Number>, _bufIndex:int;\n    function DelayLine(length:Number) {  // length [ms]\n        _buf = new Vector.<Number>(int(88.2 * length));\n    }\n    \n    override public function prepareProcess() : int {\n        var i:int, imax:int = _buf.length;\n        for (i=0; i<imax; i++) _buf[i] = 0;\n        _bufIndex = 0;\n        return 2;\n    }\n    \n    override public function process(channels:int, buffer:Vector.<Number>, startIndex:int, length:int) : int {\n        startIndex <<= 1;\n        length <<= 1;\n        var i:int, imax:int = startIndex + length, bufLength:int=_buf.length;\n        for (i=startIndex; i<imax; i++) {\n            _buf[_bufIndex] = buffer[i];\n            _bufIndex++;\n            if (_bufIndex == bufLength) _bufIndex = 0;\n            buffer[i] = _buf[_bufIndex];\n        }\n        return channels;\n    }\n}\n\nclass SolidFactory {\n    static public function sphere(mesh:Mesh, size:Number=1, precision:int=1, shareVertex:Boolean=true) : Mesh {\n        var s:Number=size*0.5, i:int, imax:int, istep:int, v:Vector3D=new Vector3D();\n        if (shareVertex) {\n            var a:Number=0.276393202, b:Number=0.447213595, c:Number=0.525731112, d:Number=0.723606798, e:Number=0.850650808\n            mesh.clear(); mesh.vertexCount=0;\n            _tv.length = 0;\n            _tv.push(0,1,0, 0,b,b+b, e,b,a, c,b,-d, -c,b,-d, -e,b,a);\n            _tv.push(e,-b,-a, c,-b,d, -c,-b,d, -e,-b,-a, 0,-b,-b-b, 0,-1,0);\n            mesh.qface(0,2,1,7).qface(0,3,2,6).qface(0,4,3,10).qface(0,5,4,9).qface(0,1,5,8);\n            mesh.qface(1,7,8,11).qface(2,6,7,11).qface(3,10,6,11).qface(4,9,10,11).qface(5,8,9,11);\n            mesh.updateBuffer(Mesh.vertexAttributeName, _tv);\n        } else {\n            //icosahedron(mesh, 1);\n        }\n        mesh.divideFaces(precision, shareVertex);\n        i = mesh.attributes[Mesh.vertexAttributeName].offset;\n        imax = mesh.vertices.length;\n        istep = mesh.data32PerVertex;\n        for (i=0; i<imax; i+=istep) {\n            v.setTo(mesh.vertices[i], mesh.vertices[i+1], mesh.vertices[i+2]);\n            v.normalize();\n            mesh.vertices[i]   = v.x * s;\n            mesh.vertices[i+1] = v.y * s;\n            mesh.vertices[i+2] = v.z * s;\n        } \n        return mesh;\n    }\n    \n    static public function plane(mesh:Mesh, width:Number, height:Number, z:Number=0) : Mesh {\n        _tv.length = 0;\n        _tv.push(-width*0.5,-height*0.5,z, width*0.5,-height*0.5,z, -width*0.5,height*0.5,z, width*0.5,height*0.5,z);\n        mesh.qface(0,1,2,3);\n        return mesh.updateBuffer(Mesh.vertexAttributeName, _tv);\n    }\n    \n// internal functions --------------------------------------------------\n    static private var _tv:Vector.<Number> = new Vector.<Number>(), _tv3d:Vector.<Vector3D> = new Vector.<Vector3D>(), _ii:int, _mesh:Mesh;\n    static private function _v3d(x:Number, y:Number, z:Number) : void { _tv3d.push(new Vector3D(x, y, z)); }\n    static private function _begin(mesh:Mesh) : void { _mesh = mesh; mesh.clear(); mesh.vertexCount=0; _ii = 0; _tv.length = 0; _tv3d.length = 0; }\n    static private function _f3() : void { _mesh.face(_ii++, _ii++, _ii++); }\n    static private function _f4() : void { _mesh.qface(_ii++, _ii++, _ii++, _ii++); }\n    static private function _end() : Mesh { return _mesh.updateBuffer(Mesh.vertexAttributeName, _tv); }\n    static private function _f5(i0:int, i1:int, i2:int, i3:int, i4:int) : void {\n        _mesh.qface(_ii++, _ii++, _ii++, _ii++).face(_ii-3, _ii-4, _ii++);\n        _tv.push(_tv3d[i0].x, _tv3d[i0].y, _tv3d[i0].z);\n        _tv.push(_tv3d[i1].x, _tv3d[i1].y, _tv3d[i1].z);\n        _tv.push(_tv3d[i2].x, _tv3d[i2].y, _tv3d[i2].z);\n        _tv.push(_tv3d[i3].x, _tv3d[i3].y, _tv3d[i3].z);\n        _tv.push(_tv3d[i4].x, _tv3d[i4].y, _tv3d[i4].z);\n    }\n}\n\n/* Tiny Ptolemy */ {\n    import flash.net.*;\n    import flash.geom.*;\n    import flash.events.*;\n    import flash.system.*;\n    import flash.display.*;\n    import flash.display3D.*;\n    import com.adobe.utils.*;\n\n    /** Operation Center */\n    class Ptolemy extends EventDispatcher {\n    // variables ----------------------------------------\n        public var context3D:Context3D;\n        public var sigl:SiGLCore;\n        public var resources:* = {};\n\n        private var _loadedResourceCount:int;\n    // constructor ----------------------------------------\n        function Ptolemy(parent:DisplayObjectContainer, xpos:Number, ypos:Number ,width:int, height:int) : void {\n            var stage:Stage = parent.stage, stage3D:Stage3D = stage.stage3Ds[0];\n            stage.scaleMode = StageScaleMode.NO_SCALE;\n            stage.align = StageAlign.TOP_LEFT;\n            stage.quality = StageQuality.LOW;\n            stage3D.x = xpos; stage3D.y = ypos;\n            sigl = new SiGLCore(width, height);\n            stage3D.addEventListener(Event.CONTEXT3D_CREATE, function(e:Event):void{\n                context3D = e.target.context3D;\n                if (context3D) {\n                    context3D.enableErrorChecking = true;                   // check internal error\n                    context3D.configureBackBuffer(width, height, 0, true);  // disable AA/ enable depth/stencil\n                    context3D.setBlendFactors(Context3DBlendFactor.SOURCE_ALPHA, Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA);\n                    context3D.setCulling(Context3DTriangleFace.BACK);       // culling back face\n                    context3D.setRenderToBackBuffer();\n                    dispatchEvent(e.clone());\n                    if (--_loadedResourceCount == 0) dispatchEvent(new Event(Event.COMPLETE));\n                } else dispatchEvent(new ErrorEvent(ErrorEvent.ERROR, false, false, \"Context3D not found\"));\n            });\n            stage3D.requestContext3D();\n            _loadedResourceCount = 1;\n        }\n    // load resource ----------------------------------------\n        public function load(urlRequest:URLRequest, id:String=null, type:String=null, checkPolicyFile:Boolean=false) : EventDispatcher {\n            var loader:Loader, urlLoader:URLLoader;\n            _loadedResourceCount++;\n            if (type == \"img\") {\n                loader = new Loader();\n                loader.load(urlRequest, new LoaderContext(checkPolicyFile));\n                loader.contentLoaderInfo.addEventListener(Event.COMPLETE, function(e:Event) : void {\n                    resources[id] = e.target.content;\n                    if (--_loadedResourceCount == 0) dispatchEvent(new Event(Event.COMPLETE));\n                });\n                return loader;\n            }\n            urlLoader = new URLLoader(urlRequest);\n            urlLoader.dataFormat = (type == \"txt\") ? URLLoaderDataFormat.TEXT : URLLoaderDataFormat.BINARY;\n            urlLoader.addEventListener(Event.COMPLETE, function(e:Event) : void {\n                resources[id] = e.target.data;\n                if (--_loadedResourceCount == 0) dispatchEvent(new Event(Event.COMPLETE));\n            });\n            return urlLoader;\n        }\n    }\n\n    /** SiGLCore provides basic matrix operations. */\n    class SiGLCore {\n    // variables ----------------------------------------\n        public var modelViewMatrix:SiGLMatrix = new SiGLMatrix(), projectionMatrix:SiGLMatrix = new SiGLMatrix();\n        public var viewWidth:Number, viewHeight:Number, pointSpriteFieldScale:Point = new Point();\n        public var defaultCameraMatrix:SiGLMatrix = new SiGLMatrix(), matrix:SiGLMatrix = modelViewMatrix;\n        private var _mvpMatrix:Matrix3D = new Matrix3D(), _mvpdir:Boolean, _2d:Number, _2r:Number;\n        private var _mag:Number, _zNear:Number, _zFar:Number, _fieldOfView:Number, _alignTopLeft:Boolean = false;\n    // properties ----------------------------------------\n        public function get modelViewProjectionMatrix() : Matrix3D {\n            if (_mvpdir) {\n                _mvpMatrix.copyFrom(projectionMatrix);\n                _mvpMatrix.prepend(modelViewMatrix);\n                _mvpdir = false;\n            }\n            return _mvpMatrix;\n        }\n        public function get align() : String { return (_alignTopLeft) ? \"topLeft\" : \"center\"; }\n        public function set align(mode:String) : void { _alignTopLeft = (mode == \"topLeft\"); _updateProjectionMatrix(); }\n        public function get matrixMode() : String { return (matrix === projectionMatrix) ? \"projection\" : \"modelView\"; }\n        public function set matrixMode(mode:String) : void { matrix = (mode == \"projection\") ? projectionMatrix : modelViewMatrix; }\n        public function get angleMode() : String { return (_2r == 1) ? \"radian\" : \"degree\"; }\n        public function set angleMode(mode:String) : void { _2d = (mode == \"radian\") ? 57.29577951308232 : 1; _2r = (mode == \"radian\") ? 1 : 0.017453292519943295; }\n        public function get fieldOfView() : Number { return _fieldOfView / _2r; }\n        public function set fieldOfView(fov:Number) : void { _fieldOfView = fov * _2r; _updateProjectionMatrix(); }\n        public function get magnification() : Number { return _mag; }\n        public function set magnification(mag:Number) : void { _mag = mag; _updateProjectionMatrix(); }\n    // constructor ----------------------------------------\n        function SiGLCore(width:Number=1, height:Number=1) {\n            viewWidth = width; viewHeight = height;\n            angleMode = \"degree\"; _mag = 1;\n            _zNear = -1000; _zFar = 200;\n            modelViewMatrix.identity();\n            _mvpdir = true;\n            this.fieldOfView = 60;\n        }\n    // matrix operations ----------------------------------------\n        public function forceUpdateMatrix() : SiGLCore { _mvpdir = true; return this; }\n        public function setZRange(zNear:Number=-100, zFar:Number=100) : SiGLCore { _zNear = zNear; _zFar = zFar; _updateProjectionMatrix(); return this; }\n        public function clear() : SiGLCore { matrix.clear(); _mvpdir = true; return this; }\n        public function id() : SiGLCore { matrix.id(); _mvpdir = true; return this; }\n        public function push() : SiGLCore { matrix.push(); return this; }\n        public function pop() : SiGLCore { matrix.pop(); _mvpdir = true; return this; }\n        public function rem() : SiGLCore { matrix.rem(); _mvpdir = true; return this; }\n        public function r(a:Number, axis:Vector3D, pivot:Vector3D = null) : SiGLCore { matrix.prependRotation(a*_2d, axis, pivot); matrix._invdir = _mvpdir = true; return this; }\n        public function s(x:Number, y:Number, z:Number=1) : SiGLCore { matrix.prependScale(x, y, z); matrix._invdir = _mvpdir = true; return this; }\n        public function t(x:Number, y:Number, z:Number=0) : SiGLCore { matrix.prependTranslation(x, y, z); matrix._invdir = _mvpdir = true; return this; }\n        public function m(mat:Matrix3D) : SiGLCore { matrix.prepend(mat); matrix._invdir = _mvpdir = true; return this; }\n        public function re(x:Number, y:Number, z:Number) : SiGLCore { matrix.prependRotationXYZ(x*_2r, y*_2r, z*_2r); _mvpdir = true; return this; }\n        public function setCameraMatrix(mat:Matrix3D=null) : SiGLCore { projectionMatrix.rem().prepend(mat || defaultCameraMatrix); _mvpdir = true; return this; }\n        private function _updateProjectionMatrix() : void {\n            var wh:Number = viewWidth / viewHeight, rev:Number = (_alignTopLeft)?-1:1,\n                fl:Number = (viewHeight * 0.5) / Math.tan(_fieldOfView * 0.5);\n            if (_zNear <= -fl) _zNear = -fl + 0.001;\n            projectionMatrix.clear().perspectiveFieldOfView(_fieldOfView, wh, _zNear+fl, _zFar+fl, -1);\n            pointSpriteFieldScale.setTo(projectionMatrix.rawData[0] * fl, projectionMatrix.rawData[5] * fl);\n            projectionMatrix.push();\n            defaultCameraMatrix.identity();\n            defaultCameraMatrix.prependTranslation(0, 0, -fl);\n            if (_alignTopLeft) defaultCameraMatrix.prependTranslation(viewWidth* 0.5, -viewHeight * 0.5, 0);\n            defaultCameraMatrix.prependScale(_mag, _mag * rev, _mag * rev);\n            setCameraMatrix();\n        }\n    }\n    \n    /** SiGLMatrix is extention of Matrix3D with push/pop operation */\n    class SiGLMatrix extends Matrix3D {\n        internal var _invdir:Boolean = false, _inv:Matrix3D = new Matrix3D(), _stac:Vector.<Matrix3D> = new Vector.<Matrix3D>();\n        static private var _tv:Vector.<Number> = new Vector.<Number>(16, true), _tm:Matrix3D = new Matrix3D();\n        static private var _in:Vector.<Number> = new Vector.<Number>(4, true), _out:Vector.<Number> = new Vector.<Number>(4, true);\n        public function get inverted() : Matrix3D { if (_invdir) { _inv.copyFrom(this); _inv.invert(); _invdir = false; } return _inv; }\n        public function forceUpdateInvertedMatrix() : SiGLMatrix { _invdir=true; return this; }\n        public function clear() : SiGLMatrix { _stac.length=0; return id(); }\n        public function id() : SiGLMatrix { identity(); _inv.identity(); return this; }\n        public function push() : SiGLMatrix { _stac.push(this.clone()); return this; }\n        public function pop() : SiGLMatrix { this.copyFrom(_stac.pop()); _invdir=true; return this; }\n        public function rem() : SiGLMatrix { this.copyFrom(_stac[_stac.length-1]); _invdir=true; return this; }\n        public function prependRotationXYZ(rx:Number, ry:Number, rz:Number) : SiGLMatrix {\n            var sx:Number = Math.sin(rx), sy:Number = Math.sin(ry), sz:Number = Math.sin(rz), \n                cx:Number = Math.cos(rx), cy:Number = Math.cos(ry), cz:Number = Math.cos(rz);\n            _tv[0] = cz*cy; _tv[1] = sz*cy; _tv[2] = -sy; _tv[4] = -sz*cx+cz*sy*sx; _tv[5] = cz*cx+sz*sy*sx;\n            _tv[6] = cy*sx; _tv[8] = sz*sx+cz*sy*cx; _tv[9] = -cz*sx+sz*sy*cx;\n            _tv[10] = cy*cx; _tv[14] = _tv[13] = _tv[12] = _tv[11] = _tv[7] = _tv[3] = 0; _tv[15] = 1;\n            _tm.copyRawDataFrom(_tv); prepend(_tm); _invdir=true;\n            return this;\n        }\n        public function lookAt(cx:Number, cy:Number, cz:Number, tx:Number=0, ty:Number=0, tz:Number=0, ux:Number=0, uy:Number=1, uz:Number=0, w:Number=0) : SiGLMatrix {\n            var dx:Number=tx-cx, dy:Number=ty-cy, dz:Number=tz-cz, dl:Number=-1/Math.sqrt(dx*dx+dy*dy+dz*dz), \n                rx:Number=dy*uz-dz*uy, ry:Number=dz*ux-dx*uz, rz:Number=dx*uy-dy*ux, rl:Number= 1/Math.sqrt(rx*rx+ry*ry+rz*rz);\n            _tv[0] = (rx*=rl); _tv[4] = (ry*=rl); _tv[8]  = (rz*=rl); _tv[12] = -(cx*rx+cy*ry+cz*rz) * w;\n            _tv[2] = (dx*=dl); _tv[6] = (dy*=dl); _tv[10] = (dz*=dl); _tv[14] = -(cx*dx+cy*dy+cz*dz) * w;\n            _tv[1] = (ux=dy*rz-dz*ry); _tv[5] = (uy=dz*rx-dx*rz); _tv[9] = (uz=dx*ry-dy*rx); _tv[13] = -(cx*ux+cy*uy+cz*uz) * w;\n            _tv[3] = _tv[7] = _tv[11] = 0; _tv[15] = 1; copyRawDataFrom(_tv); _invdir=true;\n            return this;\n        }\n        public function perspectiveFieldOfView(fieldOfViewY:Number, aspectRatio:Number, zNear:Number, zFar:Number, lh:Number=1.0) : void {\n            var yScale:Number = 1.0 / Math.tan(fieldOfViewY * 0.5), xScale:Number = yScale / aspectRatio;\n            this.copyRawDataFrom(Vector.<Number>([xScale,0,0,0,0,yScale,0,0,0,0,zFar/(zFar-zNear)*lh,lh,0,0,(zNear*zFar)/(zNear-zFar),0]));\n        }\n        public function transform(vector:Vector3D) : Vector3D {\n            _in[0] = vector.x; _in[1] = vector.y; _in[2] = vector.z; _in[3] = vector.w;\n            transformVectors(_in, _out); vector.setTo(_out[0], _out[1], _out[2]); vector.w = _out[3];\n            return vector;\n        }\n    }\n    \n    /** Mesh */\n    class Mesh {\n    // constants ----------------------------------------\n        static public const vertexAttributeName:String = \"V\";\n        static public const normalAttributeName:String = \"N\";\n    // variables ----------------------------------------\n        public var vertices:Vector.<Number> = new Vector.<Number>();\n        public var faces:Vector.<Face> = new Vector.<Face>();\n        public var vertexBuffer:VertexBuffer3D, indexBuffer:IndexBuffer3D;\n        public var data32PerVertex:int, attributes:*={}, atl:Array = [];\n        private var _indices:Vector.<uint> = new Vector.<uint>(), _indexDirty:Boolean=true;\n        static private var _out:Vector.<Number> = new Vector.<Number>();\n    // properties ----------------------------------------\n        public function get vertexCount() : int { return vertices.length / data32PerVertex; }\n        public function set vertexCount(count:int) : void { vertices.length = count * data32PerVertex; }\n        public function get indices() : Vector.<uint> {\n            var idx:Vector.<uint> = _indices, f:Face, i:int, imax:int, j:int;\n            if (_indexDirty) {\n                idx.length = imax = faces.length * 3;\n                for (i=0,j=0; i<imax; j++) { f=faces[j]; idx[i]=f.i0; i++; idx[i]=f.i1; i++; idx[i]=f.i2; i++; }\n                _indexDirty = false;\n            }\n            return idx;\n        }\n    // contructor ----------------------------------------\n        function Mesh(bufferFormat:String=\"V3\") {\n            var rex:RegExp = /([_a-zA-Z]+)([1234b])/g, res:*, i:int=0;\n            data32PerVertex = 0;\n            while (res = rex.exec(bufferFormat)) {\n                attributes[res[1]] = {size:int(res[2]), offset:data32PerVertex};\n                data32PerVertex += (atl[i++]=int(res[2]));\n            }\n        }\n    // oprations ----------------------------------------\n        public function updateBuffer(attr:String, l:Vector.<Number>, offset:int=0) : Mesh {\n            var vai:* = attributes[attr], size:int = vai.size, il:int, iv:int, i:int, j:int, imax:int=l.length/size+offset;\n            if (vertices.length < imax * data32PerVertex) vertices.length = imax * data32PerVertex;\n            for (il=0, i=offset; i<imax; i++) for (j=0, iv=i*data32PerVertex+vai.offset; j<size; j++, iv++, il++) vertices[iv]=l[il];\n            return this;\n        }\n        public function allocateBuffer(context3D:Context3D) : Mesh {\n            vertexBuffer = context3D.createVertexBuffer(vertexCount, data32PerVertex);\n            indexBuffer  = context3D.createIndexBuffer(indices.length);\n            return this;\n        }\n        public function upload(vertex:Boolean=true, index:Boolean=true) : Mesh {\n            if (vertex) vertexBuffer.uploadFromVector(vertices, 0, vertexCount);\n            if (index) indexBuffer.uploadFromVector(indices, 0, indices.length);\n            return this;\n        }\n        public function dispose() : Mesh {\n            if (vertexBuffer) vertexBuffer.dispose();\n            if (indexBuffer)  indexBuffer.dispose();\n            vertexBuffer = null;\n            indexBuffer = null;\n            return this;\n        }\n        public function drawTriangles(context3D:Context3D) : Mesh {\n            var i:int, o:int=0, f:Array = [\"\",\"float1\",\"float2\",\"float3\",\"float4\"];\n            for (i=0; i<atl.length; o+=atl[i++]) context3D.setVertexBufferAt(i, vertexBuffer, o, f[atl[i]]);\n            context3D.drawTriangles(indexBuffer, 0, faces.length);\n            for (i=0; i<atl.length; i++) context3D.setVertexBufferAt(i, null, 0, \"float1\");\n            return this;\n        }\n        public function clear() : Mesh { for (var i:int=0; i<faces.length; i++) Face.free(faces[i]); faces.length = 0; _indexDirty = true; return this; }\n        public function face(i0:int, i1:int, i2:int) : Mesh { faces.push(Face.alloc(i0, i1, i2)); _indexDirty = true; return this; }\n        public function qface(i0:int, i1:int, i2:int, i3:int) : Mesh { faces.push(Face.alloc(i0, i1, i2), Face.alloc(i3, i2, i1)); _indexDirty = true; return this; }\n        public function flipFaces() : Mesh { for (var i:int=0,j:int; i<faces.length; i++) { j=faces[i].i0; faces[i].i0=faces[i].i1; faces[i].i1=faces[i].i2; faces[i].i2=j; } return this;}\n        public function divideFaces(precision:int=1, shareVertex:Boolean=true) : Mesh {\n            var prec:int, i:int, imax:int, i0:int, i1:int, i2:int, vindex:int = vertexCount, _vhash:*={};\n            for (prec=0; prec<precision; prec++) for (i=0, imax=faces.length; i<imax; i++) {\n                i0 = faces[i].i0; i1 = faces[i].i1; i2 = faces[i].i2;\n                face(i0, _newvtx(i0, i1), _newvtx(i2, i0));\n                face(_newvtx(i0, i1), i1, _newvtx(i1, i2));\n                face(_newvtx(i2, i0), _newvtx(i1, i2), i2);\n                faces[i].i0 = _newvtx(i0, i1); faces[i].i1 = _newvtx(i1, i2); faces[i].i2 = _newvtx(i2, i0);\n            }\n            return this;\n            function _newvtx(i0:int, i1:int) : int {\n                var vkey:uint = (i0<<16) | i1, idx:int;\n                if (vkey in _vhash) return _vhash[vkey];\n                vkey = (i1<<16) | i0; if (vkey in _vhash) return _vhash[vkey];\n                i0 *= data32PerVertex; i1 *= data32PerVertex; idx = vertices.length; vertices.length += data32PerVertex;\n                vertices[idx] = (vertices[i0] + vertices[i1]) * 0.5; idx++; i0++; i1++;\n                vertices[idx] = (vertices[i0] + vertices[i1]) * 0.5; idx++; i0++; i1++;\n                vertices[idx] = (vertices[i0] + vertices[i1]) * 0.5;\n                if (shareVertex) _vhash[vkey] = vindex;\n                return vindex++;\n            }\n        }\n        public function put(vtx:Vector.<Number>, idx:Vector.<uint>, mat:Matrix3D) : Mesh {\n            var i:int, imax:int = idx.length, offset:int = vertexCount;\n            mat.transformVectors(vtx, _out);\n            vertexCount += vtx.length / 3;\n            updateBuffer(\"V\", _out, offset);\n            for (i=0; i<imax;) face(idx[i++]+offset, idx[i++]+offset, idx[i++]+offset);\n            return this;\n        }\n        public function updateFaceNormal(updateVertexNormal:Boolean=true) : Mesh {\n            var vtx:Vector.<Number> = vertices, vcount:int = vertexCount, fcount:int = faces.length, \n                i:int, istep:int, f:Face, iw:Number, fidx:int,  i0:int, i1:int, i2:int, n0:Vector3D, n1:Vector3D, n2:Vector3D, \n                x01:Number, x02:Number, y01:Number, y02:Number, z01:Number, z02:Number;\n            // calculate face normals\n            for (i=0; i<fcount; i++) {\n                f=faces[i];\n                i0=f.i0*data32PerVertex; i1=f.i1*data32PerVertex; i2=f.i2 * data32PerVertex;\n                x01 = vtx[i1]-vtx[i0]; x02 = vtx[i2]-vtx[i0]; i0++; i1++; i2++;\n                y01 = vtx[i1]-vtx[i0]; y02 = vtx[i2]-vtx[i0]; i0++; i1++; i2++;\n                z01 = vtx[i1]-vtx[i0]; z02 = vtx[i2]-vtx[i0];\n                f.normal.setTo(y02*z01-y01*z02, z02*x01-z01*x02, x02*y01-x01*y02);\n                f.normal.normalize();\n            }\n            // calculate vertex normals\n            if (updateVertexNormal) {\n                istep = data32PerVertex - 2;\n                // initialize\n                for (i=0, i0=3; i<vcount; i++, i0+=istep) { vtx[i0]=0; i0++; vtx[i0]=0; i0++; vtx[i0]=0; }\n                // sum up\n                for (i=0; i<fcount; i++) {\n                    f = faces[i];\n                    i0 = f.i0 * data32PerVertex + 3;\n                    vtx[i0]+=f.normal.x; i0++; vtx[i0]+=f.normal.y; i0++; vtx[i0]+=f.normal.z;\n                    i0 = f.i1 * data32PerVertex + 3;\n                    vtx[i0]+=f.normal.x; i0++; vtx[i0]+=f.normal.y; i0++; vtx[i0]+=f.normal.z;\n                    i0 = f.i2 * data32PerVertex + 3;\n                    vtx[i0]+=f.normal.x; i0++; vtx[i0]+=f.normal.y; i0++; vtx[i0]+=f.normal.z;\n                }\n                //* normalize (ussualy normalizing by gpu).\n                for (i=0, i0=3; i<vcount; i++, i0+=istep) {\n                    x01 = vtx[i0]; i0++; y01 = vtx[i0]; i0++; z01 = vtx[i0]; i0-=2;\n                    iw = 1 / Math.sqrt(x01*x01 + y01*y01 + z01*z01);\n                    vtx[i0] = x01 * iw; i0++; vtx[i0] = y01 * iw; i0++; vtx[i0] = z01 * iw;\n                } //*/\n            }\n            return this;\n        }\n    }\n    \n    /** Face */\n    class Face {\n        public var i0:int, i1:int, i2:int, normal:Vector3D = new Vector3D();\n        function Face() { i0 = i1 = i2 = 0; }\n        static private var _freeList:Vector.<Face> = new Vector.<Face>();\n        static public function free(face:Face) : void { _freeList.push(face); }\n        static public function alloc(i0:int, i1:int, i2:int) : Face { \n            var f:Face = _freeList.pop() || new Face();\n            f.i0 = i0; f.i1 = i1; f.i2 = i2; return f;\n        }\n    }\n    \n    /** Light */\n    class Light extends Vector3D {\n        public var lightVector:Vector.<Number>  = new Vector.<Number>(4, true), halfVector:Vector.<Number>  = new Vector.<Number>(4, true);\n        private var _in :Vector.<Number> = new Vector.<Number>(6, true), _out:Vector.<Number> = new Vector.<Number>(6, true);\n        private var _lv3d:Vector3D  = new Vector3D(), _hv3d:Vector3D  = new Vector3D();\n        function Light(x:Number=1000, y:Number=1000, z:Number=1000) { super(x, y, z); halfVector[3] = lightVector[3] = 0; }\n        public function transform(sigl:SiGLCore) : void {\n            sigl.projectionMatrix.copyColumnTo(3, _hv3d);\n            _in[0] = x; _in[1] = y; _in[2] = z; _in[3] = _hv3d.x; _in[4] = _hv3d.y; _in[5] = _hv3d.z;\n            sigl.modelViewMatrix.inverted.transformVectors(_in, _out);\n            _lv3d.setTo(_out[0], _out[1], _out[2]); _lv3d.normalize(); _hv3d.setTo(_out[3], _out[4], _out[5]); _hv3d.normalize();\n            _hv3d.x += (lightVector[0] = _lv3d.x); _hv3d.y += (lightVector[1] = _lv3d.y); _hv3d.z += (lightVector[2] = _lv3d.z);\n            _hv3d.normalize(); halfVector[0] = _hv3d.x; halfVector[1] = _hv3d.y; halfVector[2] = _hv3d.z;\n        }\n    }\n    \n    /** Camera */\n    class Camera extends SiGLMatrix {\n        public var fromVector:Vector.<Number> = new Vector.<Number>(4, true), toVector:Vector.<Number> = new Vector.<Number>(4, true);\n        private var _in :Vector.<Number> = new Vector.<Number>(3, true), _out:Vector.<Number> = new Vector.<Number>(4, true), _cvdir:Boolean;\n        function Camera(x:Number=0, y:Number=0, z:Number=-300) { update(x, y, z); }\n        public function update(cx:Number, cy:Number, cz:Number, tx:Number=0, ty:Number=0, tz:Number=0, ux:Number=0, uy:Number=1, uz:Number=0) : Camera {\n            _in[0]=fromVector[0]=cx; _in[1]=fromVector[1]=cy; _in[2]=fromVector[2]=cz; fromVector[3]=1;\n            toVector[0]=tx;   toVector[1]=ty;   toVector[2]=tz;   toVector[3]=1;\n            lookAt(cx, cy, cz, tx, ty, tz, ux, uy, uz, 1);\n            _cvdir = true;\n            return this;\n        }\n        public function cameraVector(sigl:SiGLCore) : Vector.<Number> {\n            if (_cvdir) {\n                sigl.modelViewMatrix.inverted.transformVectors(_in, _out);\n                var l:Number = _out[0]*_out[0]+_out[1]*_out[1]+_out[2]*_out[2];\n                if (l!=0) l=1/Math.sqrt(l);\n                _out[0]*=l;_out[1]*=l;_out[2]*=l;_out[3]=1;\n                _cvdir = false;\n            }\n            return _out;\n        }\n    }\n    \n    /** flat shading material */\n    class FlatShadingMaterial {\n        private var _col:int, _alp:Number, _amb:Number, _dif:Number, _spc:Number, _pow:Number;\n        private var _specMap:BitmapData = new BitmapData(1024,1,false);\n        private var _ambVector:Vector.<Number> = new Vector.<Number>(4, true);\n        private var _difDifVector:Vector.<Number> = new Vector.<Number>(4, true);\n        public function set color(c:int) : void { setColor(c, _alp, _amb, _dif); }\n        public function get color() : int { return _col; }\n        public function set alpha(a:Number) : void { setColor(_col, a, _amb, _dif); }\n        public function get alpha() : Number { return _alp; }\n        public function set ambient(a:Number) : void { setColor(_col, _alp, a, _dif); }\n        public function get ambient() : Number { return _amb; }\n        public function set diffuse(d:Number) : void { setColor(_col, _alp, _amb, d); }\n        public function get diffuse() : Number { return _dif; }\n        public function set specular(s:Number) : void { setSpecular(s, _pow); }\n        public function get specular() : Number { return _spc; }\n        public function set power(p:Number) : void { setSpecular(_spc, p); }\n        public function get power() : Number { return _pow; }\n        public function get ambientVector() : Vector.<Number> { return _ambVector; }\n        public function get diffuseDifVector() : Vector.<Number> { return _difDifVector; }\n        public function get specMap() : BitmapData { return _specMap; }\n        function FlatShadingMaterial(color:int=0xffffff, alpha:Number=1, ambient:Number=0.25, diffuse:Number=0.75, specular:Number=0.75, power:Number=16) {\n            setColor(color, alpha, ambient, diffuse);\n            setSpecular(specular, power);\n        }\n        public function setColor(color:int, alpha:Number=1, ambient:Number=0.25, diffuse:Number=0.75) : FlatShadingMaterial {\n            _col = color; _alp = alpha; _amb = ambient; _dif = diffuse;\n            var r:Number = ((color>>16)&255)*0.00392156862745098, g:Number = ((color>>8)&255)*0.00392156862745098, b:Number = (color&255)*0.00392156862745098;\n            _ambVector[0] = r * ambient; _ambVector[1] = g * ambient; _ambVector[2] = b * ambient; _ambVector[3] = alpha;\n            _difDifVector[0] = r * diffuse - _ambVector[0]; _difDifVector[1] = g * diffuse - _ambVector[1]; _difDifVector[2] = b * diffuse - _ambVector[2]; _difDifVector[3] = alpha;\n            return this;\n        }\n        private function setSpecular(specular:Number=0.75, power:Number=16) : FlatShadingMaterial {\n            _spc = specular; _pow = power; specular *= 256;\n            for (var i:int=0; i<1024; i++) {\n                var c:int = int(Math.pow(i*0.0009775171065493646, power) * specular);\n                _specMap.setPixel32(i, 0, ((c<255)?c:255)*0x10101);\n            }\n            return this;\n        }\n    }\n    \n    /** Point Sprite Field */\n    class PointSpriteField extends Mesh {\n    // variables --------------------------------------------------\n        public var spriteCount:int, maxSpriteCount:int;\n    // constructor --------------------------------------------------\n        function PointSpriteField(context3D:Context3D, maxSpriteCount:int=1024) {\n            super(\"V3S2T2C4O4\");\n            vertexCount = (this.maxSpriteCount = maxSpriteCount) * 4;\n            spriteCount = 0;\n            for (var i:int=0, j:int=0; i<maxSpriteCount; i++) qface(j++, j++, j++, j++);\n            allocateBuffer(context3D);\n            upload();\n        }\n    // operations --------------------------------------------------\n        public function clearSprites() : PointSpriteField { spriteCount = 0; return this; }\n        public function createSprite(tex:PointSpriteTexInfo, x:Number, y:Number, z:Number=0, \n                                     mata:Number=1, matb:Number=0, matc:Number=0, matd:Number=1,\n                                     rmul:Number=1, gmul:Number=1, bmul:Number=1, amul:Number=1, \n                                     radd:Number=0, gadd:Number=0, badd:Number=0, aadd:Number=0) : PointSpriteField {\n            var wa:Number = tex.hw*mata, wc:Number = tex.hw*matc, hb:Number = tex.hh*matb, hd:Number = tex.hh*matd, \n                v0x:Number = -wa+hb, v0y:Number = -wc+hd, v1x:Number = wa+hb, v1y:Number = wc+hd, \n                i0:int = spriteCount*data32PerVertex*4, i1:int=i0+data32PerVertex, i2:int=i1+data32PerVertex, i3:int=i2+data32PerVertex;\n            if (spriteCount == maxSpriteCount) return this;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = x; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = y; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = z; i0++; i1++; i2++; i3++;\n            vertices[i3] = -(vertices[i0] = v0x); i0++; i3++;\n            vertices[i3] = -(vertices[i0] = v0y); i0++; i3++;\n            vertices[i2] = -(vertices[i1] = v1x); i1++; i2++;\n            vertices[i2] = -(vertices[i1] = v1y); i1++; i2++;\n            vertices[i0] = vertices[i2] = tex.u0; i0++; i2++;\n            vertices[i1] = vertices[i3] = tex.u1; i1++; i3++;\n            vertices[i0] = vertices[i1] = tex.v0; i0++; i1++;\n            vertices[i2] = vertices[i3] = tex.v1; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = rmul; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = gmul; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = bmul; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = amul; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = radd; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = gadd; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = badd; i0++; i1++; i2++; i3++;\n            vertices[i0] = vertices[i1] = vertices[i2] = vertices[i3] = aadd; i0++; i1++; i2++; i3++;\n            spriteCount++;\n            return this;\n        }\n        override public function drawTriangles(context3D:Context3D) : Mesh {\n            if (spriteCount) {\n                vertexBuffer.uploadFromVector(vertices, 0, spriteCount*4);\n                context3D.setVertexBufferAt(0, vertexBuffer,  0, Context3DVertexBufferFormat.FLOAT_3);\n                context3D.setVertexBufferAt(1, vertexBuffer,  3, Context3DVertexBufferFormat.FLOAT_2);\n                context3D.setVertexBufferAt(2, vertexBuffer,  5, Context3DVertexBufferFormat.FLOAT_2);\n                context3D.setVertexBufferAt(3, vertexBuffer,  7, Context3DVertexBufferFormat.FLOAT_4);\n                context3D.setVertexBufferAt(4, vertexBuffer, 11, Context3DVertexBufferFormat.FLOAT_4);\n                context3D.drawTriangles(indexBuffer, 0, spriteCount*2);\n                for (var i:int=0; i<5; i++) context3D.setVertexBufferAt(i, null, 0, \"float1\");\n            }\n            return this;\n        }\n    }\n\n    /** Point Sprite Texture Infomation */\n    class PointSpriteTexInfo {\n        public var u0:Number, v0:Number, u1:Number, v1:Number, hw:Number, hh:Number;\n        function PointSpriteTexInfo(u0:Number, v0:Number, u1:Number, v1:Number, width:Number, height:Number) {\n            this.u0 = u0; this.v0 = v0; this.u1 = u1; this.v1 = v1; this.hw = width * 0.5; this.hh = height * 0.5;\n        }\n    }\n}","modified_date":1346686426,"compile_ok":"1","created_date":1346335976,"forked_count":"11","license":"MIT","swf":"http://swf.wonderfl.net/swf/usercode/9/9e/9e0f/9e0ff05badf4a63a0eb27b766820b92604cdbfd6.swf","diff":"0","user":{"icon":"http://wonderfl.net/images/icon/2/27/278a/278afc585a0a283d6e1f13f081cfd9c377ab9db2m","name":"keim_at_Si"},"title":"GIMMICK - FANTAISIE IMPROMPTU -","id":"myhA","favorite_count":"81"},"stat":"ok"}