{"code":{"thumbnail":"http://wonderfl.net/images/capture/9/95/9517/951725c9ff872ff98533c31316d3e6a1cc7ccadf_100.jpg?t=1342717583","parent":null,"as3":"package {\n    import flash.display.*;\n    import flash.desktop.*;\n    import flash.events.*;\n    import flash.media.*;\n    import flash.utils.*;\n    import flash.geom.*;\n    import flash.text.*;\n    import flash.net.*;\n    \n    import com.bit101.components.*;\n    import org.si.utils.*;\n    import org.si.sion.utils.*;\n    import org.si.sion.utils.soundfont.*;\n    import org.si.sion.*;\n    import org.si.sion.module.*;\n    \n    \n    public class main extends Sprite {\n        private const SO_VERSION:String = \"1\";\n        \n        private var sampleCountIndex:int = 1;\n        private var sampleCounts:Array = [32, 64];\n        private var sampleCount:int = 64;\n        private var barWidth:Number = 6; //384/sampleCount;\n        \n        private var bitCountIndex:int = 3;\n        private var bitCounts:Array = [4,5,6,8];\n        private var envelopeType:int = 1;\n        private var pickupWidth:int = 6;\n        \n        private var sion:SiONDriver;\n        private var envMML:Vector.<String> = new Vector.<String>();\n        private var waveShape:Vector.<Number> = new Vector.<Number>(64);\n        private var stacArea:Vector.<Vector.<Number>>;\n        private var history:Array = [];\n        \n        private var mmlInput:InputText;\n        private var hexWindow:Window;\n        private var hexWindowText:TextField;\n        private var hexWindowCopyButton:PushButton;\n        private var hexWindowUpdateButton:PushButton;\n        \n        private var pixels:BitmapData;\n        private var bitmap:Bitmap;\n        private var screen:Sprite;\n        private var shapeLayer:Shape;\n        private var pointerIndex:int, pointerRange:int;\n        private var pointerChanged:Boolean, screenDragMode:int;\n        private var rangeOperator:Number, rangeFunction:Function;\n        private var pickupStartPosition:Number;\n        private var stacBitmaps:Vector.<Bitmap>;\n        private var rc:Rectangle = new Rectangle();\n        \n        \n        function main() {\n            addEventListener(Event.ADDED_TO_STAGE, setup);\n        }\n        \n    // main --------------------------------------------------\n        private function setup(e:Event) : void {\n            removeEventListener(e.type, arguments.callee);\n\n            graphics.beginFill(0);\n            graphics.drawRect(0,0,465,465);\n            graphics.endFill();\n            \n            Style.BACKGROUND = 0x404040;\n            Style.BUTTON_FACE = 0x606060;\n            Style.LABEL_TEXT = 0xaaaaaa;\n            Style.INPUT_TEXT = 0xaaaaaa;\n            Style.DROPSHADOW = 0;\n            Style.PANEL = 0x303030;\n            Style.PROGRESS_BAR = 0x404040;\n            \n            var i:int, j:int;\n            pixels = new BitmapData(384, 260, false);\n            bitmap = new Bitmap(pixels);\n            screen = new Sprite();\n            stacBitmaps = new Vector.<Bitmap>(8);\n            stacArea = new Vector.<Vector.<Number>>(8);\n            for (i=0; i<8; i++) {\n                stacArea[i] = new Vector.<Number>(64);\n                stacBitmaps[i] = new Bitmap(new BitmapData(62, 18, false, 0));\n                addChild(stacBitmaps[i]);\n            }\n            \n            shapeLayer = new Shape();\n            screen.addChild(bitmap);\n            screen.addChild(shapeLayer);\n            screen.x = 8;\n            screen.y = 4;\n            addChild(screen);\n            addEventListener(Event.ENTER_FRAME, draw);\n            \n            screenDragMode = 0;\n            pointerIndex = 0;\n            pointerRange = 0;\n            pointerChanged = true;\n            pickupStartPosition = 0;\n            rangeOperator = 0;\n            rangeFunction = $offset;\n            \n            envMML.length = 5;\n            envMML[0] = \"%4@0,63,0,0,63,15\";\n            envMML[1] = \"%4@0,63,16,16,16,15\"; // long\n            envMML[2] = \"%4@0,63,24,24,24,15\"; // middle\n            envMML[3] = \"%4@0,63,36,36,36,15\"; // short\n            envMML[4] = \"%4@0,26,0,0,63,15\";  // soft attack\n            \n            _loadSharedObject();\n            for (i=0; i<sampleCount; i++) waveShape[i] = Math.sin((i+0.5)*Math.PI*2/sampleCount);\n            \n            _setButtons();\n            screen.addEventListener(MouseEvent.MOUSE_DOWN, _onDragStart);\n            \n            sion = new SiONDriver();\n        }\n        \n        \n        private function draw(e:Event) : void {\n            var sample:Vector.<Number> = _calcCurrentSample();\n            var i:int, imin:int, imax:int, g:Graphics = shapeLayer.graphics;\n            imin = pointerIndex + ((pointerRange < 0) ? pointerRange : 0);\n            imax = pointerIndex + ((pointerRange > 0) ? pointerRange : 0) + 1;\n            if (imin < 0) imin = 0;\n            if (imax > sampleCount) imax = sampleCount;\n            _rect(0, 0, 384, 260, 0x404040);\n            for (i=1; i<4; i++) {\n                _rect(i*96-1, 0, 1, 260, 0x408040);\n            }\n            for (i=0; i<sampleCount; i++) {\n                _rect(i*barWidth, 130, barWidth-1, -sample[i]*128, 0x80f0c0);\n                if (i<imin || imax<=i) _rect(i*barWidth, -sample[i]*128+128, barWidth-1, 4, 0xf08080);\n            }\n            _rect(imin*barWidth, -rangeOperator*128+128, (imax-imin)*barWidth-1, 4, 0x8080f0);\n            if (pointerChanged) {\n                g.clear();\n                g.lineStyle(2, 0xff0000);\n                g.beginFill(0xffffff, 0.25);\n                g.drawRect(imin*barWidth-1, -1, (imax-imin)*barWidth-1, 262);\n                pointerChanged = false;\n            }\n        }\n        \n        \n    // drawing sub routines --------------------------------------------------\n        private function _rect(x:Number, y:Number, w:Number, h:Number, c:uint) : void {\n            if (h<0) y-=(h=-h);\n            rc.setTo(x, y, w, h);\n            pixels.fillRect(rc, c);\n        }\n        \n        \n        private function _drawMiniWaveImage(pix:BitmapData, wav:Vector.<Number>) : void {\n            rc.setTo(0,0,62,18);\n            pix.fillRect(rc, 0x808080);\n            rc.setTo(1,1,60,16);\n            pix.fillRect(rc, 0);\n            var imin:int = (sampleCount==32) ? 1 : 2, imax:int = sampleCount-imin, \n                pitch:Number=64/sampleCount;\n            for (var i:int=imin; i<imax; i++) {\n                if (wav[i] < 0) rc.setTo((i-1)*pitch+1, 9,          pitch, -wav[i]*8);\n                else            rc.setTo((i-1)*pitch+1, 9-wav[i]*8, pitch,  wav[i]*8);\n                pix.fillRect(rc, 0x4080c0);\n                rc.y  = 9 - wav[i]*8;\n                rc.height = 1;\n                pix.fillRect(rc, 0xc08040);\n            }\n        }\n        \n        \n    // sub routines --------------------------------------------------\n        private var _temp32:Vector.<Number> = new Vector.<Number>(32);\n        private var _temp64:Vector.<Number> = new Vector.<Number>(64);\n        private function _applyRangeFunction(func:Function) : void {\n            var i:int, imin:int, imax:int, istart:int, iend:int;\n            imin = pointerIndex + ((pointerRange < 0) ? pointerRange : 0);\n            imax = pointerIndex + ((pointerRange > 0) ? pointerRange : 0) + 1;\n            istart = (0>imin) ? 0 : imin;\n            iend = (sampleCount<imax) ? sampleCount : imax;\n            for (i=istart; i<iend; i++) {\n                _temp64[i] = func(i, imin, imax);\n                if (_temp64[i] > 1) _temp64[i] = 1;\n                else if (_temp64[i] < -1) _temp64[i] = -1;\n            }\n            _stacHistory();\n            for (i=istart; i<iend; i++) waveShape[i] = _temp64[i];\n        }\n\n        \n        private function _loadSharedObject() : void {\n            var so:SharedObject = SharedObject.getLocal(\"WMS_EDITOR\"), i:int, si:int;\n            if (so && so.data.version == SO_VERSION) {\n                if (so.data.stacArea) {\n                    for (si=0; si<8; si++) for (i=0; i<64; i++) stacArea[si][i] = so.data.stacArea[si][i];\n                }\n                if (so.data.sampleCountIndex) {\n                    sampleCountIndex = so.data.sampleCountIndex;\n                    sampleCount = sampleCounts[sampleCountIndex];\n                    barWidth = 384/sampleCount;\n                }\n                if (so.data.bitCountIndex) bitCountIndex = so.data.bitCountIndex;\n                if (so.data.envelopeType)  envelopeType = so.data.envelopeType;\n            } else {\n                for (si=0; si<8; si++) for (i=0; i<64; i++) stacArea[si][i] = 0;\n            }\n            for (si=0; si<8; si++) {\n                _drawMiniWaveImage(stacBitmaps[si].bitmapData, stacArea[si]);\n            }\n        }\n        \n        private function _saveSampleData() : void {\n            var so:SharedObject = SharedObject.getLocal(\"WMS_EDITOR\");\n            if (so) {\n                so.data.version = SO_VERSION;\n                so.data.stacArea = stacArea;\n                so.flush();\n            }\n        }\n        \n        private function _saveSettings() : void {\n            var so:SharedObject = SharedObject.getLocal(\"WMS_EDITOR\");\n            if (so) {\n                so.data.sampleCountIndex = sampleCountIndex;\n                so.data.bitCountIndex = bitCountIndex;\n                so.data.envelopeType = envelopeType;\n                so.flush();\n            }\n        }\n        \n        private function _stacHistory() : void {\n            var s:Vector.<Number>, i:int;\n            if (history.length > 0) {\n                s = history[history.length-1];\n                for (i=0; i<sampleCount; i++) if (s[i] != waveShape[i]) break;\n                if (i == sampleCount) return;\n            }\n            s = new Vector.<Number>(sampleCount);\n            for (i=0; i<sampleCount; i++) s[i] = waveShape[i];\n            history.push(s);\n        }\n        \n        private function _undo() : void {\n            var s:Vector.<Number> = history.pop(), i:int;\n            if (s) for (i=s.length-1; i>=0; i--) waveShape[i] = s[i];\n            else   for (i=0; i<sampleCount; i++) waveShape[i] = 0;\n        }\n        \n        private function _checkSound(e:Event) : void {\n            sion.setWaveTable(0, _calcCurrentSample());\n            sion.play(envMML[envelopeType] + mmlInput.text);\n        }\n        \n        private function _calcCurrentSample() : Vector.<Number> {\n            var i:int, imin:int, imax:int, t:Number, sample:Vector.<Number> = (sampleCount==32) ? _temp32 : _temp64;\n            var resolution:Number = 1 << bitCounts[bitCountIndex];\n            imin = pointerIndex + ((pointerRange < 0) ? pointerRange : 0);\n            imax = pointerIndex + ((pointerRange > 0) ? pointerRange : 0) + 1;\n            \n            var func:Function = (screenDragMode == 1) ? $pickup : rangeFunction;\n            for (i=0; i<sampleCount; i++) {\n                t = (pointerRange==0 || i<imin || imax<=i) ? waveShape[i] : func(i, imin, imax);\n                if (t > 1) t = 1;\n                else if (t < -1) t = -1;\n                sample[i] = (int((t+1)*0.5*resolution+0.5)) * 2 / resolution - 1;\n            }\n            \n            return sample;\n        }\n        \n        \n    // mouse event --------------------------------------------------\n        private function _onDragStart(e:MouseEvent) : void {\n            var i:int, imin:int, imax:int, pos:Number;\n            stage.addEventListener(MouseEvent.MOUSE_MOVE, _onDragging);\n            stage.addEventListener(MouseEvent.MOUSE_UP, _onDragEnd);\n            imin = pointerIndex + ((pointerRange < 0) ? pointerRange : 0);\n            imax = pointerIndex + ((pointerRange > 0) ? pointerRange : 0) + 1;\n            _calcCurrentPosition();\n            pos = rangeOperator;\n            if (pointerRange != 0 && imin <= currentIndex && currentIndex < imax && pos-0.15<currentValue && currentValue<pos+0.15) {\n                screenDragMode = 2; // drag range operator\n            } else {\n                if (pointerRange != 0) _applyRangeFunction(rangeFunction);\n                rangeOperator = 0;\n                pos = waveShape[currentIndex];\n                if (pos-0.15 < currentValue && currentValue < pos+0.15) {\n                    screenDragMode = 1;  // pick up mode\n                    rangeOperator = pickupStartPosition = pos;\n                    pointerIndex = currentIndex - (pickupWidth>>1);\n                    pointerRange = pickupWidth;\n                    _stacHistory();\n                } else {\n                    screenDragMode = 3; // change range\n                    if (imin-1 <= currentIndex && currentIndex <= imin+1) {\n                        pointerIndex = imax - 1;\n                        pointerRange = imin - imax;\n                    } else \n                    if (imax-1 <= currentIndex && currentIndex <= imax+1) {\n                        pointerIndex = imin;\n                        pointerRange = imin - imax;\n                    } else {\n                        pointerIndex = currentIndex;\n                        pointerRange = 0;\n                    }\n                }\n            }\n            pointerChanged = true;\n            _onDragging(e);\n        }\n        \n        \n        private function _onDragging(e:MouseEvent) : void {\n            _calcCurrentPosition();\n            switch(screenDragMode) {\n            case 1:\n            case 2:\n                rangeOperator = currentValue;\n                break;\n            case 3:\n                pointerChanged = true;\n                pointerRange = currentIndex - pointerIndex;\n                break;\n            }\n        }\n        \n        \n        private function _onDragEnd(e:MouseEvent) : void {\n            _onDragging(e);\n            switch(screenDragMode) {\n            case 1:\n                _applyRangeFunction($pickup);\n                pickupStartPosition = rangeOperator = 0;\n                pointerIndex += pickupWidth>>1;\n                pointerRange = 0;\n                break;\n            case 3:\n                pointerChanged = true;\n                pointerRange = currentIndex - pointerIndex;\n                break;\n            }\n            pointerChanged = true;\n            screenDragMode = 0;\n            stage.removeEventListener(MouseEvent.MOUSE_MOVE, _onDragging);\n            stage.removeEventListener(MouseEvent.MOUSE_UP, _onDragEnd);\n        }\n        \n        \n        private var currentIndex:int, currentValue:Number;\n        private function _calcCurrentPosition() : void {\n            currentIndex = int(screen.mouseX / barWidth);\n            currentValue = Number((screen.mouseY-128) * -0.0078125);\n                 if (currentIndex < 0)  currentIndex = 0;\n            else if (currentIndex > sampleCount-1) currentIndex = sampleCount-1;\n                 if (currentValue < -1) currentValue = -1;\n            else if (currentValue > 1)  currentValue = 1;\n        }\n        \n        \n        private function get hexString() : String {\n            var str:String = \"\", i:int, s:int, wav:Vector.<Number> = _calcCurrentSample();\n            for (i=0; i<sampleCount; i++) {\n                s = (wav[i]+1) * 128;\n                s = (s<128) ? (s+128) : (s<256) ? (s-128) : 127;\n                str += (\"0\" + s.toString(16)).substr(-2, 2);\n            }\n            return str;\n        }\n        private function set hexString(str:String) : void {\n            var hexLength:int = str.length >> 1, i:int, n:Number, \n                imax:int = (hexLength<64) ? hexLength : 64;\n            for (i=0; i<imax; i++) {\n                n = parseInt(str.substr(i*2, 2), 16); // 1/128                \n                waveShape[i] = (n<128) ? (n * 0.0078125) : ((n-256) * 0.0078125);\n            }\n        }\n        \n        \n    // interfaces --------------------------------------------------\n        private var buttonSelector:Shape;\n        private var buttonX:Number, buttonY:Number;\n        private function _setButtons() : void {\n            var i:int;\n            \n            var test:PushButton = new PushButton(this, 8, 268, \"Check sound !!\", _checkSound);\n            test.width = 318;\n            test.height = 22;\n            mmlInput = new InputText(this, 328, 269, \"cdefgab<c1\");\n            mmlInput.width = 126;\n            mmlInput.height = 20;\n            \n            buttonX = 396;\n            buttonY = 4;\n            _label(\"[Sample count]\");\n            _radios($changeSampleCount, \"Sample count\", [\"32samples\", \"64samples\"], sampleCountIndex);\n            _label(\"[Bit count]\");\n            _radios($changeBitCount, \"Bit count\", [\"4 bits\", \"5 bits\", \"6 bits\", \"8 bits\"], bitCountIndex);\n            _label(\"[Envelop type]\");\n            _radios($changeEnvelopeType, \"Envelop type\", [\"constant\", \"long\", \"middle\", \"short\", \"soft attack\"], envelopeType);\n            \n            buttonX = 8;\n            buttonY = 294;\n            _buttonImm(\"zero fill \", $clear);\n            _buttonImm(\"linear\", $linear);\n            _buttonImm(\"half cos\", $cosine);\n            _buttonImm(\"triangle\", $triangle);\n            _buttonImm(\"sine\", $sine);\n            _buttonImm(\"square\", $square);\n            _buttonImm(\"random\", $random);\n            \n            buttonX = 8;\n            buttonY += 24;\n            _slider($pickupWidth, [\"PW:1\", \"PW:3\", \"PW:5\", \"PW:7\", \"PW:9\", \"PW:11\", \"PW:13\", \"PW:15\", \"PW:17\"], 3);\n            _buttonImm(\"UNDO\",   $undo);\n            _buttonImm(\"SELECT_ALL\", $selectAll, 128);\n            _buttonImm(\"HEX WINDOW\", $hexWindow, 128);\n\n            buttonX = 8;\n            buttonY += 20;\n            _buttonImm(\"COPY\",   $copy);\n            _buttonImm(\"PASTE\",  $paste);\n            _buttonImm(\"INVERT\",  $invert);\n            _buttonImm(\"REVERSE\", $reverse);\n            _buttonImm(\"MAXIMIZE\", $maximize);\n            buttonX += 64;\n            buttonY += 4;\n            _buttonImm(\"Reset cbar\", $barReset, 64, false);\n            \n            buttonX = 8;\n            buttonY += 20;\n            _buttonImm(\">> Operator\", $$stac(7));\n            stacBitmaps[7].x = buttonX;\n            stacBitmaps[7].y = buttonY;\n            buttonX += 64;\n            _slider($mult, [\"ml=1\", \"ml=2\", \"ml=3\", \"ml=4\", \"ml=5\", \"ml=6\", \"ml=7\", \"ml=8\"]);\n            _button(\"Blend...\",    $blend);\n            _button(\"Ring mod...\", $ring);\n            _button(\"Freq.mod...\", $phase);\n            \n            buttonX = 8;\n            buttonY += 20;\n            var offsetButton:PushButton = _button(\"Offset...\",  $offset);\n            _button(\"Scale...\",   $scale);\n            _button(\"Stretch...\", $stretch);\n            _button(\"Inflate...\", $shaper);\n            _button(\"Pinch...\",   $pinch);\n            _button(\"Rotate...\",  $rotate);\n            _button(\"Terrible...\",$terrible);\n            \n            buttonX = 8;\n            buttonY += 44;\n            for (i=0; i<7; i++) {\n                stacBitmaps[i].x = buttonX;\n                stacBitmaps[i].y = buttonY-20;\n                _buttonImm(\">> Memory\", $$stac(i));\n            }\n            buttonX = 8;\n            buttonY += 20;\n            for (i=0; i<7; i++) {\n                _buttonImm(\"<< Remem.\", $$pick(i));\n            }\n            \n            hexWindow = new Window(this, 50, 150, \"hex\");\n            hexWindow.visible = false;\n            hexWindow.draggable = false;\n            hexWindow.hasCloseButton = true;\n            hexWindow.width  = 465-hexWindow.x*2;\n            hexWindow.height = 465-hexWindow.y*2;\n            hexWindow.addEventListener(Event.CLOSE, _onHexWindowClosed);\n            hexWindowText = new TextField();\n            hexWindowText.defaultTextFormat = new TextFormat(\"_sans\", 12, Style.INPUT_TEXT);\n            hexWindowText.x = 2;\n            hexWindowText.y = 2;\n            hexWindowText.width  = hexWindow.width - 4;\n            hexWindowText.height = hexWindow.height - 66;\n            hexWindowText.background = true;\n            hexWindowText.backgroundColor = 0;\n            hexWindowText.multiline = true;\n            hexWindowText.wordWrap = true;\n            hexWindowText.selectable = true;\n            hexWindowText.type = TextFieldType.INPUT;\n            hexWindow.content.addChild(hexWindowText);\n            hexWindowUpdateButton = new PushButton(hexWindow.content, 2, hexWindow.height-62, \"Update data from HEX\", onUpdateHex);\n            hexWindowCopyButton   = new PushButton(hexWindow.content, 2, hexWindow.height-42, \"Send HEX to clipboard\", onCopyHex);\n            hexWindowUpdateButton.width  = hexWindowCopyButton.width = hexWindowText.width;\n            hexWindowUpdateButton.height = hexWindowCopyButton.height = 20;\n            \n            buttonSelector = new Shape();\n            buttonSelector.graphics.beginFill(0x4080ff, 0.25);\n            buttonSelector.graphics.drawRect(0,0,62,20);\n            buttonSelector.graphics.endFill();\n            buttonSelector.x = offsetButton.x;\n            buttonSelector.y = offsetButton.y;\n            addChild(buttonSelector);\n            \n            _stac = stacArea[7];\n        }\n        private function _label(lbl:String) : Label {\n            var label:Label = new Label(this, buttonX, buttonY, lbl);\n            label.width = 64;\n            label.height = 18;\n            buttonY += 20;\n            return label;\n        }\n        private function _button(lbl:String, func:Function) : PushButton {\n            var pb:PushButton = new PushButton(this, buttonX, buttonY, lbl, $(func));\n            buttonX += 64;\n            pb.width = 62;\n            pb.height = 18;\n            return pb;\n            function $(func:Function) : Function {\n                return function(e:Event) : void {\n                    if (pointerRange != 0) _applyRangeFunction(rangeFunction);\n                    rangeOperator = 0;\n                    buttonSelector.x = e.target.x;\n                    buttonSelector.y = e.target.y;\n                    rangeFunction = func;\n                };\n            }\n        }\n        private function _buttonImm(lbl:String, immidiateAction:Function, w:Number=64, applyRangeFunc:Boolean=true) : PushButton {\n            var pb:PushButton = new PushButton(this, buttonX, buttonY, lbl, $(immidiateAction, applyRangeFunc));\n            buttonX += w;\n            pb.width = w - 2;\n            pb.height = 18;\n            return pb;\n            function $(func:Function, apply:Boolean) : Function {\n                return function(e:Event) : void {\n                    if (apply && pointerRange != 0) {\n                        _applyRangeFunction(rangeFunction);\n                        rangeOperator = 0;\n                    }\n                    var imin:int = pointerIndex + ((pointerRange < 0) ? pointerRange : 0),\n                        imax:int = pointerIndex + ((pointerRange > 0) ? pointerRange : 0) + 1;\n                    immidiateAction(imin, imax);\n                };\n            }\n        }\n        private function _slider(action:Function, labels:Array, initValue:int=0) : HSlider {\n            var slider:HSlider = new HSlider(this, buttonX+32, buttonY+1, $(action, new Label(this, buttonX+2, buttonY, labels[initValue])));\n            slider.width = 94;\n            slider.height = 16;\n            slider.setSliderParams(0, labels.length-0.1, initValue);\n            buttonX += 128;\n            return slider;\n            function $(func:Function, label:Label) : Function { \n                return function(e:Event) : void {\n                    var index:int = int(e.target.value);\n                    label.text = labels[index];\n                    func(index);\n                };\n            }\n        }\n        private function _radios(action:Function, groupName:String, labels:Array, checkedIndex:int) : Array {\n            var rad:RadioButton, handler:Function = $(action, labels), ret:Array = [];\n            for (var i:int=0; i<labels.length; i++) {\n                rad = new RadioButton(this, buttonX, buttonY, labels[i], (checkedIndex==i), handler);\n                rad.groupName = groupName;\n                rad.width = 64;\n                rad.height = 16;\n                buttonY += 18;\n                ret.push(rad);\n            }\n            return ret;\n            function $(action:Function, labels:Array) : Function {\n                return function(e:Event) : void { \n                    var i:int, imax:int = labels.length;\n                    for (i=0; i<imax; i++) if (e.target.label == labels[i]) {\n                        action(i);\n                        return;\n                    }\n                }\n            };\n        }\n        \n        \n    // actions --------------------------------------------------\n        // global\n        private function $changeSampleCount(index:int) : void {\n            if (sampleCountIndex != index) {\n                sampleCountIndex = index;\n                sampleCount = sampleCounts[index];\n                barWidth = 384/sampleCount;\n                if (pointerIndex > sampleCount) {\n                    pointerIndex = sampleCount - 1;\n                    pointerRange = 0;\n                } else \n                if (pointerIndex + pointerRange >= sampleCount) {\n                    pointerRange = sampleCount - pointerIndex - 1;\n                }\n                pointerChanged = true;\n                \n                for (var si:int=0; si<8; si++) {\n                    _drawMiniWaveImage(stacBitmaps[si].bitmapData, stacArea[si]);\n                }\n                _saveSettings();\n                _saveSampleData();\n            }\n        }\n        private function $changeBitCount(index:int) : void {\n            bitCountIndex = index;\n            _saveSettings();\n        }\n        private function $changeEnvelopeType(index:int) : void {\n            envelopeType = index;\n            _saveSettings();\n        }\n        \n        private function $pickup(i:int, imin:int, imax:int) : Number {\n            var n:Number = rangeOperator - pickupStartPosition,\n//              r:Number = 2/(imax-imin+1)*((i+i<=imax+imin)?(i-imin+1):(imax-i)); // linear\n                r:Number = -Math.cos(Math.PI*2*(i-imin+1)/(imax-imin+1))*0.5+0.5; // cosine\n            return waveShape[i] + n*r;\n        }\n\n        // actions controled by rangeOperator\n        private function $offset(i:int, imin:int, imax:int) : Number { return waveShape[i] + rangeOperator; }\n        private function $scale(i:int, imin:int, imax:int) : Number { return waveShape[i] * (rangeOperator+1); }\n        private function $stretch(i:int, imin:int, imax:int) : Number {\n            var imid:Number = (imax+imin-1)*0.5,\n                c:Number = (i - imid) * Math.pow(8,rangeOperator) + imid, ic:int = int((c<0) ? (c-1) : c), \n                r:Number = c - ic, ic32:int = ic & (sampleCount - 1);\n            return waveShape[ic32]*(1-r) + waveShape[(ic32+1)&(sampleCount-1)]*r;\n        }\n        private function $shaper(i:int, imin:int, imax:int) : Number {\n            var r1:Number = rangeOperator+1.0000152587890625;\n            return (waveShape[i]<0) ? -Math.pow(-waveShape[i],r1*r1) : Math.pow(waveShape[i],r1*r1);\n        }\n        private function $pinch(i:int, imin:int, imax:int) : Number {\n            var pt:Number, hw:Number, n:Number, t:Number = (i-imin)/(imax-imin-1);\n            if (rangeOperator<0) {\n                pt = -rangeOperator*10;\n                t = (t < 0.5) ? (t + 0.5) : (t - 0.5);\n            } else {\n                pt = rangeOperator*10;\n            }\n            hw = 1/(pt+2);\n                 if (t < hw)   n = pt * (-0.5/hw * t + 1 - hw) * t;\n            else if (t < 1-hw) n = pt * hw * (0.5 - t);\n            else               n = pt * ((0.5/hw * t + 1 - hw - 1/hw) * t -1 + hw + 0.5/hw);\n            var c:Number = i + n * sampleCount, ic:int = int((c<0) ? (c-1) : c), \n                r:Number = c - ic, ic32:int = ic & (sampleCount - 1);\n            return waveShape[ic32]*(1-r) + waveShape[(ic32+1)&(sampleCount-1)]*r;\n        }\n        private function $rotate(i:int, imin:int, imax:int) : Number {\n            var n:Number = i + (rangeOperator+0.0000152587890625) * (imax-imin);\n            var index:int = int((n<0)?(n-1):n);\n            if (index < imin) index += imax-imin;\n            else if (index >= imax) index -= imax-imin;\n            return waveShape[index];\n        }\n        private function $terrible(i:int, imin:int, imax:int) : Number {\n            return waveShape[i] *(1+((rangeOperator<0)?rangeOperator:-rangeOperator)) + ((i&1)*2-1) * rangeOperator;\n        }\n        \n        // immidiate actions\n        private var _clip:Vector.<Number> = new Vector.<Number>();\n        private function $clear (imin:int, imax:int) : void { for (var i:int=imin; i<imax; i++) waveShape[i] = 0; }\n        private function $copy(imin:int, imax:int) : void {\n            var i:int, ci:int, cimax:int = imax - imin;\n            _clip.length = cimax;\n            for (i=imin, ci=0; ci<cimax; i++, ci++) _clip[ci] = waveShape[i];\n        }\n        private function $paste(imin:int, imax:int) : void {\n            var i:int, ci:int, cimax:int = _clip.length;\n            if (cimax == 0) return;\n            if (imax - imin < 2) imax = (imin+cimax<sampleCount) ? (imin+cimax) : sampleCount;\n            for (i=imin, ci=0; i<imax; i++, ci++) waveShape[i] = _clip[ci%cimax];\n        }\n        private function $selectAll(imin:int, imax:int) : void {\n            pointerIndex = 0;\n            pointerRange = sampleCount - 1;\n            pointerChanged = true;\n        }\n        private function $undo(imin:int, imax:int) : void {\n            pointerRange = 0;\n            pointerChanged = true;\n            _undo();\n        }\n        private function $hexWindow(imin:int, imax:int) : void {\n            hexWindowText.text = hexString;\n            hexWindow.visible = true;\n        }\n        private function onUpdateHex(e:Event) : void {\n            hexString = hexWindowText.text;\n            hexWindow.visible = false;\n        }\n        private function onCopyHex(e:Event) : void {\n            Clipboard.generalClipboard.setData(ClipboardFormats.TEXT_FORMAT, hexWindowText.text);\n            hexWindow.visible = false;\n        }\n        private function _onHexWindowClosed(e:Event): void {\n            hexWindow.visible = false;\n        }\n        \n        \n        private function $invert(imin:int, imax:int) : void { for (var i:int=imin; i<imax; i++) waveShape[i] = -waveShape[i]; }\n        private function $reverse(imin:int, imax:int) : void {\n            var i:int, j:int=imax-1, n:Number;\n            imax = ((imax - imin) >> 1) + imin;\n            for (i=imin; i<imax; i++, j--) {\n                n = waveShape[j];\n                waveShape[j] = waveShape[i];\n                waveShape[i] = n;\n            }\n        }\n        private function $maximize(imin:int, imax:int) : void {\n            var i:int, max:Number = 0;\n            for (i=imin; i<imax; i++) {\n                     if (max <  waveShape[i]) max =  waveShape[i];\n                else if (max < -waveShape[i]) max = -waveShape[i];\n            }\n            max = (max == 0) ? 0 : (1/max);\n            for (i=imin; i<imax; i++) waveShape[i] *= max;\n        }\n        private function $pickupWidth(index:int) : void {\n            pickupWidth = index * 2;\n        }\n        \n        private var _stac:Vector.<Number> // = stacArea[7];\n        private var _mul:Number = 1;\n        private function $blend(i:int, imin:int, imax:int) : Number {\n            var si:int = (i * _mul) & (sampleCount - 1);\n            return waveShape[i] * (1+((rangeOperator<0)?rangeOperator:-rangeOperator)) + _stac[si] * rangeOperator;\n        }\n        private function $ring(i:int, imin:int, imax:int) : Number {\n            var si:int = (i * _mul) & (sampleCount - 1);\n            return waveShape[i] * ((rangeOperator<0)?(1+(1+_stac[si])*rangeOperator):(1-(1-_stac[si])*rangeOperator));\n        }\n        private function $phase(i:int, imin:int, imax:int) : Number {\n            var si:int = (i * _mul) & (sampleCount - 1),\n                c:Number = i + _stac[si] * rangeOperator * sampleCount, ic:int = int((c<0) ? (c-1) : c), \n                r:Number = c - ic, ic32:int = ic & (sampleCount - 1);\n            return waveShape[ic32]*(1-r) + waveShape[(ic32+1)&(sampleCount-1)]*r;\n        }\n        private function $mult(i:int) : void {\n            _mul = i+1;\n        }\n        private function $barReset(imin:int, imax:int) : void {\n            rangeOperator = 0;\n        }\n\n        // stac area operation\n        private function $$stac(stacIndex:int) : Function {\n            return function(imin:int, imax:int) : void {\n                var i:int, s:Vector.<Number>=stacArea[stacIndex];\n                for (i=0; i<sampleCount; i++) s[i] = waveShape[i];\n                _saveSampleData();\n                _drawMiniWaveImage(stacBitmaps[stacIndex].bitmapData, s);\n            };\n        }\n        private function $$pick(stacIndex:int) : Function {\n            return function(imin:int, imax:int) : void {\n                _stacHistory();\n                var i:int, s:Vector.<Number>=stacArea[stacIndex];\n                for (i=0; i<sampleCount; i++) waveShape[i] = s[i];\n            };\n        }\n        \n        // patch wave\n        private function $linear(imin:int, imax:int) : void {\n            if (imax - imin < 2) return;\n            var i:int, n:Number = 2/(imax-imin-1);\n            for (i=imin; i<imax; i++) waveShape[i] = 1-((i-imin)*n);\n            \n        }\n        private function $cosine(imin:int, imax:int) : void {\n            if (imax - imin < 2) return;\n            var i:int, n:Number = Math.PI/(imax-imin-1);\n            for (i=imin; i<imax; i++) waveShape[i] = Math.cos((i-imin)*n);\n        }\n        private function $sine(imin:int, imax:int) : void {\n            if (imax - imin < 2) return;\n            var i:int, n:Number = Math.PI*2/(imax-imin);\n            for (i=imin; i<imax; i++) waveShape[i] = Math.sin((i-imin+0.5)*n);\n        }\n        private function $triangle(imin:int, imax:int) : void {\n            if (imax - imin < 2) return;\n            var i:int, n:Number = 4/(imax-imin), m:Number;\n            for (i=imin; i<imax; i++) {\n                m = (i-imin+0.5) * n;\n                waveShape[i] = (m<1)?m:(m<3)?(2-m):(m-4);\n            }\n        }\n        private function $square(imin:int, imax:int) : void {\n            var i:int, imid:int = (imax+imin)>>1;\n            for (i=imin; i<imax; i++) waveShape[i] = (i<imid)? 1:-1;\n        }\n        private function $random(imin:int, imax:int) : void {\n            for (var i:int=imin; i<imax; i++) waveShape[i] = Math.random() * 2 - 1;\n        }\n    }\n}\n\n","modified_date":1342544618,"compile_ok":"1","created_date":1342544010,"forked_count":"3","license":"MIT","swf":"http://swf.wonderfl.net/swf/usercode/9/95/9517/951725c9ff872ff98533c31316d3e6a1cc7ccadf.swf","diff":"0","user":{"icon":"http://wonderfl.net/images/icon/2/27/278a/278afc585a0a283d6e1f13f081cfd9c377ab9db2m","name":"keim_at_Si"},"title":"Wave Shape Editor","id":"lgUJ","favorite_count":"25"},"stat":"ok"}