{"code":{"thumbnail":"http://wonderfl.net/images/capture/8/8f/8f92/8f924c5a80fad2eea17834114719f303ec020f81_100.jpg?t=1319481860","parent":"enj6","as3":"// forked from keim_at_Si's Clear Water [Stage3D version]\n// forked from keim_at_Si's Clear Water with refraction rendering forked from: 3D陋얼록 / Water 3D\n// forked from saharan's 3D陋얼록 / Water 3D\npackage {\n    import flash.system.LoaderContext;\n    import flash.display.*;\n    import flash.events.*;\n    import flash.geom.*;\n    import flash.text.*;\n    import flash.net.*;\n    import com.bit101.components.*;\n    import net.hires.debug.*;\n    \n    import com.adobe.utils.*;\n    import flash.display3D.*;\n    import flash.display3D.textures.*;\n    //import org.si.ptolemy.*;\n\n    public class main extends Sprite {\n        private const NUM_DETAILS:int = 48;\n        private const INV_NUM_DETAILS:Number = 1 / NUM_DETAILS;\n        private const MESH_SIZE:Number = 100;\n        private const SURFACE_DETAILS:int = NUM_DETAILS-4;\n        private const VCOUNT:int = SURFACE_DETAILS * SURFACE_DETAILS;\n        private const VBUFFER_SIZE:int = 7; // x,y,z,u,v,u,v\n        private const CBUFFER_SIZE:int = 7; // x,y,z,u,v,u,v\n        private var count:uint;\n        private var bmd:BitmapData, bmd2:BitmapData, bmd3:BitmapData;\n        private var loader:Loader, loader2:Loader;\n        private var vertices:Vector.<Number>;\n        private var indices:Vector.<int>;\n        private var causticVertices:Vector.<Number>;\n        private var heights:Vector.<Number>;\n        private var velocity:Vector.<Number>;\n        \n/*      // for local\n        private var refractionTexture:String = \"_env1.png\";\n        private var reflectionTexture:String = \"_env2.png\";\n/*/     // for wonderfl\n        private var refractionTexture:String = \"http://assets.wonderfl.net/images/related_images/b/b2/b217/b2177f87d979a28b9bcbb6e0b89370e77ce22337\";\n        private var reflectionTexture:String = \"http://assets.wonderfl.net/images/related_images/b/bb/bbf1/bbf12c60cf84e5ab43e059920783d036da25df48\";\n//*/\n        private var container:Sprite;\n        private var viewedAngleH:Number = 0;\n        private var viewedAngleV:Number = -20 * 0.017453292519943295;\n        private var cameraDistance:Number = MESH_SIZE;\n        private var focalLength:Number = MESH_SIZE * 4;\n        private var boxHeight:Number = MESH_SIZE*0.75;\n        private var refractiveIndex:Number = 1.4;\n        private var reflectionRatio:Number = 0.4;\n        private var enableCaustic:Boolean = true;\n        \n        private var cameraPosition:Vector3D = new Vector3D();\n\n        // molehill\n        private var ptolemy:TinyPtolemy;\n        private var projectionMatrix:PerspectiveMatrix3D = new PerspectiveMatrix3D();\n        private var modelviewMatrix:Matrix3D = new Matrix3D();\n        private var matrix3D:Matrix3D = new Matrix3D();\n        \n        private var vertexBuffer:VertexBuffer3D;\n        private var normalBuffer:VertexBuffer3D;\n        private var indexBuffer:IndexBuffer3D;\n        private var causticVertexBuffer:VertexBuffer3D;\n        private var program:Program3D, program_oss:Program3D;\n        private var tex:Texture, tex2:Texture, tex3:Texture, oss:Texture;\n        private var asm:AGALMiniAssembler = new AGALMiniAssembler();\n        \n        \n        \n\n    //-------------------------------------------------- constructor\n        function main() : void {\n            Wonderfl.disable_capture();\n            // create surface\n            var i:int, j:int, idx:int, px:Number, py:Number;\n            vertices = new Vector.<Number>(VCOUNT * VBUFFER_SIZE, true);\n            causticVertices = new Vector.<Number>(VCOUNT * CBUFFER_SIZE, true);\n            for (i = 0; i < VCOUNT; i++) {\n                vertices[i*VBUFFER_SIZE]   = ((int(i/SURFACE_DETAILS)+2) * INV_NUM_DETAILS - 0.5) * MESH_SIZE;\n                vertices[i*VBUFFER_SIZE+1] = ((int(i%SURFACE_DETAILS)+2) * INV_NUM_DETAILS - 0.5) * MESH_SIZE;\n                vertices[i*VBUFFER_SIZE+2] = 0;\n                px = (int(i/SURFACE_DETAILS)) / SURFACE_DETAILS;\n                py = (int(i%SURFACE_DETAILS)) / SURFACE_DETAILS;\n                causticVertices[i*CBUFFER_SIZE]   = (px - 0.5) * MESH_SIZE;\n                causticVertices[i*CBUFFER_SIZE+1] = (0.5 - py) * MESH_SIZE;\n                causticVertices[i*CBUFFER_SIZE+2] = MESH_SIZE*0.8660254037844386; // 3^0.5 * 0.5\n                causticVertices[i*CBUFFER_SIZE+3] = px;\n                causticVertices[i*CBUFFER_SIZE+4] = py;\n            }\n            indices = new Vector.<int>();\n            for (i=1; i<SURFACE_DETAILS; i++) for (j=1; j<SURFACE_DETAILS; j++) {\n                idx = j * SURFACE_DETAILS + i;\n                indices.push(idx-SURFACE_DETAILS-1, idx-SURFACE_DETAILS, idx, idx-SURFACE_DETAILS-1, idx, idx-1);\n            }\n            \n            // create field\n            heights = new Vector.<Number>(NUM_DETAILS * NUM_DETAILS, true);\n            velocity = new Vector.<Number>(NUM_DETAILS * NUM_DETAILS, true);\n            for (i = 0; i < NUM_DETAILS * NUM_DETAILS; i++) velocity[i] = heights[i] = 0;\n            \n            addEventListener(Event.ADDED_TO_STAGE, setup);\n        }\n\n        private function setup(e:Event) : void {\n            e.target.removeEventListener(e.type, arguments.callee);\n            // load resource\n            ptolemy = new TinyPtolemy(this, 8, 8, 450, 450);\n            ptolemy.addEventListener(Event.CONTEXT3D_CREATE, loaded);\n            loader = new Loader();\n            loader.load(new URLRequest(refractionTexture), new LoaderContext(true));\n            loader.contentLoaderInfo.addEventListener(Event.COMPLETE, loaded);\n            loader2 = new Loader();\n            loader2.load(new URLRequest(reflectionTexture), new LoaderContext(true));\n            loader2.contentLoaderInfo.addEventListener(Event.COMPLETE, loaded);\n        }\n        \n        private function loaded(e:Event) : void {\n            e.target.removeEventListener(e.type, arguments.callee);\n            if (loader.content && loader2.content && ptolemy.context3D) {\n                bmd  = Bitmap(loader.content).bitmapData;\n                bmd2 = Bitmap(loader2.content).bitmapData;\n                createCausticTexture();\n                \n                // setup buffers\n                var uindices:Vector.<uint> = new Vector.<uint>(indices.length, true);\n                for (var i:int=0; i<uindices.length; i++) uindices[i] = indices[i];\n                vertexBuffer = ptolemy.context3D.createVertexBuffer(VCOUNT, VBUFFER_SIZE);\n                causticVertexBuffer = ptolemy.context3D.createVertexBuffer(VCOUNT, CBUFFER_SIZE);\n                indexBuffer = ptolemy.context3D.createIndexBuffer(uindices.length);\n                indexBuffer.uploadFromVector(uindices, 0, uindices.length);\n                program = ptolemy.context3D.createProgram();\n                program.upload(asm.assemble(\"vertex\", vs), asm.assemble(\"fragment\", fs));\n                program_oss = ptolemy.context3D.createProgram();\n                program_oss.upload(asm.assemble(\"vertex\", vs), asm.assemble(\"fragment\", fsoss));\n                \n                // setup textures\n                tex = ptolemy.context3D.createTexture(512, 512, \"bgra\", false);\n                tex.uploadFromBitmapData(bmd);\n\n                tex2 = ptolemy.context3D.createTexture(512, 512, \"bgra\", false);\n                tex2.uploadFromBitmapData(bmd2);\n\n                tex3 = ptolemy.context3D.createTexture(128, 128, \"bgra\", false);\n                tex3.uploadFromBitmapData(bmd3);\n                oss = ptolemy.context3D.createTexture(512, 512, \"bgra\", true);\n                \n                \n                projectionMatrix.perspectiveFieldOfViewLH(60/180*3.141592653589793, 1, 1, 200);\n                \n                addChild(container = new Sprite());\n                container.x = container.y = 8;\n                container.graphics.beginFill(0);\n                container.graphics.drawRect(0,0,180,98);\n                container.graphics.endFill();\n                new HUISlider(container, 0,  0, \"Angle\", function(e:Event):void { viewedAngleV = -e.target.value*0.017453292519943295;}).setSliderParams(0, 80, 20);\n                new HUISlider(container, 0, 20, \"Rotation\", function(e:Event):void { viewedAngleH = -e.target.value*0.017453292519943295;}).setSliderParams(-180, 180, 0);\n                new HUISlider(container, 0, 40, \"Refraction\", function(e:Event):void { refractiveIndex = e.target.value;}).setSliderParams(1, 3, 1.4);\n                new HUISlider(container, 0, 60, \"Reflection\", function(e:Event):void { reflectionRatio = e.target.value;}).setSliderParams(0, 1, 0.4);\n                new CheckBox(this, 10, 84, \"Caustics\", function(e:Event):void { enableCaustic = e.target.selected;}).selected = enableCaustic;\n                var driverInfo:TextField = new TextField();\n                driverInfo.textColor = 0xffffff;\n                driverInfo.width = 450;\n                driverInfo.y = 435;\n                driverInfo.text = ptolemy.context3D.driverInfo;\n                container.addChild(driverInfo);\n                addAllEventListeners();\n            }\n        }\n        \n        private function createCausticTexture() : void {\n            bmd3 = new BitmapData(128, 128, false, 0x404040);\n            var shape:Shape = new Shape(), g:Graphics = shape.graphics, m:Matrix=new Matrix();\n            m.createGradientBox(96, 96);\n            g.beginGradientFill(\"radial\", [0xd0d0d0,0x808080,0x404040], [1,1,1], [0,48,255], m);\n            g.drawRect(0, 0, 96, 96);\n            g.endFill();\n            bmd3.draw(shape, new Matrix(1,0,0,1,16,48));\n        }\n        \n        private function addAllEventListeners() : void {\n            // add all listeners     \n            stage.addEventListener(MouseEvent.MOUSE_DOWN, mouseDown);\n            addEventListener(Event.ENTER_FRAME, frame);\n            count = 0;\n        }\n        \n    //-------------------------------------------------- events\n        private function mouseDown(e:MouseEvent) : void {\n            stage.addEventListener(MouseEvent.MOUSE_UP, mouseUp);\n            stage.addEventListener(MouseEvent.MOUSE_MOVE, mouseDrag);\n            ripple((232.5 - mouseY) / 465, (mouseX -232.5) / 465, 20);\n        }\n        \n        private function mouseUp(e:MouseEvent) : void {\n            stage.removeEventListener(MouseEvent.MOUSE_UP, mouseUp);\n            stage.removeEventListener(MouseEvent.MOUSE_MOVE, mouseDrag);\n        }\n        \n        private function mouseDrag(e:MouseEvent) : void {\n            ripple((232.5 - mouseY) / 465, (mouseX -232.5) / 465, 3);\n        }\n        \n        private function ripple(mx:Number, my:Number, intensity:Number) : void {\n            var i:int, j:int, idx:int, dx:Number, dy:Number, acc:Number, imin:int, jmin:int, imax:int, jmax:int,\n                sin:Number = Math.sin(viewedAngleH), cos:Number = Math.cos(viewedAngleH);\n            dx =  mx * cos + my * sin;\n            dy = -mx * sin + my * cos;\n            mx = (dx + 0.5) * NUM_DETAILS;\n            my = (dy + 0.5) * NUM_DETAILS;\n            imin = (mx > 5) ? int(mx - 3) : 2;\n            jmin = (my > 5) ? int(my - 3) : 2;\n            imax = (mx < NUM_DETAILS-5) ? int(mx + 4) : (NUM_DETAILS - 1);\n            jmax = (my < NUM_DETAILS-5) ? int(my + 4) : (NUM_DETAILS - 1);\n            for (i=imin; i<imax; i++) for (j=jmin; j<jmax; j++) {\n                dx = mx - i;\n                dy = my - j;\n                acc = 3 - Math.sqrt(dx * dx + dy * dy);\n                if (acc > 0) velocity[j*NUM_DETAILS+i] += acc*intensity;\n            }\n        }\n        \n    //-------------------------------------------------- on each frame\n        private function frame(e:Event = null):void {\n            count++;\n            move();\n            setMesh();\n            molehill_draw();\n        }\n\n        private function move():void {\n            // ---Water simulation---\n            var i:int, j:int, idx:int, v:Number, imax:int, jmax:int;\n            imax = jmax = NUM_DETAILS - 1;\n            for (i=1; i<imax; i++) for (j=1; j<jmax; j++) {\n                idx = j * NUM_DETAILS + i;\n                heights[idx] += velocity[idx];\n                if (heights[idx] > 100) heights[idx] = 100;\n                else if (heights[idx] < -100) heights[idx] = -100;\n            }\n            for (i=1; i<imax; i++) for (j=1; j<jmax; j++) {\n                idx = j * NUM_DETAILS + i;\n                v = -heights[idx] * 4; idx-=NUM_DETAILS;\n                v += heights[idx];     idx+=NUM_DETAILS-1;\n                v += heights[idx];     idx+=2;\n                v += heights[idx];     idx+=NUM_DETAILS-1;\n                v += heights[idx];     idx-=NUM_DETAILS;\n                velocity[idx] = (velocity[idx] + v * 0.5) * 0.9;\n            }\n            \n            // change view\n            modelviewMatrix.identity();\n            modelviewMatrix.prependTranslation(0, 0, cameraDistance);\n            modelviewMatrix.prependRotation(-viewedAngleV*57.29577951308232, Vector3D.X_AXIS);\n            modelviewMatrix.prependRotation(-viewedAngleH*57.29577951308232, Vector3D.Z_AXIS);\n            _invmat.copyFrom(modelviewMatrix);\n            _invmat.invert();\n            _invmat.copyColumnTo(3, cameraPosition);\n        }\n        private var _invmat:Matrix3D = new Matrix3D();\n\n        private function setMesh():void {\n            var i:int, j:int, index:int, len:Number, u:Number, v:Number,\n                t:Number, s:Number, r:Number, hitz:Number, sign:Number,\n                vx:Number, vy:Number, vz:Number, \n                nx:Number, ny:Number, nz:Number, \n                dx:Number, dy:Number, dz:Number, \n                rimo:Number = refractiveIndex - 1,\n                xymax:Number = MESH_SIZE * 0.45, //MESH_SIZE * 0.5,\n                ixymax:Number = 1 / xymax;\n            \n            for (i = 0; i < SURFACE_DETAILS; i++) {\n                for (j = 0; j < SURFACE_DETAILS; j++) {\n                    index = (j * SURFACE_DETAILS + i) * VBUFFER_SIZE;\n                    len = heights[(j+2)*NUM_DETAILS+i+2];\n                    vx = vertices[index]; index++;\n                    vy = vertices[index]; index++;\n                    vz = vertices[index] = len * 0.25; index++;\n                    \n                    // Sphere map\n                    nx = (len - heights[(j+2)*NUM_DETAILS+i+1]) * 0.25;\n                    ny = (len - heights[(j+1)*NUM_DETAILS+i+2]) * 0.25;\n                    nz = 1 / Math.sqrt(nx * nx + ny * ny + 1);\n                    nx *= nz;\n                    ny *= nz;\n                    \n                    // Refraction map\n                    // incident vector (you can calculate them in the setup if you want faster)\n                    dx = vx - cameraPosition.x;\n                    dy = vy - cameraPosition.y;\n                    dz = vz - cameraPosition.z;\n                    len = 1 / Math.sqrt(dx * dx + dy * dy + dz * dz);\n                    dx *= len;\n                    dy *= len;\n                    dz *= len;\n                    // output vector\n                    t = (dx * nx + dy * ny + dz) * rimo;\n                    dx += nx * t;\n                    dy += ny * t;\n                    dz += nz * t;\n                    // uv coordinate\n                    if (dx == 0) {\n                        if (dy == 0) {\n                            u = v = 0.5;\n                            sign = 0;\n                        } else sign = (dy < 0) ? -1 : 1;\n                    } else {\n                        sign = (dx < 0) ? -1 : 1;\n                        t = (sign * xymax - vx) / dx;\n                        s = t * dy + vy;\n                        if (-xymax < s && s < xymax) {\n                            hitz = t * dz + vz;\n                            if (hitz > boxHeight) {\n                                r = (boxHeight-vz) / dz;\n                                u = (dx * r + vx) * ixymax * 0.25 + 0.5;\n                                v = (dy * r + vy) * ixymax * 0.25 + 0.5;\n                            } else {\n                                r = boxHeight / (hitz + boxHeight);\n                                u = sign       * r * 0.5 + 0.5;\n                                v = s * ixymax * r * 0.5 + 0.5;\n                            }\n                            sign = 0;\n                        } else sign = (dy < 0) ? -1 : 1;\n                    }\n                    if (sign != 0) {\n                        t = (sign * xymax - vy) / dy;\n                        s = t * dx + vx;\n                        hitz = t * dz + vz;\n                        if (hitz > boxHeight) {\n                            r = (boxHeight-vz) / dz;\n                            u = (dx * r + vx) * ixymax * 0.25 + 0.5;\n                            v = (dy * r + vy) * ixymax * 0.25 + 0.5;\n                        } else {\n                            r = boxHeight / (hitz + boxHeight);\n                            u = s * ixymax * r * 0.5 + 0.5;\n                            v = sign       * r * 0.5 + 0.5;\n                        }\n                    }\n                    // set vertices\n                    s = nx * 0.5 + 0.5;\n                    t = ny * 0.5 + 0.5;\n                    vertices[index] = s + ((i - NUM_DETAILS * 0.5) * INV_NUM_DETAILS * 0.25); index++;\n                    vertices[index] = t + ((NUM_DETAILS * 0.5 - j) * INV_NUM_DETAILS * 0.25); index++;\n                    vertices[index] = u; index++;\n                    vertices[index] = v; \n                    index = (j * SURFACE_DETAILS + i) * CBUFFER_SIZE + 5;\n                    causticVertices[index] = s; index++;\n                    causticVertices[index] = t;\n                }\n            }\n        }\n        \n        \n        private function molehill_draw() : void {\n            var context3D:Context3D = ptolemy.context3D;\n            \n            context3D.setProgramConstantsFromVector(\"vertex\", 9, Vector.<Number>([0,0.5,1,2]));\n            context3D.setProgramConstantsFromVector(\"fragment\", 0, Vector.<Number>([reflectionRatio,1-reflectionRatio,1,2]));\n            \n            matrix3D.copyFrom(projectionMatrix);\n\n            var refmap:Texture = tex2;\n            if (enableCaustic) {\n                causticVertexBuffer.uploadFromVector(causticVertices, 0, VCOUNT);\n                context3D.setRenderToTexture(oss);\n                context3D.clear(0, 0, 0, 1);\n                context3D.setDepthTest(false, \"never\");\n                context3D.setCulling(Context3DTriangleFace.NONE);\n                context3D.setProgram(program_oss);\n                context3D.setProgramConstantsFromMatrix(\"vertex\", 0, matrix3D, true);\n                context3D.setTextureAt(0, tex2);\n                context3D.setTextureAt(1, tex3);\n                context3D.setVertexBufferAt(0, causticVertexBuffer, 0, Context3DVertexBufferFormat.FLOAT_3);\n                context3D.setVertexBufferAt(1, causticVertexBuffer, 3, Context3DVertexBufferFormat.FLOAT_2);\n                context3D.setVertexBufferAt(2, causticVertexBuffer, 5, Context3DVertexBufferFormat.FLOAT_2);\n                context3D.drawTriangles(indexBuffer, 0, indices.length/3);\n                refmap = oss;\n            }\n\n            matrix3D.prepend(modelviewMatrix);\n            vertexBuffer.uploadFromVector(vertices, 0, VCOUNT);\n            context3D.setRenderToBackBuffer();\n            context3D.clear(0.2, 0.2, 0.2, 1);\n            context3D.setDepthTest(true, \"less\");\n            context3D.setCulling(Context3DTriangleFace.BACK);\n            context3D.setProgram(program);\n            context3D.setProgramConstantsFromMatrix(\"vertex\", 0, matrix3D, true);\n            context3D.setTextureAt(0, tex);\n            context3D.setTextureAt(1, refmap);\n            context3D.setVertexBufferAt(0, vertexBuffer, 0, Context3DVertexBufferFormat.FLOAT_3);\n            context3D.setVertexBufferAt(1, vertexBuffer, 3, Context3DVertexBufferFormat.FLOAT_2);\n            context3D.setVertexBufferAt(2, vertexBuffer, 5, Context3DVertexBufferFormat.FLOAT_2);\n            context3D.drawTriangles(indexBuffer, 0, indices.length/3);\n            \n            context3D.present();\n        }\n    }\n}\n\n\n// off screen surface render\nvar fsoss:String = <agalCode><![CDATA[\ntex ft0, v0.xy, fs0 <2d,clamp,nearest>\ntex ft1, v1.xy, fs1 <2d,clamp,nearest>\nmul ft1, ft1, fc0.w\nsat ft2, ft1\nsub ft1, ft1, fc0.z\nsat ft3, ft1\nadd ft0, ft0, ft3\nmul oc, ft0, ft2\n]]></agalCode>;\n// hardlight = (fg<0.5)?(bg*fg*2):(bg+fg*2-1)\n\n\n// render\nvar vs:String = <agalCode><![CDATA[\nmov vt0.xyz, va0.xyz\nmov vt0.w, vc9.z\nm44 op, vt0, vc0\nmov v0, va1\nmov v1, va2\n]]></agalCode>;\n\nvar fs:String = <agalCode><![CDATA[\ntex ft0, v0.xy, fs0 <2d,clamp,nearest>\ntex ft1, v1.xy, fs1 <2d,clamp,nearest>\nmul ft0, ft0, fc0.x\nmul ft1, ft1, fc0.y\nadd oc, ft0, ft1\n]]></agalCode>;\n\n\n\n\n\nimport flash.events.*;\nimport flash.display.*;\nimport flash.display3D.*;\n\nclass TinyPtolemy extends EventDispatcher {\n    public var context3D:Context3D;\n    \n    function TinyPtolemy(parent:DisplayObjectContainer, xpos:Number, ypos:Number ,width:int, height:int) : void {\n        var stage:Stage = parent.stage, stage3D:Stage3D = stage.stage3Ds[0];\n        stage.scaleMode = StageScaleMode.NO_SCALE;\n        stage.align = StageAlign.TOP_LEFT;\n        stage.quality = StageQuality.LOW;\n        stage3D.x = xpos;\n        stage3D.y = ypos;\n        stage3D.addEventListener(Event.CONTEXT3D_CREATE, function(e:Event):void{\n            context3D = e.target.context3D;\n            if (context3D) {\n                context3D.enableErrorChecking = true;                   // check internal error\n                context3D.configureBackBuffer(width, height, 0, true);  // disable AA/ enable depth/stencil\n                context3D.setRenderToBackBuffer();\n                context3D.setBlendFactors(Context3DBlendFactor.SOURCE_ALPHA, Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA);\n                context3D.setCulling(Context3DTriangleFace.BACK);       // culling back face\n                dispatchEvent(e.clone());\n            } else {\n                dispatchEvent(new ErrorEvent(ErrorEvent.ERROR, false, false, \"Context3D not found\"));\n            }\n        });\n        stage3D.requestContext3D();\n    }\n}\n\n","modified_date":1319481876,"compile_ok":"1","created_date":1319121135,"forked_count":"10","license":"MIT","swf":"http://swf.wonderfl.net/swf/usercode/8/8f/8f92/8f924c5a80fad2eea17834114719f303ec020f81.swf","diff":"109","user":{"icon":"http://wonderfl.net/images/icon/2/27/278a/278afc585a0a283d6e1f13f081cfd9c377ab9db2m","name":"keim_at_Si"},"title":"Clear Water with caustics [Stage3D version]","id":"ku5I","favorite_count":"38"},"stat":"ok"}