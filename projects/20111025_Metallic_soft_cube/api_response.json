{"code":{"thumbnail":"http://wonderfl.net/images/capture/f/fc/fc9c/fc9c6893fb35356c810c3e2b633fa11c4fb46dde_100.jpg?t=1319481421","parent":null,"as3":"package {\n    import flash.display.*;\n    import flash.events.*;\n    import flash.utils.*;\n    import flash.geom.*;\n    import flash.text.*;\n    import flash.net.*;\n    \n    import com.adobe.utils.*;\n    import com.bit101.components.*;\n    import flash.display3D.*;\n    import flash.display3D.textures.*;\n    //import org.si.ptolemy.*;\n    //import org.si.ptolemy.core.*;\n\n    public class main extends Sprite {\n/*      // for local\n        private const cceURL:String = \"cce.swf\";\n        private const envURL:String = \"_env1.png\";\n/*/     // for wonderfl\n        private const cceURL:String = \"http://swf.wonderfl.net/swf/usercode/6/67/679c/679c3b410a599d83b3548ce73ce37b873ae4046b.swf?t=1319478894168\";\n        private const envURL:String = \"http://assets.wonderfl.net/images/related_images/b/b2/b217/b2177f87d979a28b9bcbb6e0b89370e77ce22337\";\n//*/\n        \n        private var container:Sprite;\n        private var ptolemy:Ptolemy;\n        \n        private var asm:AGALMiniAssembler = new AGALMiniAssembler();\n        private var programs:Vector.<Program3D> = new Vector.<Program3D>();\n\n        private var _boxVertex:Vector.<Vector3D> = new Vector.<Vector3D>();\n        private var _sphVertex:Vector.<Vector3D> = new Vector.<Vector3D>();\n        private var _sphNormal:Vector.<Vector3D> = new Vector.<Vector3D>();\n        private var _effector:Vector.<Vector.<Number>> = new Vector.<Vector.<Number>>();\n        private var _gravPoints:Vector.<Vector3D> = new Vector.<Vector3D>(8);\n        private var _amplitude:Vector.<Number> = new Vector.<Number>(8);\n        private var _mesh:Mesh = new Mesh(\"V3N3\");\n        \n        private var _ifreq:Number;\n        private var _phase:Number;\n        private var _rotx:Number;\n\n        private var _ambVector:Vector.<Number> = Vector.<Number>([0.2,0.2,0.3,1]);\n        private var _difVectorDif:Vector.<Number> = Vector.<Number>([0.4,0.4,0.6,1]); \n        private var _col:uint = 0x80c0e0;\n        private var _amb:Number = 0.3;\n        private var _dif:Number = 0.9;\n        private var _ref:Number = 0.25;\n        private var _pow:Number = 16;\n        private var _spc:Number = 200;\n        private var _var:Number = 0.5;\n        private var _shp:Number = 0.5;\n        private var _specMap:BitmapData;\n        private var _specTex:Texture;\n        private var _shpereMap:BitmapData;\n        private var _shpereTex:Texture;\n        \n        private var _startTime:Number;\n        private var _lightPosition:Vector3D = new Vector3D();\n        private var _halfVector:Vector3D = new Vector3D();\n        \n        function main() {\n            Wonderfl.disable_capture();\n            ptolemy = new Ptolemy(this, 8, 8, 450, 450);\n            ptolemy.addEventListener(Event.COMPLETE, setup);\n            ptolemy.load(new URLRequest(cceURL), \"cce\", \"img\", true);\n            ptolemy.load(new URLRequest(envURL), \"env\", \"img\", true);\n        }\n        \n        \n        private function setup(e:Event) : void {\n            var px:Number, py:Number, i:int, j:int, k:int, i0:int;\n            var context3D:Context3D = ptolemy.context3D, prog:Program3D;\n            removeEventListener(Event.COMPLETE, setup);\n            \n            context3D.enableErrorChecking = true;\n            \n            // create shape \n            for (i=0; i<8; i++) {\n                _gravPoints[i] = new Vector3D(((i&1)<<1)*120-120, (i&2)*120-120, ((i&4)>>1)*120-120);\n                _amplitude[i] = 1;\n            }\n            for (px=-84; px<90; px+=12) for (py=-84; py<90; py+=12) {\n                _vertex( px, py, 84);\n                _vertex( px,-py,-84);\n                _vertex( py, 84, px);\n                _vertex(-py,-84, px);\n                _vertex( 84, px, py);\n                _vertex(-84, px,-py);\n            }\n            for (i=0; i<14; i++) for (j=0; j<14; j++) for (k=0; k<6; k++) {\n                i0 = (i*15+j)*6+k;\n                _mesh.qface(i0, i0+6, i0+90, i0+96);\n            }\n            _mesh.vertexCount = _boxVertex.length;\n            _mesh.allocateBuffer(context3D);\n            _mesh.upload(false, true);\n            \n            _shpereMap = ptolemy.resources[\"env\"].bitmapData;\n            _shpereTex = context3D.createTexture(512, 512, \"bgra\", false);\n            _shpereTex.uploadFromBitmapData(_shpereMap);\n            _specMap = new BitmapData(256, 1, false, 0);\n            _specTex = context3D.createTexture(256, 1, \"bgra\", false);\n            context3D.setTextureAt(0, _specTex);\n            context3D.setTextureAt(1, _shpereTex);\n            for (i=0; i<shaders.length; i++) {\n                prog = context3D.createProgram();\n                prog.upload(asm.assemble(\"vertex\", shaders[i].vs), asm.assemble(\"fragment\", shaders[i].fs));\n                programs.push(prog);\n            }\n            context3D.setProgramConstantsFromVector(\"vertex\",   9, Vector.<Number>([0, 0.5, 1, 2]));\n            context3D.setProgramConstantsFromVector(\"fragment\", 9, Vector.<Number>([0, 0.5, 1, 2]));\n            \n            addChild(container = new Sprite());\n            container.x = container.y = 8;\n            var ColorChooserEx:Class = ptolemy.resources[\"cce\"].getClass();\n            new ColorChooserEx(container, 0, 0, _col,  function(e:Event):void { _col = e.target.value; updateColor();});\n            new HUISlider(container, 0, 20, \"ambient\", function(e:Event):void { _amb = e.target.value; updateColor();}).setSliderParams(0,1,_amb);\n            new HUISlider(container, 0, 40, \"diffuse\", function(e:Event):void { _dif = e.target.value; updateColor();}).setSliderParams(0,1,_dif);\n            new HUISlider(container, 0, 60, \"power\",   function(e:Event):void { _pow = e.target.value; updateSpecMap();}).setSliderParams(0,64,_pow);\n            new HUISlider(container, 0, 80, \"specular\",function(e:Event):void { _spc = e.target.value; updateSpecMap();}).setSliderParams(0,255,_spc);\n            new HUISlider(container, 0, 100, \"refrection\",function(e:Event):void { _ref = e.target.value; }).setSliderParams(0,1,_ref);\n            new HUISlider(container, 0, 410, \"variance\",  function(e:Event):void { _var = e.target.value; updateSpecMap();}).setSliderParams(0,1,_var);\n            new HUISlider(container, 0, 430, \"shape\",     function(e:Event):void { _shp = e.target.value; }).setSliderParams(-1,1,_shp);\n            updateSpecMap();\n            updateColor();\n\n            _rotx = 0;\n            _startTime = getTimer();\n            addEventListener(Event.ENTER_FRAME, draw);\n            \n\n            _ifreq = 3.141592653589793/(60000/(80));\n        }\n        \n        private function _vertex(x:Number, y:Number, z:Number) : void {\n            var vec:Vector3D = new Vector3D(x, y, z),  nml:Vector3D = vec.clone(), sph:Vector3D,\n                effect:Vector.<Number> = new Vector.<Number>(8, true), i:int;\n            for (i=0; i<8; i++) {\n                effect[i] = (240 - Vector3D.distance(_gravPoints[i], vec)) / 100;\n                if (effect[i] < 0) effect[i] = 0;\n            }\n            nml.normalize();\n            sph = nml.clone();\n            sph.scaleBy(112);\n            _boxVertex.push(vec);\n            _sphVertex.push(sph);\n            _sphNormal.push(nml);\n            _effector.push(effect);\n        }\n\n        private function updateSpecMap() : void {\n            for (var i:int=0; i<256; i++) {\n                var c:int = int(Math.pow(i*0.0039215686, _pow)*_spc);\n                _specMap.setPixel32(i, 0, ((c<255)?c:255)*0x10101);\n            }\n            _specTex.uploadFromBitmapData(_specMap);\n\n        }\n        \n        private function updateColor() : void {\n            var r:Number = ((_col>>16)&255)*0.00392156862745098,\n                g:Number = ((_col>>8)&255)*0.00392156862745098,\n                b:Number = (_col&255)*0.00392156862745098, difamb:Number = _dif - _amb;\n            _difVectorDif[0] = r * difamb;\n            _difVectorDif[1] = g * difamb;\n            _difVectorDif[2] = b * difamb;\n            _ambVector[0] = r * _amb;\n            _ambVector[1] = g * _amb;\n            _ambVector[2] = b * _amb;\n        }\n        \n        private function draw(e:Event) : void {\n            var context3D:Context3D = ptolemy.context3D,\n                sigl:SiGLCore = ptolemy.sigl, \n                time:Number = getTimer() - _startTime;\n            \n            var i:int, imax:int = _mesh.vertexCount, j:int, idx:int, bv:Vector3D, sv:Vector3D, \n                vstep:int = _mesh.data32PerVertex, vertices:Vector.<Number> = _mesh.vertices;\n            \n            // geometry blending\n            _phase = time * 0.00005 + 0.1;\n            for (j=0; j<8; j++) {\n                _amplitude[j] = (Math.cos(time * _ifreq + j * _phase)) * _var + _shp;\n            }\n            \n            var rat:Number, eff:Vector.<Number>;\n            for (i=0; i<imax; i++) {\n                idx = i * vstep;\n                bv = _boxVertex[i];\n                sv = _sphVertex[i];\n                eff = _effector[i];\n                for (rat=0, j=0; j<8; j++) rat += eff[j] * _amplitude[j];\n                vertices[idx] = sv.x * (1-rat) + bv.x * rat; idx++;\n                vertices[idx] = sv.y * (1-rat) + bv.y * rat; idx++;\n                vertices[idx] = sv.z * (1-rat) + bv.z * rat;\n            }\n            _mesh.updateFaceNormal(true);\n            _mesh.upload(true, false);\n\n            _rotx += Math.sin(time*0.0002) * 3;\n            sigl.id().re(_rotx, time*0.02, time*0.05);\n            \n            // lighting vector\n            _lightPosition.x = 232-mouseX;\n            _lightPosition.y = mouseY-232;\n            _lightPosition.z = 50;\n            _lightPosition.normalize();\n            _halfVector.copyFrom(_lightPosition);\n            _halfVector.z += 1;\n            _halfVector.normalize();\n            _inv.copyFrom(sigl.modelViewMatrix);\n            _inv.invert();\n            var l:Vector3D = _inv.deltaTransformVector(_lightPosition);\n            var h:Vector3D = _inv.deltaTransformVector(_halfVector);\n            \n            // drawing\n            context3D.clear(0.125, 0.125, 0.125, 1);\n            context3D.setProgram(programs[0]);\n            context3D.setVertexBufferAt(0, _mesh.vertexBuffer, 0, Context3DVertexBufferFormat.FLOAT_3);\n            context3D.setVertexBufferAt(1, _mesh.vertexBuffer, 3, Context3DVertexBufferFormat.FLOAT_3);\n            context3D.setProgramConstantsFromMatrix(\"vertex\",   0, sigl.modelViewProjectionMatrix, true);\n            context3D.setProgramConstantsFromMatrix(\"vertex\",   4, sigl.modelViewMatrix, true);\n            context3D.setProgramConstantsFromVector(\"fragment\", 0, Vector.<Number>([l.x, l.y, l.z, 0]));\n            context3D.setProgramConstantsFromVector(\"fragment\", 1, Vector.<Number>([h.x, h.y, h.z, 0]));\n            context3D.setProgramConstantsFromVector(\"fragment\", 2, _ambVector);\n            context3D.setProgramConstantsFromVector(\"fragment\", 3, _difVectorDif);\n            context3D.setProgramConstantsFromVector(\"fragment\", 4, Vector.<Number>([_ref, 0, 0, 0]));\n            context3D.drawTriangles(_mesh.indexBuffer, 0, _mesh.indices.length/3);\n            context3D.present();\n        }\n        private var _inv:Matrix3D = new Matrix3D();\n    }\n}\n\n\n\nvar vs0:String = <agal><![CDATA[\nm44 op, va0, vc0\nnrm vt0.xyz, va1.xyz\nmov vt0.w, vc9.x\nmov v0, vt0\nm44 vt0, vt0, vc4\nmul vt0, vt0, vc9.yyy\nadd v1,  vt0, vc9.yyy\n]]></agal>;\nvar fs0:String = <agal><![CDATA[\ndp3 ft0, v0, fc0\nsat ft0, ft0\nmul ft0, fc3, ft0\nadd ft0, ft0, fc2\ndp3 ft1, v0, fc1\ntex ft3, ft1.xy, fs0 <2d,clamp,nearest>\ntex ft4, v1.xy, fs1 <2d,repeat,nearest>\nmul ft4, ft4, fc9.w\nsub ft4, ft4, fc9.z\nmul ft4, ft4, fc4.x\nsat ft2, ft4\nadd ft4, ft4, fc9.z\nsat ft1, ft4\nadd ft0, ft0, ft2\nmul ft0, ft0, ft1\nadd oc, ft0, ft3\n]]></agal>;\n\n\n\nvar shaders:Array = [\n{\"vs\":vs0,\"fs\":fs0}\n];\n\n\n\n\n\n/* Tiny Ptolemy */ {\n    import flash.net.*;\n    import flash.geom.*;\n    import flash.events.*;\n    import flash.system.*;\n    import flash.display.*;\n    import flash.display3D.*;\n    import com.adobe.utils.*;\n\n    /** Operation Center */\n    class Ptolemy extends EventDispatcher {\n    // variables ----------------------------------------\n        public var context3D:Context3D;\n        public var sigl:SiGLCore;\n        public var resources:* = {};\n\n        private var _loadedResourceCount:int;\n    // constructor ----------------------------------------\n        function Ptolemy(parent:DisplayObjectContainer, xpos:Number, ypos:Number ,width:int, height:int) : void {\n            var stage:Stage = parent.stage, stage3D:Stage3D = stage.stage3Ds[0];\n            stage.scaleMode = StageScaleMode.NO_SCALE;\n            stage.align = StageAlign.TOP_LEFT;\n            stage.quality = StageQuality.LOW;\n            stage3D.x = xpos; stage3D.y = ypos;\n            stage3D.addEventListener(Event.CONTEXT3D_CREATE, function(e:Event):void{\n                context3D = e.target.context3D;\n                if (context3D) {\n                    context3D.enableErrorChecking = true;                   // check internal error\n                    context3D.configureBackBuffer(width, height, 0, true);  // disable AA/ enable depth/stencil\n                    context3D.setBlendFactors(Context3DBlendFactor.SOURCE_ALPHA, Context3DBlendFactor.ONE_MINUS_SOURCE_ALPHA);\n                    context3D.setCulling(Context3DTriangleFace.BACK);       // culling back face\n                    context3D.setRenderToBackBuffer();\n                    sigl = new SiGLCore(width, height);\n                    dispatchEvent(e.clone());\n                    if (--_loadedResourceCount == 0) dispatchEvent(new Event(Event.COMPLETE));\n                } else dispatchEvent(new ErrorEvent(ErrorEvent.ERROR, false, false, \"Context3D not found\"));\n            });\n            stage3D.requestContext3D();\n            _loadedResourceCount = 1;\n        }\n    // load resource ----------------------------------------\n        public function load(urlRequest:URLRequest, id:String=null, type:String=null, checkPolicyFile:Boolean=false) : EventDispatcher {\n            var loader:Loader, urlLoader:URLLoader;\n            _loadedResourceCount++;\n            if (type == \"img\") {\n                loader = new Loader();\n                loader.load(urlRequest, new LoaderContext(checkPolicyFile));\n                loader.contentLoaderInfo.addEventListener(Event.COMPLETE, function(e:Event) : void {\n                    resources[id] = e.target.content;\n                    if (--_loadedResourceCount == 0) dispatchEvent(new Event(Event.COMPLETE));\n                });\n                return loader;\n            }\n            urlLoader = new URLLoader(urlRequest);\n            urlLoader.dataFormat = (type == \"txt\") ? URLLoaderDataFormat.TEXT : URLLoaderDataFormat.BINARY;\n            urlLoader.addEventListener(Event.COMPLETE, function(e:Event) : void {\n                resources[id] = e.target.data;\n                if (--_loadedResourceCount == 0) dispatchEvent(new Event(Event.COMPLETE));\n            });\n            return urlLoader;\n        }\n    }\n    \n    /** SiGLCore provides basic matrix operations. */\n    class SiGLCore {\n    // variables ----------------------------------------\n        public var modelViewMatrix:Matrix3D = new Matrix3D();\n        public var projectionMatrix:PerspectiveMatrix3D = new PerspectiveMatrix3D();\n        public var viewWidth:Number, viewHeight:Number;\n        private var _mvMatrixStac:Vector.<Matrix3D> = new Vector.<Matrix3D>();\n        private var _mvpMatrix:Matrix3D = new Matrix3D(), _mvpMatrixDirty:Boolean, _toDegree:Number, _toRadian:Number;\n        private var _cameraPosition:Vector3D = new Vector3D(0,0,0), _magnification:Number, _zNear:Number, _zFar:Number, _fieldOfView:Number;\n        static private var _tv:Vector.<Number> = new Vector.<Number>(16, true), _tm:Matrix3D = new Matrix3D();\n    // properties ----------------------------------------\n        public function get modelViewProjectionMatrix() : Matrix3D {\n            if (_mvpMatrixDirty) {\n                _mvpMatrix.copyFrom(projectionMatrix);\n                _mvpMatrix.prepend(modelViewMatrix);\n                _mvpMatrixDirty = false;\n            }\n            return _mvpMatrix;\n        }\n        public function get angleMode() : String { return (_toRadian == 1) ? \"radian\" : \"degree\"; }\n        public function set angleMode(mode:String) : void {\n            _toDegree = (mode == \"radian\") ? 57.29577951308232 : 1;\n            _toRadian = (mode == \"radian\") ? 1 : 0.017453292519943295;\n        }\n        public function get fieldOfView() : Number { return _fieldOfView / _toRadian; }\n        public function set fieldOfView(fov:Number) : void { _fieldOfView = fov * _toRadian; _updateProjectionMatrix(); }\n        public function get magnification() : Number { return _magnification; }\n        public function set magnification(mag:Number) : void { _magnification = mag; _updateProjectionMatrix(); }\n        public function get cameraPosition() : Vector3D { return _cameraPosition; }\n    // constructor ----------------------------------------\n        function SiGLCore(width:Number=1, height:Number=1) {\n            viewWidth = width;\n            viewHeight = height;\n            angleMode = \"degree\";\n            _zNear = -100;\n            _zFar = 100;\n            _magnification = 1;\n            modelViewMatrix.identity();\n            this.fieldOfView = 60;\n            _mvpMatrixDirty = true;\n        }\n    // matrix operations ----------------------------------------\n        public function forceUpdateMatrix() : SiGLCore { _mvpMatrixDirty = true; return this; }\n        public function setZRange(zNear:Number=-100, zFar:Number=100) : SiGLCore { _zNear = zNear; _zFar = zFar; _updateProjectionMatrix(); return this; }\n        public function clear() : SiGLCore { _mvMatrixStac.length = 0; return id(); }\n        public function id() : SiGLCore { modelViewMatrix.identity(); _mvpMatrixDirty = true; return this; }\n        public function push() : SiGLCore { _mvMatrixStac.push(modelViewMatrix.clone()); return this; }\n        public function pop() : SiGLCore { modelViewMatrix = _mvMatrixStac.pop(); return this; }\n        public function r(angle:Number, axis:Vector3D, pivotPoint:Vector3D = null) : SiGLCore { modelViewMatrix.prependRotation(angle*_toDegree, axis, pivotPoint); _mvpMatrixDirty = true; return this; }\n        public function s(scaleX:Number, scaleY:Number, scaleZ:Number=1) : SiGLCore { modelViewMatrix.prependScale(scaleX, scaleY, scaleZ); _mvpMatrixDirty = true; return this; }\n        public function t(x:Number, y:Number, z:Number=0) : SiGLCore { modelViewMatrix.prependTranslation(x, y, z); _mvpMatrixDirty = true; return this; }\n        public function re(angleX:Number, angleY:Number, angleZ:Number) : SiGLCore {\n            var rx:Number = angleX*_toRadian, ry:Number=angleY*_toRadian, rz:Number=angleZ*_toRadian,\n                sx:Number = Math.sin(rx), sy:Number = Math.sin(ry), sz:Number = Math.sin(rz), \n                cx:Number = Math.cos(rx), cy:Number = Math.cos(ry), cz:Number = Math.cos(rz);\n            _tv[0] = cz*cy; _tv[1] = sz*cy; _tv[2] = -sy; _tv[4] = -sz*cx+cz*sy*sx; _tv[5] = cz*cx+sz*sy*sx;\n            _tv[6] = cy*sx; _tv[8] = sz*sx+cz*sy*cx; _tv[9] = -cz*sx+sz*sy*cx;\n            _tv[10] = cy*cx; _tv[14] = _tv[13] = _tv[12] = _tv[11] = _tv[7] = _tv[3] = 0; _tv[15] = 1;\n            _tm.copyRawDataFrom(_tv); modelViewMatrix.prepend(_tm); _mvpMatrixDirty = true;\n            return this;\n        }\n        private function _updateProjectionMatrix() : void {\n            var aspect:Number = viewWidth / viewHeight;\n            _cameraPosition.z = (viewHeight * 0.5) / Math.tan(_fieldOfView * 0.5);\n            if (_zNear <= _cameraPosition.z) _zNear = _cameraPosition.z + 0.001;\n            projectionMatrix.perspectiveFieldOfViewRH(_fieldOfView, aspect, _zNear - _cameraPosition.z, _zFar - _cameraPosition.z);\n            projectionMatrix.prependTranslation(-_cameraPosition.x, -_cameraPosition.y, -_cameraPosition.z);\n            projectionMatrix.prependScale(_magnification, _magnification, _magnification);\n        }\n    }\n\n\n    /** Mesh */\n    class Mesh {\n    // variables ----------------------------------------\n        public var vertices:Vector.<Number> = new Vector.<Number>();\n        public var faces:Vector.<Face> = new Vector.<Face>();\n        public var vertexBuffer:VertexBuffer3D;\n        public var indexBuffer:IndexBuffer3D;\n        public var data32PerVertex:int;\n        private var _indices:Vector.<uint> = new Vector.<uint>(), _indexDirty:Boolean=true;\n        private var _normalOffset:int;\n    // properties ----------------------------------------\n        public function get vertexCount() : int { return vertices.length / data32PerVertex; }\n        public function set vertexCount(count:int) : void { vertices.length = count * data32PerVertex; }\n        public function get indices() : Vector.<uint> {\n            var idx:Vector.<uint> = _indices, f:Face, i:int, imax:int, j:int;\n            if (_indexDirty) {\n                idx.length = imax = faces.length * 3;\n                for (i=0,j=0; i<imax; j++) {\n                    f = faces[j];\n                    idx[i] = f.i0; i++;\n                    idx[i] = f.i1; i++;\n                    idx[i] = f.i2; i++;\n                }\n                _indexDirty = false;\n            }\n            return idx;\n        }\n    // contructor ----------------------------------------\n        function Mesh(bufferFormat:String=\"V3\") {\n            var res:* = /(V(\\d))(N(\\d))?(T(\\d))?(C(\\d))?/.exec(bufferFormat);\n            data32PerVertex = int(res[2]) + int(res[4]) + int(res[6]) + int(res[8]);\n            _normalOffset = (int(res[4]) > 0) ? int(res[2]) : -1;\n            this.data32PerVertex = data32PerVertex;\n        }\n    // oprations ----------------------------------------\n        public function allocateBuffer(context3D:Context3D) : Mesh {\n            vertexBuffer = context3D.createVertexBuffer(vertexCount, data32PerVertex);\n            indexBuffer  = context3D.createIndexBuffer(indices.length);\n            return this;\n        }\n        public function upload(vertex:Boolean=true, index:Boolean=true) : Mesh {\n            if (vertex) vertexBuffer.uploadFromVector(vertices, 0, vertexCount);\n            if (index) indexBuffer.uploadFromVector(indices, 0, indices.length);\n            return this;\n        }\n        public function qface(i0:int, i1:int, i2:int, i3:int) : Mesh {\n            faces.push(Face.alloc(i0, i1, i2), Face.alloc(i3, i2, i1));\n            _indexDirty = true;\n            return this;\n        }\n        public function updateFaceNormal(updateVertexNormal:Boolean=true) : Mesh {\n            var vtx:Vector.<Number> = vertices, vcount:int = vertexCount, fcount:int = faces.length, \n                i:int, istep:int, f:Face, iw:Number, fidx:int, \n                i0:int, i1:int, i2:int, n0:Vector3D, n1:Vector3D, n2:Vector3D, \n                x01:Number, x02:Number, y01:Number, y02:Number, z01:Number, z02:Number;\n            // calculate face normals\n            for (i=0; i<fcount; i++) {\n                f=faces[i];\n                i0=f.i0*data32PerVertex; i1=f.i1*data32PerVertex; i2=f.i2 * data32PerVertex;\n                x01 = vtx[i1]-vtx[i0]; x02 = vtx[i2]-vtx[i0]; i0++; i1++; i2++;\n                y01 = vtx[i1]-vtx[i0]; y02 = vtx[i2]-vtx[i0]; i0++; i1++; i2++;\n                z01 = vtx[i1]-vtx[i0]; z02 = vtx[i2]-vtx[i0];\n                f.normal.setTo(y02*z01-y01*z02, z02*x01-z01*x02, x02*y01-x01*y02);\n                f.normal.normalize();\n            }\n            // calculate vertex normals\n            if (updateVertexNormal && (_normalOffset != -1)) {\n                istep = data32PerVertex - 2;\n                // initialize\n                for (i=0, i0=_normalOffset; i<vcount; i++, i0+=istep) { vtx[i0]=0; i0++; vtx[i0]=0; i0++; vtx[i0]=0; }\n                // sum up\n                for (i=0; i<fcount; i++) {\n                    f = faces[i];\n                    i0 = f.i0 * data32PerVertex + _normalOffset;\n                    vtx[i0]+=f.normal.x; i0++; vtx[i0]+=f.normal.y; i0++; vtx[i0]+=f.normal.z;\n                    i0 = f.i1 * data32PerVertex + _normalOffset;\n                    vtx[i0]+=f.normal.x; i0++; vtx[i0]+=f.normal.y; i0++; vtx[i0]+=f.normal.z;\n                    i0 = f.i2 * data32PerVertex + _normalOffset;\n                    vtx[i0]+=f.normal.x; i0++; vtx[i0]+=f.normal.y; i0++; vtx[i0]+=f.normal.z;\n                }\n                /*  normalize vertex vector (if need)\n                for (i=0, i0=_normalOffset; i<vcount; i++, i0+=istep) {\n                    x01 = vtx[i0]; i0++; y01 = vtx[i0]; i0++; z01 = vtx[i0]; i0-=2;\n                    iw = 1 / Math.sqrt(x01*x01 + y01*y01 + z01*z01);\n                    vtx[i0] = x01 * iw; i0++; vtx[i0] = y01 * iw; i0++; vtx[i0] = z01 * iw;\n                }//*/\n            }\n            return this;\n        }\n    }\n\n\n    /** Face */\n    class Face {\n        public var i0:int, i1:int, i2:int, normal:Vector3D = new Vector3D();\n        function Face() { i0 = i1 = i2 = 0; }\n        static private var _freeList:Vector.<Face> = new Vector.<Face>();\n        static public function free(face:Face) : void { _freeList.push(face); }\n        static public function alloc(i0:int, i1:int, i2:int) : Face { \n            var f:Face = _freeList.pop() || new Face();\n            f.i0 = i0; f.i1 = i1; f.i2 = i2; return f;\n        }\n    }\n}\n\n","modified_date":1319997993,"compile_ok":"1","created_date":1319478917,"forked_count":"7","license":"MIT","swf":"http://swf.wonderfl.net/swf/usercode/f/fc/fc9c/fc9c6893fb35356c810c3e2b633fa11c4fb46dde.swf","diff":"0","user":{"icon":"http://wonderfl.net/images/icon/2/27/278a/278afc585a0a283d6e1f13f081cfd9c377ab9db2m","name":"keim_at_Si"},"title":"Metallic soft cube","id":"A2Hq","favorite_count":"74"},"stat":"ok"}